package SBV::STONE::AXIS;
#------------------------------------------------+
#    [APM] This moudle is generated by amp.pl    |
#    [APM] Creat time: 2013-05-31 11:15:29       |
#------------------------------------------------+
=pod

=head1 Name

SBV::STONE::AXIS

=head1 Synopsis

This module is not meant to be used directly

=head1 Feedback

Author: Peng Ai
Email:  aipeng0520@163.com

=head1 Version

Version history

=head2 v1.0

Date: 2013-05-31 11:15:29

=cut

use strict;
use warnings;
require Exporter;
our @ISA = qw(Exporter);

use Math::Round;
use FindBin;
use lib "$FindBin::RealBin";
use lib "$FindBin::RealBin/../";
use lib "$FindBin::RealBin/lib/";
use lib "$FindBin::RealBin/../lib";

use SBV::STAT;
use SBV::DEBUG;

#-------------------------------------------------------------------------------
#  name: new
#  func: create new axis object
#-------------------------------------------------------------------------------
sub new 
{
    my $class = shift;
    my $axis = {};
    my %param = @_;

    do_init_feature($axis);
    
    bless $axis , $class;
    $axis->feature(%param);
    return $axis;
}

#-------------------------------------------------------------------------------
#  name: doInitFeature
#  func: set the default feature for axis
#-------------------------------------------------------------------------------
sub do_init_feature
{
    my %feature = (
        # ox , oy , length => must be defined 
        show        => 1,
        angle       => 0,
        thickness   => 0,
        
        bone        => 0,
        tail        => 0, # the bone tail marker
        
        tick        => undef, # no draw tick/scale
        side        => "right", # right(outter) / left(inner)
        start       => 0.1, # 0 - 1 units
        
        show_tick_line  => 1, # draw ticks line or not
        size        => 8, # main ticks line length
        
        show_tick_label => 1,
        ticktext    => undef, # defined specific ticks text
        multiple    => 1,
        translate   => 0, # 0 - 1 units / general is 0.5 (for string ticks)

        theme       => undef, # the ticks text theme
        bgline      => 0, # draw background line or not

        labels      => undef, # add specific labels
        labels_theme => undef, 
        
        skip_first_tick => 1,
        skip_last_tick => 1,

        unit_label => "",
    );
    my $axis = shift;
    feature($axis,%feature);
}


#-------------------------------------------------------------------------------
#  name: check_features
#  func: check the needed feature was defined or not 
#        check the features were defined correctly or not
#-------------------------------------------------------------------------------
sub check_features
{
    my $self = shift;
    
    ERROR('axis_point_coord_err') unless (defined $self->{ox} && defined $self->{oy});
    ERROR('axis_length_err') unless (defined $self->{length});
    ERROR('axis_parent_err') unless (defined $self->{parent});
    # you can add other checks here 

    return 1;
}

#-------------------------------------------------------------------------------
#  name: feature
#  func: set the parameter for axis
#-------------------------------------------------------------------------------
sub feature
{
    my $self = shift;
    my %param = @_;
    foreach my$key(keys %param)
    {
        $self->{$key} = $param{$key};
    }
    return 1;
}

*aes = \&feature;

# draw the axis
sub plot
{
    my $self = shift;
    my %param = @_;
    $self->feature(%param);
    $self->check_features;
    
    # remove old axis group if exists
    $self->{parent}->removeChild($self->{group}) if (exists $self->{group});
    
    my ($ox,$oy) = ($self->{ox},$self->{oy});
    my $group = $self->{parent}->group(class=>"axis",transform=>"translate($ox,$oy)");
    $group->setAttribute("transform","translate($ox,$oy) rotate($self->{angle})") if (my$angle = $self->{angle});
    $self->{group} = $group;
    $self->normal_axis;
    
    $self->{parent}->removeChild($self->{group}) unless($self->{show});
}

# draw normal axis
sub normal_axis
{
    my $self = shift;
    my $group = $self->{group} or die "the axis group is not defined!";
    
    # draw bone
    if ($self->{bone})
    {
        my $bone = $group->line(x1=>0,y1=>0,x2=>$self->{length},y2=>0,class=>"axis");
        
        if ($self->{tail})
        {
            my $markid = SBV::DRAW::arrow(2*$self->{size},$self->{size},-zh=>0.5,-class=>"arrow");
            $bone->setAttribute("marker-end","url(#$markid)");
        };
    }
    
    if (defined $self->{tick})
    {
        $self->normal_tick;    
    }
}

# add tick on axis
sub normal_tick
{
    my ($self,%param) = @_;
    my $group = $self->{group} or die "the axis group is not defined";
    
    $self->feature(%param);
    return unless (defined $self->{tick});
    
    my $hi = $SBV::conf->{hspace};
    my $vi = $SBV::conf->{vspace};
    
    # font 
    my $font = SBV::Font->new($self->{theme});
    my $tickH = $font->fetch_text_height;

    # deal the dividing
    my @temp = split /\s+/ , $self->{tick};
    my $subNum = int( pop @temp ) if ($#temp == 3);
    my ($min,$max,$window) = @temp;
    my $zoom = ($max - $min + $self->{start} * $window) / $self->{'length'};
    my $markNum = int (($max-$min)/$window);
    my $markRm = ($max - $min) / $window - $markNum;
    $markNum -- if ($markRm == 0 && $self->{translate} == 0 && $self->{skip_last_tick});
    my $subwin = $window / $subNum if ($subNum);
    
    $self->feature(zoom=>$zoom,unit=>1/$zoom,min=>$min,max=>$max,window=>$window);
    my $startX = nearest 0.001 , $self->{start} * $window / $zoom;
    
    # draw ticks
    my $start_item = 0;
    $start_item = 1 if (0 == $self->{start} && 1 == $self->{skip_first_tick});
    #$start_item = 1 if (0 == $self->{start} && 1 == $self->{skip_first_tick} && 0 == $self->{translate});
    #my $start_item = (0 == $self->{translate} && 0 != $self->{start}) ? 0 : 1;
    
    if (0 == $self->{show_tick_line})
    {
        $self->{size} = 0;
    }
    
    foreach my$i ( $start_item .. $markNum )
    {
        my $tickX = nearest 0.01 , $startX + $i*$window/$zoom;
        
        # draw tick line
        if (1 == $self->{show_tick_line})
        {
            my $tickY2 = $self->{side} eq "left" ? -$self->{size} : $self->{size};
            $group->line(x1=>$tickX,x2=>$tickX,y1=>0,y2=>$tickY2,class=>"tick")
        }
        
        # draw bg line
        if ($self->{bgline} > 0)
        {
            my $bglineY2 = $self->{side} eq "left" ? $self->{bgline} : - $self->{bgline};
            unless ($self->{start} == 0 && $i == 0)
            {
                $group->line(x1=>$tickX,x2=>$tickX,y1=>0,y2=>$bglineY2,class=>"bgline");
            }
        }
        
        # draw tick text 
        if ($self->{show_tick_label})
        {
            # fetch the tick label
            my $tick_val = defined $self->{ticktext} ? 
                $self->{ticktext}->[$i-1] : $min+$i*$window*$self->{multiple};
            $tick_val .= $self->{unit_label} if ($self->{unit_label});
            
            # fetch the tick label width
            my $textW = $font->fetch_text_width($tick_val);

            # fetch the tick label true size
            # ($textW,$tickH) = true_size($textW,$tickH,$font->{'font-angle'});

            # fetch the tick label y coord
            my $textY = $self->{side} eq "left" ? 
                0 - $self->{size} - $vi : 0 + $self->{size} + $tickH + $vi; 
            my $textX = nearest 0.01 , $tickX - $self->{translate} * $window / $zoom;
            #$textX = $textX + $textW if (defined $font->{'font-angle'} && $font->{'font-angle'} == -90);
            #$textY = $textY - $tickH if (defined $font->{'font-angle'} && $font->{'font-angle'} == 90);
            
            $self->{theme} .= "hjust:0.5" unless $self->{theme};
            $self->{theme} .= ";hjust:0.5" unless $self->{theme} =~ /hjust:/;
            my $text = SBV::DRAW::theme_text($group,$textX,$textY,$self->{theme},$tick_val);
            
            if ($self->{label_mirror})
            {
                my$matrix = SBV::DRAW::mirror($textX+$textW/2,0,$textX+$textW/2,1);
                $text->setAttribute('transform',$matrix);
            }
        }

        # draw sub tick
        map {
            my $subtickY2 = $self->{side} eq "left" ? - $self->{size}/2 : $self->{size}/2;
            my $subtickX = $tickX + $_*$subwin/$zoom;
        } 1 .. $subNum - 1 if ($subNum && $subNum > 1 && $i != $markNum)
    }

    # add labels 
    my $labelFont = SBV::Font->new($self->{labels_theme});
    my $labelH = $labelFont->fetch_text_height;
    $tickH = 0 unless ( $self->{show_tick_label} ); 
    my $label_y = $self->{side} eq "left" ? 0 - $self->{size} - 2*$vi - $tickH : 0 + $self->{size} + $labelH + $tickH + 2*$vi;
    if ($self->{labels})
    {
        foreach my$label (@{$self->{labels}})
        {
            my ($pos,$name) = @$label;
            my $labelW = $labelFont->fetch_text_width($name);
            my $x = $self->fetch_dis($pos);
            my $label_text = $group->text(x=>$x-$labelW/2,y=>$label_y)->cdata($name);
        }
    }
}

# draw circular axis
sub circle_axis
{
    
}

# add circle tick on axis
sub circle_tick
{
    
}

#-------------------------------------------------------------------------------
#  other functions for axis
#-------------------------------------------------------------------------------
# turn the true coordinate to the svg distance (the [input] to original point)
# the tick must be defined
sub fetch_dis
{
    my ($self,$rawval) = @_;
    return nearest (0.0001, ($rawval - $self->{min} + $self->{start}*$self->{window})*$self->{unit});
}

sub fetch_coord
{
    my ($self,$val) = @_;
    return $self->{ox} + $self->fetch_dis($val);
}

sub thickness
{
    my $self = shift;
    my %param = %$self;

    my $thickness = 0;
    my $tick = $param{tick};
    my $size = $param{size} || 8;
    my $len = $param{length};
    my $ticktext = $param{ticktext};

    return $thickness unless ($tick);
    
    $thickness += $size if($param{show_tick_line});
    
    my $tickFont = SBV::Font->new($param{theme});
    
    my @ticks;
    if ($self->{ticktext})
    {
        @ticks = @{$self->{ticktext}};
    }
    else 
    {
        my @temp = split /\s+/ , $self->{tick};
        my $subNum = int( pop @temp ) if ($#temp == 3);
        my ($min,$max,$window) = @temp;
        my $markNum = int (($max-$min)/$window);
        my $markRm = ($max - $min) / $window - $markNum;
        $markNum -- if ($markRm == 0 && $self->{translate} == 0 && $self->{skip_last_tick});
        
        my $start_item = 0;
        $start_item = 1 if (0 == $self->{start} && 1 == $self->{skip_first_tick});
        
        @ticks = map { $min+$_*$window*$self->{multiple} } $start_item .. $markNum;
    }

    if ($self->{unit_label})
    {
        @ticks = map { $_ . $self->{unit_label} } @ticks;
    }

    my $tickH = $tickFont->fetch_true_text_height(\@ticks);
    
    my $vi = $SBV::conf->{vspace} || 4;

    # dividing
    my @temp = split /\s+/ , $tick;
    my $subNum = int( pop @temp ) if ($#temp == 3);
    my ($min,$max,$window) = @temp;
    my $tickNum = int (($max-$min)/$window); # tick number
    
    my @tickVal;
    if (defined $param{ticktext})
    {
        @tickVal = @{$param{ticktext}};
    }
    else
    {
        @tickVal = map { $_*$window+$min } 0 .. $tickNum;
        shift @tickVal unless (0 == $param{translate});
        @tickVal = map { $_*$param{multiple}} 0 .. $#tickVal if (defined $param{multiple});
    }
    
    my $tickW = $tickFont->fetch_max_text_width(\@tickVal);
    $thickness += $vi + $tickH if ($param{show_tick_label});
    
    # labels 
    my $labelFont = SBV::Font->new($param{labels_theme});
    my $labelH = $labelFont->fetch_true_text_height($self->{labels});
    $thickness += 2*$vi + $labelH if ($param{labels});

    $self->{thickness} = $thickness;
    return $thickness;
}
