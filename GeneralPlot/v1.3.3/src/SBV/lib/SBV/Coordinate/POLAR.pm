package SBV::Coordinate::POLAR;
#------------------------------------------------+
#    [APM] This moudle is generated by amp.pl    |
#    [APM] Created time: 2013-06-21 08:47:21     |
#------------------------------------------------+
=pod

=head1 Name

SBV::Coordinate::POLAR

=head1 Synopsis

This module is not meant to be used directly

=head1 Feedback

Author: Peng Ai
Email:  aipeng0520@163.com

=head1 Version

Version history

=head2 v1.0

Date: 2013-06-21 08:47:21

=cut

use strict;
use warnings;
require Exporter;
our @ISA = qw(Exporter);
our @EXPORT    = qw(theta2arc);

#use Math::Cephes qw(:trigs :constants);
use Math::Round;

use FindBin;
use lib "$FindBin::RealBin";
use lib "$FindBin::RealBin/lib";
use lib "$FindBin::RealBin/..";
use lib "$FindBin::RealBin/../lib";

use SBV::Constants;

# create new polar system with original point (cx,cy)
sub new 
{
	my $class = shift;

	my ($cx,$cy,%par) = @_;
	my $polar = {};
	$polar->{cx} = $cx;
	$polar->{cy} = $cy;
	$polar->{parent} = $par{parent} || $SBV::svg;

	bless $polar , $class; 

	return $polar;
}

# set the parent 
sub parent
{
	my $self = shift;
	$self->{parent} = shift;

	return 1;
}

# turn svg position coordinate to polar coordinate
# under build 
sub pos2polar
{
	my $self = shift;
	my $x = shift;
	my $y = shift;

	my $newx = $x - $self->{cx};
	my $newy = $self->{cy} - $y;

	my $r = sqrt($newx**2+$newy**2);
	my $theta = 0;
	
	if ($newx >= 0)
	{
		$theta = acos($newy/$r);
	}
	else
	{
		$theta = $PI + acos(-$newy/$r);
	}

	return ($r,$theta);
}

# turn polar coordinate to svg position coordinate 
sub polar2pos
{
	my $self = shift;
	my $r = shift;
	my $theta = shift;
	my $theta_type = shift || "arc";
	
	if ($theta_type eq "ratio")
	{
		$theta *= $TWOPI;
	}
	elsif ($theta_type eq "angle")
	{
		$theta = theta2arc($theta);
	}

	my $x = nearest 0.001 , sin($theta) * $r;
	my $y = nearest 0.001 , cos($theta) * $r;

	return ($self->{cx} + $x, $self->{cy} - $y);
}

# polar line (arc)
# default the angle is arc
# if angle please divide 360 and times TWOPI
# if ratio please times TWOPI
sub pline
{
	my $self = shift;
	my ($cx,$cy) = ($self->{cx} , $self->{cy});
	my $parent = $self->{parent};
	
	my ($r,$theta1,$theta2,%param) = @_;
	($r,$theta1,$theta2) = simple_float($r,$theta1,$theta2);
	
	$param{theta_type} = "angle" unless defined $param{theta_type}; 
	if ($param{theta_type} eq "angle")
	{
		$theta1 = theta2arc($theta1);
		$theta2 = theta2arc($theta2);
	}

	my ($x1,$y1) = $self->polar2pos($r,$theta1);
	my ($x2,$y2) = $self->polar2pos($r,$theta2);
	my $flag = abs($theta2 - $theta1) > $PI ? 1 : 0;
	my $flag1 = $theta2 > $theta1 ? 1 : 0;
	my $path = "M$x1 $y1 A$r $r $theta1 $flag $flag1 $x2 $y2";

	my $obj = $parent->path(d=>$path,%param);
	return $obj;
}

*arc = \&pline;

# polar rect (fan)
sub prect
{
	my $self = shift;
	my ($cx,$cy,$parent) = ($self->{cx} , $self->{cy}, $self->{parent});

	my ($r1,$theta1,$r2,$theta2,%param) = @_;
	$param{theta_type} = "angle" unless defined $param{theta_type}; 
	$param{arrow}      = 0 unless defined $param{arrow};

	if ($param{theta_type} eq "angle")
	{
		$theta1 = theta2arc($theta1);
		$theta2 = theta2arc($theta2);
	}

	($r1,$theta1,$r2,$theta2) = simple_float($r1,$theta1,$r2,$theta2);
	my $r12 = ($r1+$r2)/2;

	my ($x1,$y1) = $self->polar2pos($r1,$theta1);
	my ($x2,$y2) = $self->polar2pos($r2,$theta1);
	my ($x5,$y5) = $self->polar2pos($r12,$theta1);
	my ($x3,$y3) = $self->polar2pos($r2,$theta2);
	my ($x4,$y4) = $self->polar2pos($r1,$theta2);
	my ($x6,$y6) = $self->polar2pos($r12,$theta2);
		
	my $arrow_theta = $param{arrow} == 0 ? 0 : abs(2*($r1-$r2)/($r1+$r2));
	my $flag = abs($theta2 - $theta1) - $arrow_theta > $PI ? 1 : 0;
	my $flag1 = $theta2 > $theta1 ? 1 : 0;
	my $flag2 = $theta2 > $theta1 ? 0 : 1;
	
	my %paths = (0 => "M$x2 $y2 A$r2 $r2 $theta1 $flag $flag1 $x3 $y3 L$x4 $y4 A$r1 $r1 $theta1 $flag $flag2 $x1 $y1 Z");

	## set the arrow path, 1 means clockwise arrow, -1 means anticlockwise arrow
	# the angle of the fan is less than the angle of arrow need 
	if ( abs($theta1-$theta2) <= $arrow_theta ) 
	{
		$paths{1} = "M$x1 $y1 L$x2 $y2 L$x6 $y6 Z";
		$paths{-1}= "M$x3 $y3 L$x4 $y4 L$x5 $y5 Z";
	}
	else 
	{
		my ($newx3,$newy3) = $self->polar2pos($r2,$theta2-$arrow_theta);
		my ($newx4,$newy4) = $self->polar2pos($r1,$theta2-$arrow_theta);
		$paths{1} = "M$x2 $y2 A$r2 $r2 $theta1 $flag $flag1 $newx3 $newy3 L$x6 $y6 L$newx4 $newy4 A$r1 $r1 $theta1 $flag $flag2 $x1 $y1 Z";
		
		my ($newx1,$newy1) = $self->polar2pos($r1,$theta1+$arrow_theta);
		my ($newx2,$newy2) = $self->polar2pos($r2,$theta1+$arrow_theta);
		$paths{-1} = "M$x5 $y5 L$newx2 $newy2 A$r2 $r2 $theta1 $flag $flag1 $x3 $y3 L$x4 $y4 A$r1 $r1 $theta1 $flag $flag2 $newx1 $newy1 Z";
	}

	my $obj = $parent->path(d=>$paths{$param{arrow}},%param);
	return $obj;
}

*fan = \&prect;

# line 
sub line
{
	my $self = shift;
	my ($cx,$cy,$parent) = ($self->{cx} , $self->{cy}, $self->{parent});
	
	my ($r1,$theta1,$r2,$theta2,%param) = @_;

	$param{theta_type} = "angle" unless defined $param{theta_type}; 
	if ($param{theta_type} eq "angle")
	{
		$theta1 = theta2arc($theta1);
		$theta2 = theta2arc($theta2);
	}

	($r1,$theta1,$r2,$theta2) = simple_float($r1,$theta1,$r2,$theta2);
	my ($x1,$y1) = $self->polar2pos($r1,$theta1);
	my ($x2,$y2) = $self->polar2pos($r2,$theta2);
	
	my $line = $parent->line(x1=>$x1,y1=>$y1,x2=>$x2,y2=>$y2,%param);
	return $line;
}

# rectangle
sub rect 
{
	my $self = shift;
	my ($cx,$cy,$parent) = ($self->{cx} , $self->{cy}, $self->{parent});

	my ($r,$theta,$w,$h,%param) = @_;
	($r,$theta,$w,$h) = simple_float($r,$theta,$w,$h);

	my ($x,$y) = $self->polar2pos($r,$theta);
	my $rect = $parent->rect(x=>$x,y=>$y,width=>$w,height=>$h,%param);
	return $rect;
}

# BCurve polygon
sub BCurve
{
	my $self = shift;
	my ($r0,$Qangle1,$Qangle2,$r1,$Rangle1,$Rangle2,%attrs) = @_;
	my ($cx,$cy,$parent) = ($self->{cx} , $self->{cy}, $self->{parent});
	
	my ($Qx1,$Qy1) = $self->polar2pos($r0,$Qangle1,"angle");
	my ($Qx2,$Qy2) = $self->polar2pos($r0,$Qangle2,"angle");
	my ($Rx1,$Ry1) = $self->polar2pos($r1,$Rangle1,"angle");
	my ($Rx2,$Ry2) = $self->polar2pos($r1,$Rangle2,"angle");

	my $color = $attrs{color} || "#000";
	my $fill = $attrs{fill} || "#000";
	my $thickness = $attrs{stroke_width} || 1;
	
	my $flag1 = $Qangle1 > $Qangle2 ? 0 : 1;
	my $flag2 = $Rangle1 > $Rangle2 ? 0 : 1;
	$parent->path(
		d=>"M$Qx1 $Qy1 A$r0 $r0 $Qangle1 0 $flag1 $Qx2 $Qy2 C$Qx2 $Qy2 $cx $cy $Rx1 $Ry1 A$r1 $r1 $Rangle1 0 $flag2 $Rx2 $Ry2 C$Rx2 $Ry2 $cx $cy $Qx1 $Qy1",
		style=>"stroke-width:$thickness;stroke:$color;fill:$fill"
	);
}

# BCurve line 
sub BCurve_line
{
	my $self = shift;
	my ($r0,$Qangle1,$Qangle2,$r1,$Rangle1,$Rangle2,%attrs) = @_;
	my ($cx,$cy,$parent) = ($self->{cx} , $self->{cy}, $self->{parent});

	my ($Qx1,$Qy1) = $self->polar2pos($r0,$Qangle1,"angle");
	my ($Qx2,$Qy2) = $self->polar2pos($r0,$Qangle2,"angle");
	my ($Rx1,$Ry1) = $self->polar2pos($r1,$Rangle1,"angle");
	my ($Rx2,$Ry2) = $self->polar2pos($r1,$Rangle2,"angle");
	
	my $color = $attrs{color} || "#000";
	my $thickness = $attrs{stroke_width} || 1;
	
	my $flag1 = $Qangle1 > $Qangle2 ? 0 : 1;
	my $flag2 = $Rangle1 > $Rangle2 ? 0 : 1;
	
	$parent->path(
		d=>"M$Qx1 $Qy1 C$Qx1 $Qy1 $cx $cy $Rx1 $Ry1",
		style=>"stroke-width:$thickness;stroke:$color;fill:none"
	);
}

# text
sub text 
{
	my $self = shift;
	my ($r,$theta,$trans,$label,%param) = @_;
	
	my ($cx,$cy,$parent) = ($self->{cx} , $self->{cy}, $self->{parent});
	($r,$theta,$trans) = simple_float($r,$theta,$trans);
	
	my $attrs = "";
	my $font;
	my $style;
	
	if($param{theme})
	{
		$font = SBV::Font->new($param{theme});
		$style = $font->toStyle();
	}
	elsif ($param{class}) 
	{
		$font = SBV::Font->fetch_font($param{class});
	}
	else 
	{
		$font = SBV::Font->fetch_font("default");
	}
	
	$param{theta_type} = "angle" unless (defined $param{theta_type});
	if ($param{theta_type} eq "arc")
	{
		$theta = arc2theta($theta);
	}
	
	$theta = $theta < 0   ? $theta + 360 : 
			 $theta > 360 ? $theta - 360 : $theta;
	Error("[$theta] < 0 or > 360") if $theta < 0 || $theta > 360;

	my $text;
	if ($param{parallel})
	{
		if ($theta <= 90 || $theta > 270)
		{
			$text = $parent->text(x=>$cx-$trans,y=>$cy-$r,class=>"leaf",
				transform=>"rotate($theta,$cx,$cy)")->cdata($label);
		}
		else 
		{
			$theta -= 180;
			my $text_height = $font->fetch_text_height;
			$text = $parent->text(x=>$cx-$trans,y=>$cy+$r+$text_height,class=>"leaf",
				transform=>"rotate($theta,$cx,$cy)")->cdata($label);
		}
	}
	else
	{
		if ($theta <= 180)
		{
			$theta -= 90;
			#$text = $parent->text(x=>$cx+$r,y=>$cy+$trans,class=>"leaf",
			#	transform=>"rotate($theta,$cx,$cy)")->cdata($label);
			$text = $parent->text(x=>$cx+$r,y=>$cy+$trans,class=>"leaf",
				transform=>"rotate($theta,$cx,$cy)",'text-anchor'=>"start")->cdata($label);
		}
		else
		{
			$theta -= 270;
			my $text_width = $font->fetch_text_width($label);
			#$text = $parent->text(x=>$cx-$r-$text_width,y=>$cy+$trans,class=>"leaf",
			#	transform=>"rotate($theta,$cx,$cy)")->cdata($label);
			$text = $parent->text(x=>$cx-$r,y=>$cy+$trans,class=>"leaf",
				transform=>"rotate($theta,$cx,$cy)",'text-anchor'=>"end")->cdata($label);
		}
	}
	
	$text->setAttribute(class=>$param{class}) if ($param{class});
	$text->setAttribute(id=>$param{id}) if ($param{id});
	$text->setAttribute(style=>$style) if ($param{theme});

	return $text;
}

# turn angle to arc
sub theta2arc
{
	my $angle = shift;
	return $angle * $TWOPI / 360;
}

sub arc2theta
{
	my $angle = shift;
	return $angle * 360 / $TWOPI;
}

sub simple_float
{
	return map { nearest 0.001 , $_ } @_;
}

sub dist
{
	my $class = shift ;

	my ($r1,$arc1,$r2,$arc2,%opts) = @_;
	$opts{'-type'} = "angle";
	
	my ($x1,$y1) = $class->polar2pos($r1,$arc1,$opts{'-type'});
	my ($x2,$y2) = $class->polar2pos($r2,$arc2,$opts{'-type'});
	
	my $dist = sqrt(($x1-$x2)**2 + ($y1-$y2)**2);
	return $dist;
}
