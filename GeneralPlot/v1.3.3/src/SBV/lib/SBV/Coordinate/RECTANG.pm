package SBV::Coordinate::RECTANG;
#------------------------------------------------+
#    [APM] This moudle is generated by amp.pl    |
#    [APM] Created time: 2013-06-25 14:16:29     |
#------------------------------------------------+
=pod

=head1 Name

SBV::Coordinate::RECTANG

=head1 Synopsis

This module is not meant to be used directly

=head1 Feedback

Author: Peng Ai
Email:  aipeng0520@163.com

=head1 Version

Version history

=head2 v1.0

Date: 2013-06-25 14:16:29

=cut

use strict;
use warnings;
require Exporter;

use List::Util;
use FindBin;
use lib "$FindBin::RealBin";
use lib "$FindBin::RealBin/..";
use lib "$FindBin::RealBin/lib";
use lib "$FindBin::RealBin/../lib";

use SBV;
use SBV::STAT;
use SBV::Colors;
use SBV::DRAW;
use SBV::DEBUG;
use Math::Round;


#-------------------------------------------------------------------------------
#  create a new rectangular coordinate system
#  features:
#  ox,oy,width,height: which you can defined in conf, needed
#  parent: the svg object which you can draw the OS on it, needed
#-------------------------------------------------------------------------------
sub new 
{
    my $class = shift;
    my %param = @_;

    my $coord = {};
    $coord->{legend} = {};
    bless $coord , $class;
    $coord->aes(%param);
    return $coord;
}

sub check_features
{
    my $self = shift;

    ERROR('no_svg_object') unless (defined $self->{parent});
    ERROR('os_coord_err') unless (defined $self->{ox} && defined $self->{oy} && 
        defined $self->{tw} && defined $self->{th});
    ERROR('no_axis_limit') unless (defined $self->{xlim} && defined $self->{ylim});

    return 1;
}

# re load the datafile
sub read
{
    my ($self,$file,%param) = @_;
    $file = check_path($file);
    
    my $header = $param{header} || 0;
    my $rownames = $param{rownames} || 0;

    my $data = SBV::DATA::Frame->new($file,header=>$header,rownames=>$rownames);
    $self->{data} = $data;
}

sub labs
{
    my ($self,%param) = @_;
    $self->title($param{title}) if (exists $param{title});
    $self->xlab($param{x}) if (exists $param{x});
    $self->ylab($param{y}) if (exists $param{y});
}

sub title
{
    my ($self,$str) = @_;
    my $font = SBV::Font->fetch_font('CLASStitle');
    my $textH = $font->fetch_text_height;

    if ($str && ! defined $self->{title})
    {
        $self->{th} -= $textH + $SBV::conf->{vspace}*2;
        $self->{title} = $str;
    }
    elsif ($str && defined $self->{title})
    {
        $self->{title} = $str;    
    }
    elsif (defined $self->{title})
    {
        $self->{th} += $textH + $SBV::conf->{vspace}*2;
        $self->{title} = undef;
    }
}

sub xlab
{
    my ($self,$str) = @_;
    my $font = SBV::Font->fetch_font('CLASSsubtitle');
    my $textH = $font->fetch_text_height;

    if ($str && ! defined $self->{xlab})
    {
        $self->{th} -= $textH + $SBV::conf->{vspace}*2;
        $self->{oy} -= $textH + $SBV::conf->{vspace}*2;
        $self->{xlab} = $str;
    }
    elsif ($str && defined $self->{xlab})
    {
        $self->{xlab} = $str;    
    }
    elsif (defined $self->{xlab})
    {
        $self->{th} += $textH + $SBV::conf->{vspace}*2;
        $self->{oy} += $textH + $SBV::conf->{vspace}*2;
        $self->{xlab} = undef;
    }
}

sub ylab
{
    my ($self,$str) = @_;
    my $font = SBV::Font->fetch_font('CLASSsubtitle');
    my $textH = $font->fetch_text_height;
    
    if ($str && ! defined $self->{ylab})
    {
        $self->{tw} -= $textH + $SBV::conf->{hspace}*2;    
        $self->{ox} += $textH + $SBV::conf->{hspace}*2;
        $self->{ylab} = $str;
    }
    elsif ($str && defined $self->{ylab})
    {
        $self->{ylab} = $str;    
    }
    elsif (defined $self->{ylab})
    {
        $self->{tw} += $textH + $SBV::conf->{hspace}*2;    
        $self->{ox} -= $textH + $SBV::conf->{hspace}*2;
        $self->{ylab} = undef;
    }
}

sub xlim
{
    my ($self,@vals) = @_;
    return $self->{xlim} unless (@vals);
    
    unless ($self->{xlim})
    {
        $self->{xlim} = \@vals;
        return;
    }

    my @raw = @{$self->{xlim}};
    my ($rawmin,$rawmax) = @raw[0,1];
    my ($newmin,$newmax) = @vals[0,1];
    $raw[0] = min([$rawmin,$newmin]);
    $raw[1] = max([$rawmax,$newmax]);
    $self->{xlim} = \@raw;
}

sub setXlim
{
    my ($self,@vals) = @_;
    $self->{conf}->{xlim} = join " " , @vals;
}

sub setYlim
{
    my ($self,@vals) = @_;
    $self->{conf}->{ylim} = join " " , @vals;
}

sub ylim
{
    my ($self,@vals,%opts) = @_;
    return $self->{ylim} unless (@vals);
    unless ($self->{ylim})
    {
        $self->{ylim} = \@vals;
        return;
    }
    
    my @raw = @{$self->{ylim}}; 
    my ($rawmin,$rawmax) = @raw[0,1];
    my ($newmin,$newmax) = @vals[0,1];
    
    $self->{ylim} = [min([$rawmin,$newmin]),max([$rawmax,$newmax])];
}

sub xaxis
{
    my ($self) = @_;
    
    my $xlim = $self->{xlim};
    my $tick;
    if (scalar @$xlim == 3)
    {
        $tick = join " " , @$xlim;    
    }
    else
    {
        $tick = dividing($xlim);
    }
    my %par = (tick=>$tick);
    
    if ($self->{xnames})
    {
        $par{translate} = 0.5;    
        $par{ticktext} = $self->{ticktext};
        $par{show_tick_line} = 0;
        $par{start} = 0;
    }
    
    if ($self->{conf}->{xaxis})
    {
        foreach my$key(keys %{$self->{conf}->{xaxis}})
        {
            $par{$key} = $self->{conf}->{xaxis}->{$key};
        }
    }
    
    my $axis = SBV::STONE::AXIS->new(%par,parent=>$self->{parent});
    my $thick = $axis->thickness;

    $self->{th} -= $thick;
    $self->{oy} -= $thick;
    $self->{xaxis} = $axis;
}

sub yaxis
{
    my ($self) = @_;
    
    my $ylim = $self->{ylim};
    my $tick;
    if (scalar @$ylim == 3)
    {
        $tick = join " " , @$ylim;
    }
    else
    {
        $tick = dividing(@$ylim);
    }    
    
    my %par = (tick=>$tick,angle=>-90,side=>"left");
    if ($self->{conf}->{yaxis})
    {
        foreach my$key(keys %{$self->{conf}->{yaxis}})
        {
            $par{$key} = $self->{conf}->{yaxis}->{$key};
        }
    }
    my $axis = SBV::STONE::AXIS->new(%par,parent=>$self->{parent});
    my $thick = $axis->thickness;

    $self->{tw} -= $thick;
    $self->{ox} += $thick;
    $self->{yaxis} = $axis;
}

sub flip
{
    my $self = shift;
    ($self->{yaxis},$self->{xaxis}) = ($self->{xaxis},$self->{yaxis});
    my $xlab = $self->{xlab};
    my $ylab = $self->{ylab};
    $self->xlab($ylab);
    $self->ylab($xlab);
    
    $self->{ox} = $self->{ox} - $self->{xaxis}->{thickness} + $self->{yaxis}->{thickness};
    $self->{tw} = $self->{tw} - $self->{yaxis}->{thickness} + $self->{xaxis}->{thickness};
    $self->{oy} = $self->{oy} - $self->{xaxis}->{thickness} + $self->{yaxis}->{thickness};
    $self->{th} = $self->{th} - $self->{xaxis}->{thickness} + $self->{yaxis}->{thickness};

    $self->{xaxis}->aes(angle=>0,side=>'right');
    $self->{yaxis}->aes(angle=>-90,side=>'left');

    return 1;
}

# draw the side of the ggplot2
sub draw
{
    my $self = shift;
    $self->check_features;
    
    # init legend
    my $legend;
    if ($self->{conf}->{legend})
    {
        my $lconf = SBV::CONF::fetch_first_conf('legend',$self->{conf});
        my $legend_par = $self->legend;
        $legend = SBV::STONE::LEGEND->new(conf=>$lconf,%$legend_par);
        if ($lconf->{pos} eq "outright")
        {
            my $legend_width = $legend->width;
            $self->{tw} -= $legend_width;
        }
    }
    
    # reset xlim and ylim 
    if ($self->{conf}->{xlim})
    {
        my @tmp = split /[\s\,\t]+/ , $self->{conf}->{xlim};
        $self->{xlim} = \@tmp;
    }

    if ($self->{conf}->{ylim})
    {
        my @tmp = split /[\s\,\t]+/ , $self->{conf}->{ylim};
        $self->{ylim} = \@tmp;
    }

    # init axis
    $self->xaxis;
    $self->yaxis;
    $self->flip if ($self->{conf}->{flip});
    
    my ($xaxis,$yaxis) = ($self->{xaxis},$self->{yaxis});
    $xaxis->aes(ox=>$self->{ox},oy=>$self->{oy},length=>$self->{tw},bgline=>$self->{th});
    $yaxis->aes(ox=>$self->{ox},oy=>$self->{oy},length=>$self->{th},bgline=>$self->{tw});
    
    # background
    my $conf = {ox=>$self->{ox},oty=>$self->{oy}-$self->{th},
        tw=>$self->{tw},th=>$self->{th},
        border=>$self->{conf}->{border},
        background=>$self->{conf}->{background}
    };
    SBV::DRAW::background($conf,$self->{parent});
    
    # add the clipPath of background region
    my $clip_id = "xy_coord_limit";
    my $clip = $SBV::defs->clipPath(id=>$clip_id,style=>"evenodd",clipPathUnits=>"UserSpaceOnUse");
    $clip->rect(x=>$self->{ox},y=>$conf->{oty},width=>$self->{tw},height=>$self->{th});

    # draw axis
    $xaxis->plot;
    $yaxis->plot;

    my $hi = $SBV::conf->{hspace};
    my $vi = $SBV::conf->{vspace};
    my $font = SBV::Font->fetch_font('CLASSsubtitle');
    my $textH = $font->fetch_text_height;
    
    my $labs_group = $self->{parent}->g(class=>"labs");
    if ($self->{xlab})
    {
        my $textW = $font->fetch_text_width($self->{xlab});
        my $x = $self->{ox} + $self->{tw}/2 - $textW/2;
        my $y = $self->{conf}->{oy} - $vi;
        $labs_group->text(x=>$x,y=>$y,class=>"subtitle")->cdata($self->{xlab});
    }

    if ($self->{ylab})
    {
        my $textW = $font->fetch_text_width($self->{ylab});
        my $x = $self->{conf}->{ox} + $vi + $textH;
        my $y = $self->{oy} - $self->{th}/2 + $textW/2;
        $labs_group->text(class=>"subtitle",x=>$x,y=>$y,transform=>"rotate(-90,$x,$y)")->cdata($self->{ylab});
    }

    $font = SBV::Font->fetch_font('CLASStitle');
    $textH = $font->fetch_text_height;
    if ($self->{title})
    {
        my $textW = $font->fetch_text_width($self->{title});
        my $x = $self->{ox} + $self->{tw}/2 - $textW/2;
        my $y = $self->{conf}->{oty} + $vi + $textH;
        $labs_group->text(x=>$x,y=>$y,class=>"title")->cdata($self->{title});
    }
    
    # draw main diagram
    my %mg_opts = $self->{conf}->{show_outrange} ? () : ('clip-path'=>"url(#xy_coord_limit)");
    my $main_group = $self->{parent}->g(class=>"main",%mg_opts);
    $self->{parent} = $main_group;

    foreach (@{$self->{eval}})
    {
        my $cmd =  "\$self->$_";
        my $temp = eval("$cmd");
        ERROR('ggplot2_eval_err',$_) if (! defined $temp);
    }

    if ($legend)
    {
        $legend->location($self);
        $legend->draw($self->{parent});
    }
}

# set the legend 
sub legend
{
    my $self = shift;
    my $legend = $self->{legend};

    if (@_)
    {
        my %par = @_;
        $legend->{$_} = $par{$_} foreach (keys %par);
    }
    else
    {
        return $legend;
    }

    return 1;
}

# aes
# change the paramter for this class
# like aes of ggplot2 in R
sub aes
{
    my $self = shift;
    my %param = @_;

    if ($param{conf})
    {
        $self->load_conf($param{conf});
    }
    
    foreach my$key (keys %param)
    {
        if ($key eq "xlab")
        {
            $self->xlab($param{$key});
        }
        elsif ($key eq "ylab")
        {
            $self->ylab($param{$key});
            
        }
        elsif ($key eq "title")
        {
            $self->title($param{$key});
        }
        elsif ($key eq "file")
        {
            $self->read($param{file});    
        }
        else
        {
            $self->{$key} = $param{$key};
        }
    }
}

*features = \&aes;

# load the ggplot2 conf for RECT OS
sub load_conf
{
    my ($self,$conf) = @_;    
    
    $self->{ox} = $conf->{ox} or die;
    $self->{oy} = $conf->{oy} or die;
    $self->{tw} = $conf->{tw} or die;
    $self->{th} = $conf->{th} or die;
    $self->{oty} = $conf->{oty} or die;
    
    $self->{stat} = $conf->{stat};

    my @items = ("xlab","ylab","title","xnames");
    foreach my$item (@items)
    {
        next unless (defined $conf->{$item});

        if ($item eq "xlab") 
        {
            $self->xlab($conf->{$item});
        }
        elsif ($item eq "ylab")
        {
            $self->ylab($conf->{$item});
        }
        elsif ($item eq "title")
        {
            $self->title($conf->{$item});
        }
        else
        {
            $self->{$item} = $conf->{$item};
        }
    }
    
    @items = ("fill","col","shape","type");
    foreach my$item(@items)
    {
        if ($conf->{$item})
        {
            if ($item eq "col" || $item eq "fill")
            {
                my @temp = SBV::Colors::fetch_brewer_color($conf->{$item});
                $self->{$item} = \@temp;
            }
            else
            {
                my @temp = SBV::CONF::fetch_val($conf,$item);
                $self->{$item} = \@temp;
            }
        }
    }

    $self->{oty} = $self->{oy} - $self->{th};
}

# Name: localPar
# Func: init the local parameter
sub localPar
{
    my $self = shift;
    my $param = shift;
    my $factor = shift || 0;
    my $level;
    
    foreach my$key (keys %$self)
    {
        $param->{$key} = $self->{$key} if (! defined $param->{$key});    
    }
    
    #if ($param->{file})
    #{
    #    $self->read($param->{file});    
    #}
    
    my @labels;
    if ($param->{group})
    {
        if (! defined $param->{level})
        {
            $param->{level} = levels($param->{data}->{col}->{$param->{group}});
            @labels = uniq_arr ($param->{data}->{col}->{$param->{group}});
        }
    }

    if ($param->{col})
    {
        if (exists $param->{data}->{col}->{$param->{col}})
        {
            $param->{col} = _arr2color($param->{data}->{col}->{$param->{col}},1);
            if (! defined $param->{level})
            {
                $param->{level} = levels($param->{data}->{col}->{$param->{col}});
                @labels = uniq_arr($param->{data}->{col}->{$param->{col}});
            }
        }
        elsif (ref $param->{col} eq "ARRAY")
        {
            my @colors = @{$param->{col}};
            @colors = map {SBV::Colors::fetch_color($_)} @colors;
            $param->{col} = \@colors;
        }
        else
        {
            #my @colors = split /\s+/ , $param->{col};
            #@colors = map {SBV::Colors::fetch_color($_)} @colors;
            my @colors = SBV::Colors::fetch_brewer_color($param->{col});
            $param->{col} = \@colors;
        }
    }
    
    if ($param->{fill})
    {
        if (exists $param->{data}->{col}->{$param->{fill}})
        {
            my $fill = $param->{data}->{col}->{$param->{fill}};
            $param->{fill} = _arr2color($fill,1);
            if (! defined $param->{level})
            {
                $param->{level} = levels($fill);
                @labels = uniq_arr($fill);
            }
        }
        elsif (ref $param->{fill} eq "ARRAY")
        {
            my @fill = @{$param->{fill}};
            @fill = map {SBV::Colors::fetch_color($_)} @fill;
            $param->{fill} = \@fill;
        }
        else
        {
            #my @fill = split /\s+/ , $param->{fill};
            #@fill = map {SBV::Colors::fetch_color($_)} @fill;
            my @fill = SBV::Colors::fetch_brewer_color($param->{fill});
            $param->{fill} = \@fill;
        }
    }
    
    if (! exists $param->{level})
    {
        my @rownames = $param->{data}->rownames;
        my @temp = map { 0 } 0 .. $#rownames;
        $param->{level} = \@temp;
        @labels = ('label');
    }
    
    $self->legend(label=>\@labels) if (! exists $self->{legend}->{label});
    return $param;
}

sub _arr2color
{
    my$arr = shift;
    my$factor = shift;
    
    if ($factor)
    {
        my @temp = uniq_arr($arr);
        $arr = \@temp;
    }
    
    my $isColor = SBV::Colors::isColor(@$arr);
    my @colors;
    if ($isColor)
    {
        @colors = map {SBV::Colors::fetch_color($_)} @$arr;
    }
    else
    {
        @colors = SBV::Colors::rainbow($#$arr+1);
    }
    
    return \@colors;
}

# get the svg location
sub coord2pos
{
    my $self = shift;
    my $x = shift;
    my $y = shift;

    my $newx = $self->{ox} + $self->{xaxis}->fetch_dis($x);
    my $newy = $self->{oy} - $self->{yaxis}->fetch_dis($y);
    
    return ($newx,$newy);
}

sub xcoord2pos
{
    my $self = shift;
    my $x = shift;
    return $self->{ox} + $self->{xaxis}->fetch_dis($x);
}

sub ycoord2pos
{
    my $self = shift;
    my $y = shift;
    return $self->{oy} - $self->{yaxis}->fetch_dis($y);
}

# get the svg true distance of two points
sub coord2dis
{
    my $self = shift;
    my ($x1,$y1,$x2,$y2) = @_;
    
    my ($newx1,$newy1) = $self->coord2pos($x1,$y1);
    my ($newx2,$newy2) = $self->coord2pos($x2,$y2);

    my $dis = sqrt ( ($newx1-$newx2)**2 + ($newy1-$newy2)**2 );
    return $dis;
}

# density
sub density
{
    my $self = shift;
    my %param = @_;
    my $opts = restore_cmd(\%param);

    my ($par,$newdata,$xval,$names) = $self->doInitAes_density(\%param);
    unless ($param{draw})
    {
        push @{$self->{eval}} , "density($opts)";
        return 1;
    }

    my @xval = @$xval;
    my @names = @$names;

    # default fill and col
    my $col = $par->{col} || ["#000"];
    my $parent = $par->{parent};
    my $stroke_width = defined $par->{stroke_width} ? $par->{stroke_width} : 2;

    my ($xcor,$ycor);
    
    foreach my$i( 0 .. $#names )
    {
        my $x = $xval[$i];
        my $y = $newdata->{$names[$i]};
        my ($rectx,$recty) = $self->coord2pos($x,$y);
        push @$xcor , $rectx;
        push @$ycor , $recty;
    }
    
    my $style = "stroke:$col->[0];stroke-width:$stroke_width;fill:none;";
    $style .= "stroke-dasharray:$par->{stroke_dashes}" if ($par->{stroke_dashes});

    my $points = $parent->get_path(x=>$xcor,y=>$ycor,-type=>'polyline');
    $parent->polyline(%$points,style=>$style);
}

# multi group bar
sub mbar
{
    my $self = shift;
    my %param = @_;
    my $opts = restore_cmd(\%param);
    my ($par,$newdata,$xval,$names) = $self->doInitAes_bar_group(\%param);
    my @xval = @$xval;
    my @names = @$names;
    
    # data stat method the draw bar
    my $stat = $par->{'stat'} || "mean";

    my $col = $par->{col} || ["none"];
    my $fill = $par->{fill} || ["#000"];
    my $parent = $par->{parent};
    my $width = $par->{width} || 0.8;
    my $size = $par->{size} || 1;
    my $swidth = $par->{stroke_width} || 0;
    
    # set the legend
    my $factor = $par->{factor};
    $self->legend(shape=>[0],color=>$col,fill=>$fill,label=>$factor);
    
    unless ($param{draw})
    {
        push @{$self->{eval}} , "mbar($opts)";
        return 1;
    }
    
    # fetch the xaxis and yaxis info 
    my $xaxis = $self->{xaxis};
    my $xmin = $xaxis->{min};
    my $xmax = $xaxis->{max};
    my $yaxis = $self->{yaxis};
    my $ymin = $yaxis->{min};
    my $ymax = $yaxis->{max};
    
    my $vi = $SBV::conf->{vspace};
    my $hi = $SBV::conf->{hspace};
    my $font = SBV::Font->fetch_font();
    my $textH = $font->fetch_text_height;
    
    # get the bar width 
    my $barW = $self->{conf}->{flip} ? $yaxis->{unit} * $width : $xaxis->{unit} * $width;
    
    if ($par->{pileup}) # pile up the group bar
    {
        foreach my$i( 0 .. $#names )
        {
            my $x = $xval[$i];
            my $name = $names[$i];
            my $subdata = $newdata->{$name};
            
            my $minusy1 = 0;
            my $plusy1 = 0;
            
            my @order = grep { $subdata->{$_} } @$factor;

            if ($par->{sort} && $par->{sort} eq "number")
            {
                @order = sort { fetch_y($stat,$subdata->{$b}) <=>  fetch_y($stat,$subdata->{$a}) } @order;
            }
            elsif ($par->{sort} && $par->{sort} eq "ascii")
            {
                @order = sort @order;
            }
            
            if ($par->{reverse})
            {
                @order = reverse @order;
            }
            
            my %colors;
            my %fill;
            
            foreach my$j (0 .. $#$factor)
            {
                my $group = $factor->[$j];
                my $color = loop_arr($col,$j);
                my $fill_col = loop_arr($fill,$j);
                
                $colors{$group} = $color;
                $fill{$group} = $fill_col;
            }
            
            my $sum_val;
            foreach my$j (0 .. $#order)
            {
                my $group = $order[$j];
                next if (! exists $subdata->{$group});
                my @val = @{$subdata->{$group}};
                my $val =  fetch_y($stat,\@val);
                $sum_val += $val;

                my $color = $colors{$group};
                my $fill_col = $fill{$group};
                
                if ($val < 0)
                {
                    my $y2 = $minusy1 + $val;
                    if ($self->{conf}->{flip})
                    {
                        my $h = $xaxis->fetch_dis($minusy1) - $xaxis->fetch_dis($y2);
                        my ($rectx,$recty) = $self->coord2pos($y2,$x+$width/2);
                        $parent->rect(x=>$rectx,y=>$recty,width=>$h,height=>$barW,
                            style=>{fill=>$fill_col,stroke=>$color,"stroke-width"=>$swidth});
                    }
                    else
                    {
                        my $h = $yaxis->fetch_dis($minusy1) - $yaxis->fetch_dis($y2);
                        my ($rectx,$recty) = $self->coord2pos($x-$width/2 , $minusy1);
                        $parent->rect(x=>$rectx,y=>$recty,width=>$barW,height=>$h,
                            style=>{fill=>$fill_col,stroke=>$color,"stroke-width"=>$swidth});
                    }
                    $minusy1 = $y2;
                }
                else
                {
                    my $y2 = $plusy1 + $val;
                    if ($self->{conf}->{flip})
                    {
                        my $h = $xaxis->fetch_dis($y2) - $xaxis->fetch_dis($plusy1);
                        my ($rectx,$recty) = $self->coord2pos($plusy1 , $x+$width/2);

                        if ($par->{letter})
                        {
                            my $letter = $par->{letter}->[$j];
                            SBV::DRAW::fixText($rectx,$recty,$h,$barW,$letter,"fill:$fill_col","freq",$parent);
                        }
                        else
                        {
                            $parent->rect(x=>$rectx,y=>$recty,width=>$h,height=>$barW,
                                style=>{fill=>$fill_col,stroke=>$color,"stroke-width"=>$swidth});
                        }
                    }
                    else
                    {
                        my $h = $yaxis->fetch_dis($y2) - $yaxis->fetch_dis($plusy1);
                        my ($rectx,$recty) = $self->coord2pos($x-$width/2 , $y2);

                        if ($par->{letter})
                        {
                            my $letter = $par->{letter}->[$j];
                            SBV::DRAW::fixText($rectx,$recty,$barW,$h,$letter,"fill:$fill_col","freq",$parent);
                        }
                        else
                        {
                            $parent->rect(x=>$rectx,y=>$recty,width=>$barW,height=>$h,
                                style=>{fill=>$fill_col,stroke=>$color,"stroke-width"=>$swidth});
                        }
                    }
                    $plusy1 = $y2;
                }
            }
            
            if ($par->{val})
            {
                my $fontW = $font->fetch_text_width($sum_val);

                if ($self->{conf}->{flip})
                {
                    my $textx = $sum_val < 0 ? $self->xcoord2pos($sum_val) - $hi - $fontW : $self->xcoord2pos($sum_val) + $hi;
                    my $texty = $self->ycoord2pos($x) + $textH/2;
                    $parent->text( x=>$textx, y=>$texty )->cdata($sum_val);
                }
                else 
                {
                    my $textx = $self->xcoord2pos($x) - $fontW/2;
                    my $texty = $sum_val < 0 ? $self->ycoord2pos($sum_val) + $vi + $textH/2 : $self->ycoord2pos($sum_val) - $textH/2 -  $vi;
                    $parent->text( x=>$textx, y=>$texty )->cdata($sum_val);
                }
            }
        }
    }
    else # draw group bar separately
    {
        # get the width of each bar
        my $groupN = scalar @$factor;
        $barW = $barW/$groupN;
        my $tempW = $barW * $size;

        foreach my$i( 0 .. $#names )
        {
            my $x = $xval[$i];
            my $name = $names[$i];
            my $subdata = $newdata->{$name};

            foreach my$j (0 .. $#$factor)
            {
                my $group = $factor->[$j];
                next if (! exists $subdata->{$group});

                my @val = @{$subdata->{$group}};
                my $y = fetch_y($stat,\@val);
                $y = nearest 0.01 , $y;

                my $color = loop_arr($col,$j);
                my $fill_col = loop_arr($fill,$j);
                
                if ($self->{conf}->{flip})
                {
                    my ($rectx,$recty,$h,$textx);
                    my $fontW = $font->fetch_text_width($y);
                    
                    if ($xmax <= 0)
                    {
                        $h = $xaxis->fetch_dis($xmax) - $xaxis->fetch_dis($y);
                        ($rectx,$recty) = $self->coord2pos($y,$x+$width/2 - $j*$width/$groupN);
                        $textx = $rectx - $hi - $fontW;
                    }
                    elsif ($xmin >= 0)
                    {
                        $h = $xaxis->fetch_dis($y) - $xaxis->fetch_dis($xmin);
                        ($rectx,$recty) = $self->coord2pos($xmin,$x+$width/2 - $j*$width/$groupN);
                        $textx = $rectx + $h + $hi;
                    }
                    else
                    {
                        if ($y > 0)
                        {
                            $h = $xaxis->fetch_dis($y) - $xaxis->fetch_dis(0);
                            ($rectx,$recty) = $self->coord2pos(0,$x+$width/2 - $j*$width/$groupN);
                            $textx = $rectx + $h + $hi;
                        }
                        else
                        {
                            $h = $xaxis->fetch_dis(0) - $xaxis->fetch_dis($y);
                            ($rectx,$recty) = $self->coord2pos($y,$x+$width/2 - $j*$width/$groupN);
                            $textx = $rectx - $hi - $fontW;
                        }
                    }
                    
                    $recty += $barW * (1-$size)/2;
                    $parent->rect(x=>$rectx,y=>$recty,width=>$h,height=>$tempW,
                            style=>{fill=>$fill_col,stroke=>$color,'stroke-width'=>$swidth});

                    # add the val to the bar top
                    if ($par->{val})
                    {
                        my $texty = $self->ycoord2pos($x+$width/2-($j+0.5)*$width/$groupN) + $textH/2;
                        $parent->text(x=>$textx,y=>$texty)->cdata($y);
                    }
                }
                else
                {
                    my ($rectx,$recty,$h,$texty);
                    if ($ymax <= 0)
                    {
                        $h = $yaxis->fetch_dis($ymax) - $yaxis->fetch_dis($y);
                        ($rectx,$recty) = $self->coord2pos($x-$width/2 + $j*$width/$groupN,$y);
                        $texty = $recty + $h + $vi + $textH;
                    }
                    elsif ($ymin >= 0)
                    {
                        $h = $yaxis->fetch_dis($y) - $yaxis->fetch_dis($ymin);
                        ($rectx,$recty) = $self->coord2pos($x-$width/2 + $j*$width/$groupN,$y);
                        $texty = $recty - $vi;
                    }
                    else
                    {
                        if ($y > 0)
                        {
                            $h = $yaxis->fetch_dis($y) - $yaxis->fetch_dis(0);
                            ($rectx,$recty) = $self->coord2pos($x-$width/2 + $j*$width/$groupN,$y);
                            $texty = $recty - $vi;
                        }
                        else
                        {
                            $h = $yaxis->fetch_dis(0) - $yaxis->fetch_dis($y);
                            ($rectx,$recty) = $self->coord2pos($x-$width/2 + $j*$width/$groupN,0);
                            $texty = $recty + $h + $vi + $textH;
                        }    
                    }
                    $rectx += $barW * (1-$size)/2;
                    $parent->rect(x=>$rectx,y=>$recty,width=>$tempW,height=>$h,
                            style=>{fill=>$fill_col,stroke=>$color,'stroke-width'=>$swidth});

                    # add the val to the bar top
                    if ($par->{val})
                    {
                        my $fontW = $font->fetch_text_width($y);
                        my $textx = $self->xcoord2pos($x-$width/2+($j+0.5)*$width/$groupN) - $fontW/2;
                        $parent->text(x=>$textx,y=>$texty)->cdata($y);
                    }
                }
                
            }
        }
    }
}

# draw bar
*histogram = \&bar;
*hist = \&bar;

sub bar
{
    my $self = shift;
    my %param = @_;
    my $opts = restore_cmd(\%param);

    if (exists $param{group})
    {
        $self->mbar(%param);
        return 1;
    }

    my ($par,$newdata,$xval,$names) = $self->doInitAes_bar(\%param);
    my @xval = @$xval;
    my @names = @$names;

    # data stat method the draw bar 
    # mean, max, min
    my $stat = $par->{'stat'} || "mean";
    
    # default fill and col
    my $col = $par->{col} || ["none"];
    my $fill = $par->{fill} || ["#000"];
    my $parent = $par->{parent};
    my $width = $par->{width} || 0.6;
    my $swidth = defined $par->{stroke_width} ? $par->{stroke_width} : 1;

    # set the legend 
    $self->legend(shape=>[0],color=>$col,fill=>$fill,label=>\@names);
    
    unless ($param{draw})
    {
        push @{$self->{eval}} , "bar($opts)";
        return 1;
    }
    
    # fetch the xaxis info 
    my $yaxis = $self->{yaxis};
    my $ymin = $yaxis->{min};
    my $ymax = $yaxis->{max};
    
    # for filp , fetch the yaxis info
    my $xaxis = $self->{xaxis};
    my $xmin = $xaxis->{min};
    my $xmax = $xaxis->{max};
    
    # get the bar width 
    my $barW = $self->{conf}->{flip} ? $yaxis->{unit} * $width : $xaxis->{unit} * $width;
    
    # fetch the font info for value marker
    my $font = SBV::Font->fetch_font();
    my $textH = $font->fetch_text_height;
    
    my $hi = $SBV::conf->{hspace};
    my $vi = $SBV::conf->{vspace};
    
    foreach my$i( 0 .. $#names )
    {
        my $x = $xval[$i];
        my $name = $names[$i];
        
        my @val = @{$newdata->{$name}};
        my $y = fetch_y($stat,\@val); # the value 
        $y = nearest 0.01 , $y;
        my $color = loop_arr($col,$i);
        my $fill_col = loop_arr($fill,$i);
        
        if ($self->{conf}->{flip})
        {
            my ($rectx,$recty,$h,$textx);
            if ($xmax <= 0) # values are all negative 
            {
                $h = $xaxis->fetch_dis($xmax) - $xaxis->fetch_dis($y);
                ($rectx,$recty) = $self->coord2pos($y,$x+$width/2);
                $textx = $rectx - $hi - $font->fetch_text_width($y);
            }
            elsif ($xmin >= 0) # values are all positive
            {
                $h = $xaxis->fetch_dis($y) - $xaxis->fetch_dis($xmin);
                ($rectx,$recty) = $self->coord2pos($xmin,$x+$width/2);
                $textx = $rectx + $h + $hi;
            }
            else
            {
                if ($y > 0)
                {
                    $h = $xaxis->fetch_dis($y) - $xaxis->fetch_dis(0);
                    ($rectx,$recty) = $self->coord2pos(0,$x+$width/2);
                    $textx = $rectx + $h + $hi;
                }
                else
                {
                    $h = $xaxis->fetch_dis(0) - $xaxis->fetch_dis($y);
                    ($rectx,$recty) = $self->coord2pos($y,$x+$width/2);
                    $textx = $rectx - $hi - $font->fetch_text_width($y);
                }
            }
            
            $parent->rect(x=>$rectx,y=>$recty,width=>$h,height=>$barW,
                style=>{fill=>$fill_col,stroke=>$color,'stroke_width'=>$swidth});
            
            # add the val to the bar top
            if ($par->{val})
            {
                my $texty = $self->ycoord2pos($x) + $textH/2;
                $parent->text(x=>$textx,y=>$texty)->cdata($y);
            }
        }
        else
        {
            my ($rectx,$recty,$h,$texty);
            if ($ymax <= 0) # values are all negative
            {
                $h = $yaxis->fetch_dis($ymax) - $yaxis->fetch_dis($y);
                ($rectx,$recty) = $self->coord2pos($x-$width/2,$ymax);
                $texty = $recty + $h + $vi + $textH;
            }
            elsif ($ymin >= 0) # values are all positive
            {
                $h = $yaxis->fetch_dis($y) - $yaxis->fetch_dis($ymin);
                ($rectx,$recty) = $self->coord2pos($x-$width/2,$y);
                $texty = $recty - $vi;
            }
            else
            {
                if ($y > 0)
                {
                    $h = $yaxis->fetch_dis($y) - $yaxis->fetch_dis(0);
                    ($rectx,$recty) = $self->coord2pos($x-$width/2,$y);
                    $texty = $recty - $vi;
                }
                else
                {
                    $h = $yaxis->fetch_dis(0) - $yaxis->fetch_dis($y);
                    ($rectx,$recty) = $self->coord2pos($x-$width/2,0);
                    $texty = $recty + $h + $vi + $textH;
                }
            }

            $parent->rect(x=>$rectx,y=>$recty,width=>$barW,height=>$h,
                    style=>{fill=>$fill_col,stroke=>$color,'stroke-width'=>$swidth});

            # add the val to the bar top
            if ($par->{val})
            {
                my $textW = $font->fetch_text_width($y);
                my $textx = $self->xcoord2pos($x) - $textW/2;
                $parent->text(x=>$textx,y=>$texty)->cdata($y);
            }
        }
    }
}

# fetch y coordinate of bar by stat
sub fetch_y
{
    my $stat = shift;
    my $array = shift;

    if ($stat eq "max")
    {
        return max($array);    
    }
    elsif ($stat eq "min")
    {
        return min($array);
    }
    elsif($stat eq "mean")
    {
        return mean($array);
    }
}

# draw points
sub points
{
    my $self = shift;
    my %param = @_;
    my $opts = restore_cmd(\%param);
    my ($par,$newx,$xval,$yval) = $self->doInitAes2(\%param);
    my @xval = @$xval;
    my @yval = @$yval;
    
    # default fill and col
    my $col = $par->{col} || ["#000"];
    my $fill = $par->{fill} || ["#000"];
    my $shape = exists $par->{shape} ? $par->{shape} : [1];
    my $conf = $par->{conf} || {};
    my $parent = $par->{parent};
    my $level = $par->{level};
    my $swidth = $par->{stroke_width} || 0;
    
    my $size = $par->{size} || 5;
    $conf->{symbol_width} = $size * 2;
    $conf->{symbol_height} = $size * 2;

    # init the symbol 
    my @levels = uniq_arr($level);
    my @symid = map {
        my $pch = loop_arr($shape,$_);
        my $fill_col = loop_arr($fill,$_);
        my $color = loop_arr($col,$_);
        SBV::STONE::SYMBOL::new($pch,fill=>$fill_col,color=>$color,stroke_width=>$swidth);
    } 0 .. $#levels;
    
    # set the legend 
    $self->legend(shape=>$shape,color=>$col,fill=>$fill,stroke_width=>$swidth);
    
    unless ($param{draw})
    {
        push @{$self->{eval}} , "points($opts)";
        return 1;
    }

    my ($xcor,$ycor,$symids);
    foreach my$i( 0 .. $#xval )
    {
        my $x = $newx->{$xval[$i]};
        my $y = $yval[$i];
        my ($rectx,$recty) = $self->coord2pos($x,$y);
        push @$xcor , $rectx;
        push @$ycor , $recty;
        push @$symids , $symid[$level->[$i]];
    }
    
    SBV::DRAW::points($xcor,$ycor,$symids,$conf,$parent);
}

*scatter = \&points;

# honrizontal lines
sub hline
{
    my $self = shift;
    my ($yintercept,%param) = @_;

    unless ($param{draw})
    {
        my $opts = restore_cmd($yintercept) . "," . restore_cmd(\%param);
        push @{$self->{eval}} , "hline($opts)";
        return 1;
    }

    my $parent = $param{parent} || $self->{parent};
    my $style = fetch_line_style(%param);
    
    my $xmin = $self->{xaxis}->{min};
    my $xmax = $self->{xaxis}->{max};
    my $ymin = $self->{yaxis}->{min};
    my $ymax = $self->{yaxis}->{max};

    my $x1 = $self->xcoord2pos($xmin); 
    my $x2 = $self->xcoord2pos($xmax);
    $x1 -= $self->{xaxis}->{start} * $self->{xaxis}->{unit} * $self->{xaxis}->{window};

    my %par = (x1=>$x1,x2=>$x2);
    $par{style} = $style;

    if (ref $yintercept eq "ARRAY")
    {
        foreach my$num (@$yintercept)    
        {
            if ($num > $ymax || $num < $ymin)
            {
                WARN("the hline is in the outside of the axis");
                next;
            }
            
            my $y = $self->ycoord2pos($num);
            $parent->line(y1=>$y,y2=>$y,%par);
        }
    }
    else
    {
        if ($yintercept > $ymax || $yintercept < $ymin)
        {
            WARN("the hline is in the outside of the axis"); 
            next;        
        }
        
        my $y = $self->ycoord2pos($yintercept);
        $parent->line(y1=>$y,y2=>$y,%par);
    }

    return 1;
}

# vertical lines
sub vline
{
    my $self = shift;
    my ($xintercept,%param) = @_;
    
    unless ($param{draw})
    {
        my $opts = restore_cmd($xintercept) . "," . restore_cmd(\%param);
        push @{$self->{eval}} , "vline($opts)";
        return 1;
    }

    my $parent = $param{parent} || $self->{parent};
    my $style = fetch_line_style(%param);
    
    my $xmin = $self->{xaxis}->{min};
    my $xmax = $self->{xaxis}->{max};
    my $ymin = $self->{yaxis}->{min};
    my $ymax = $self->{yaxis}->{max};
    my $y1 = $self->ycoord2pos($ymin); 
    my $y2 = $self->ycoord2pos($ymax);
    $y1 += $self->{yaxis}->{start} * $self->{yaxis}->{window} * $self->{yaxis}->{unit};

    my %par = (y1=>$y1,y2=>$y2);
    $par{style} = $style;

    if (ref $xintercept eq "ARRAY")
    {
        foreach my$num (@$xintercept)    
        {
            if ($num > $xmax || $num < $xmin)
            {
                WARN("the vline is in the outside of the axis");
            }
            else
            {
                my $x = $self->xcoord2pos($num);
                $parent->line(x1=>$x,x2=>$x,%par);
            }
        }
    }
    else
    {
        if ($xintercept > $xmax || $xintercept < $xmin)
        {
            WARN("the vline is in the outside of the axis");
            next;
        }
        else
        {
            my $x = $self->xcoord2pos($xintercept);
            $parent->line(x1=>$x,x2=>$x,%par);
        }
    }

    return 1;
}

# abline
sub abline
{
    my $self = shift;
    my ($k,$b,%param) = @_;
    
    unless ($param{draw})
    {
        my $opts = restore_cmd(\%param);
        push @{$self->{eval}} , "abline($k,$b,$opts)";
        return 1;
    }

    my $parent = $param{parent} || $self->{parent};
    my $style = fetch_line_style(%param);

    if (0 == $k)
    {
        $self->hline($b,%param);
    }
    else
    {
        my $xmin = $self->{xaxis}->{min};
        my $xmax = $self->{xaxis}->{max};
        my $ymin = $self->{yaxis}->{min};
        my $ymax = $self->{yaxis}->{max};
    
        my %par;
        my $flag = 0;
        
        # x = xmin => y = k*xmin + b
        my $temp = $k*$xmin + $b;
        if ($temp >= $ymin && $temp <= $ymax)
        {
            $par{x1} = $xmin;
            $par{y1} = $temp;
            $flag = 1;
        }

        # x = xmax => y = k*xmax + b
        $temp = $k*$xmax + $b;
        if ($temp >= $ymin && $temp <= $ymax)
        {
            if (1 == $flag)
            {
                $par{x2} = $xmax;
                $par{y2} = $temp;
                $flag = 2;
            }
            else
            {
                $par{x1} = $xmax;
                $par{y1} = $temp;
                $flag = 1;
            }
        }

        # y = ymin => x = (ymin-b)/k
        if (2 != $flag)
        {
            $temp = ($ymin-$b)/$k;
            if ($temp >= $xmin && $temp <= $xmax)
            {
                if (0 == $flag)
                {
                    $par{x1} = $temp;
                    $par{y1} = $ymin;
                    $flag = 1;
                }
                elsif (1 == $flag)
                {
                    $par{x2} = $temp;
                    $par{y2} = $ymin;
                    $flag = 2;
                }
            }
        }

        # y = ymax => x = (ymax-b)/k
        if (2 != $flag)
        {
            $temp = ($ymax-$b)/$k;    
            if ($temp >= $xmin && $temp <= $xmax)
            {
                if (0 == $flag)
                {
                    $par{x1} = $temp;
                    $par{y1} = $ymax;
                    $flag = 1;
                }
                elsif (1 == $flag)
                {
                    $par{x2} = $temp;
                    $par{y2} = $ymax;
                    $flag = 2;
                }
            }
        }
        
        if (2 != $flag)
        {
            WARN("the abline is in the outside of the axis!");    
            return;
        }
        
        $par{x1} = $self->xcoord2pos($par{x1});
        $par{x2} = $self->xcoord2pos($par{x2});
        $par{y1} = $self->ycoord2pos($par{y1});
        $par{y2} = $self->ycoord2pos($par{y2});
        $par{style} = $style;

        $parent->line(%par);
    }
    
    return 1;
}

# linerange
sub linerange
{
    my $self = shift;
    my %param = @_;
    $self->range("linerange",%param);
}

# pointrange
sub pointrange
{
    my $self = shift;
    my %param = @_;
    $self->range("pointrange",%param);
}

# crossbar
sub crossbar
{
    my $self = shift;
    my %param = @_;
    $self->range("crossbar",%param);
}

# errbar
sub errbar
{
    my $self = shift;
    my %param = @_;
    $self->range("errbar",%param);
}

# multi group range
sub mrange
{
    my ($self,$type,%param) = @_;
    my $opts = restore_cmd(\%param);
    
    my ($par,$newdata,$xval,$names) = $self->doInitAes_group(\%param);
    my @xval = @$xval;
    my @names = @$names;

    # default fill and col
    my $col = $par->{col} || ["#000"];
    my $fill = $par->{fill} || ["#000"];
    my $width = $par->{width} || 0.8;
    my $size = $par->{size} || 1;
    my $stat = $par->{stat} || "sem";
    my $parent = $par->{parent};
    my $stroke_width = defined $par->{stroke_width} ? $par->{stroke_width} : 2;
    my $shape = fetch_range_shape($type);
    my $factor = $par->{factor};
    
    $self->legend(color=>$col,fill=>$fill,label=>$factor,shape=>[$shape]) if (1 == $par->{legend});

    unless ($param{draw})
    {
        push @{$self->{eval}} , "mrange(\'$type\',$opts)";
        return 1;
    }
    
    my $xaxis = $self->{xaxis};
    my $yaxis = $self->{yaxis};

    my $groupN = scalar @$factor;
    my $barW = $width/$groupN;
    foreach my$i( 0 .. $#names )
    {
        my $name = $names[$i];
        my $x = $xval[$i];
        my $subdata = $newdata->{$name};

        foreach my$j (0 .. $#$factor)
        {
            my $group = $factor->[$j];
            my $color = loop_arr($col,$j);
            my $fill_col = loop_arr($fill,$j);

            my @val = @{$subdata->{$group}};
            my ($mid,$up,$low);
            
            my $style = "stroke:$color;stroke-width:$stroke_width";

            if ($stat eq "sem")
            {
                my $mean = mean(\@val);
                my $sem = sem(\@val);
                $mid = $mean;
                $up = $mean+$sem;
                $low = $mean-$sem;
            }
            elsif ($stat eq "normal")
            {
                my $max = max(\@val);
                my $min = min(\@val);
                my $mean = mean(\@val);
                $mid = $mean;
                $up = $max;
                $low = $min;
            }

            my $y1 = $self->{oy} - $yaxis->fetch_dis($up);    
            my $y2 = $self->{oy} - $yaxis->fetch_dis($mid);    
            my $y3 = $self->{oy} - $yaxis->fetch_dis($low);

            my $x1 = $self->{ox} + $xaxis->fetch_dis($x-$width/2 + $j*$barW + (1-$size)/2*$barW );
            my $x2 = $self->{ox} + $xaxis->fetch_dis($x-$width/2 + ($j+0.5)*$barW);
            my $x3 = $self->{ox} + $xaxis->fetch_dis($x-$width/2 + ($j+1)*$barW - (1-$size)/2*$barW );

            if ($type eq "errbar")
            {
                $parent->line(x1=>$x1,y1=>$y1,x2=>$x3,y2=>$y1,style=>$style,class=>"errbar");
                $parent->line(x1=>$x1,y1=>$y3,x2=>$x3,y2=>$y3,style=>$style,class=>"errbar");
                $parent->line(x1=>$x2,y1=>$y1,x2=>$x2,y2=>$y3,style=>$style,class=>"errbar");
            }
            elsif ($type eq "linerange")
            {
                $parent->line(x1=>$x2,y1=>$y1,x2=>$x2,y2=>$y3,style=>$style,class=>"linerange");
            }
            elsif ($type eq "pointrange")
            {
                my $r = $stroke_width * 2; 
                $parent->line(x1=>$x2,y1=>$y1,x2=>$x2,y2=>$y3,style=>$style,class=>"pointrange");    
                $parent->circle(cx=>$x2,cy=>$y2,r=>$r,style=>"fill:$color;'stroke-width':0");
            }
            elsif ($type eq "crossbar")
            {
                $parent->rect(x=>$x1,y=>$y1,width=>$x3-$x1,height=>$y3-$y1,
                        style=>{stroke=>$color,'stroke-width'=>1,fill=>$fill_col},class=>"crossbar");
                $parent->line(x1=>$x1,x2=>$x3,y1=>$y2,y2=>$y2,
                        style=>$style,class=>"crossbar");
            }
        }
    }

    return 1;
}


sub range
{
    my ($self,$type,%param) = @_;
    my $opts = restore_cmd(\%param);

    if (exists $param{group})
    {
        $self->mrange($type,%param);
        return 1;
    }

    my ($par,$newdata,$xvalue,$names) = $self->doInitAes(\%param);
    my @xval = @$xvalue;
    my @names = @$names;
    
    # default fill and col
    my $col = $par->{col} || ["#000"];
    my $fill = $par->{fill} || ["#000"];
    my $width = $par->{width} || 0.6;
    my $stat = $par->{stat} || "sem";
    my $parent = $par->{parent};
    my $stroke_width = $par->{stroke_width} || 2;
    my $shape = fetch_range_shape($type);
    $self->legend(color=>$col,fill=>$fill,label=>\@names,shape=>[$shape]) if ($par->{legend});
    
    unless ($param{draw})
    {
        push @{$self->{eval}} , "range(\"$type\",$opts)";
        return 1;
    }

    my $xaxis = $self->{xaxis};
    my $yaxis = $self->{yaxis};

    foreach my$i( 0 .. $#names )
    {
        my $name = $names[$i];
        my $x = $xval[$i];
        my $color = loop_arr($col,$i);
        my $fill_col = loop_arr($fill,$i);
        
        my @val = @{$newdata->{$name}};
        
        my ($mid,$up,$low);
        
        if ($stat eq "sem")
        {
            my $mean = mean(\@val);
            my $sem = sem(\@val);
            $mid = $mean;
            $up = $mean+$sem;
            $low = $mean-$sem;
        }
        elsif ($stat eq "normal")
        {
            my $max = max(\@val);
            my $min = min(\@val);
            my $mean = mean(\@val);
            $mid = $mean;
            $up = $max;
            $low = $min;
        }

        my $y1 = $self->{oy} - $yaxis->fetch_dis($up);    
        my $y2 = $self->{oy} - $yaxis->fetch_dis($mid);    
        my $y3 = $self->{oy} - $yaxis->fetch_dis($low);
        
        my $x1 = $self->{ox} + $xaxis->fetch_dis($x-$width/2);
        my $x2 = $self->{ox} + $xaxis->fetch_dis($x);
        my $x3 = $self->{ox} + $xaxis->fetch_dis($x+$width/2);
        
        my $style = "stroke:$color;stroke-width:$stroke_width";

        if ($type eq "errbar")
        {
            $parent->line(x1=>$x1,y1=>$y1,x2=>$x3,y2=>$y1,style=>$style,class=>"errbar");
            $parent->line(x1=>$x1,y1=>$y3,x2=>$x3,y2=>$y3,style=>$style,class=>"errbar");
            $parent->line(x1=>$x2,y1=>$y1,x2=>$x2,y2=>$y3,style=>$style,class=>"errbar");
        }
        elsif ($type eq "linerange")
        {
            $parent->line(x1=>$x2,y1=>$y1,x2=>$x2,y2=>$y3,style=>$style,class=>"linerange");
        }
        elsif ($type eq "pointrange")
        {
            my $r = $stroke_width * 2; 
            $parent->line(x1=>$x2,y1=>$y1,x2=>$x2,y2=>$y3,style=>$style,class=>"pointrange");    
            $parent->circle(cx=>$x2,cy=>$y2,r=>$r,style=>"fill:$color;stroke-width:0");
        }
        elsif ($type eq "crossbar")
        {
            $parent->rect(x=>$x1,y=>$y1,width=>$x3-$x1,height=>$y3-$y1,
                style=>"stroke:$color;'stroke-width':1;fill:$fill_col",class=>"crossbar");
            $parent->line(x1=>$x1,x2=>$x3,y1=>$y2,y2=>$y2,style=>$style,class=>"crossbar");
        }
    }

    return 1;
}

#-------------------------------------------------------------------------------
# multi group boxplot 
#-------------------------------------------------------------------------------
sub mboxplot
{
    my ($self,%param) = @_;
    my $opts = restore_cmd(\%param);

    my ($par,$newdata,$xval,$names) = $self->doInitAes_group(\%param);
    my @xval = @$xval;
    my @names = @$names;
    
    # default fill and col
    my $col = $par->{col} || ["#000"];
    my $fill = $par->{fill} || ["none"];
    my $width = $par->{width} || 0.8;
    my $size = $par->{size} || 0.9;
    my $parent = $par->{parent};

    my $factor = $par->{factor};
    my $groupN = scalar @$factor;
    my $barW = $width/$groupN; 

    $self->legend(fill=>$fill,color=>$col,shape=>[19],label=>$factor);
    
    unless ($param{draw})
    {
        push @{$self->{eval}} , "boxplot($opts)";
        return 1;
    }
    
    my $xaxis = $self->{xaxis};
    my $yaxis = $self->{yaxis};

    foreach my$i( 0 .. $#names )
    {
        my $name = $names[$i];
        my $x = $xval[$i];
        my $subdata = $newdata->{$name};

        for my$j( 0 .. $#$factor)
        {
            my $group = $factor->[$j];
            my $color = loop_arr($col,$j);
            my $fill_col = loop_arr($fill,$j);

            my @val = $subdata->{$group} ?  @{$subdata->{$group}} : next;
            
            my ($q1,$q2,$q3) = SBV::STAT::quartile(\@val);
            my $iqr = $q3 - $q1;

            my $up = $q3 + 1.5*$iqr;
            my $low = $q1 - 1.5*$iqr;

            my ($upval,$lowval,@abnormal);
            foreach (@val)
            {
                if ($_ >= $low)
                {
                    $lowval = $_;
                    last;
                }
                else
                {
                    push @abnormal , $_;    
                }
            }

            foreach (reverse @val)
            {
                if ($_ <= $up)
                {
                    $upval = $_;
                    last;
                }
                else
                {
                    push @abnormal , $_;    
                }
            }
            
            if ($self->{conf}->{flip})
            {
                my $q3x = $self->xcoord2pos($q3);
                my $q2x = $self->xcoord2pos($q2);
                my $q1x = $self->xcoord2pos($q1);
                my $upx = $self->xcoord2pos($upval);
                my $lowx = $self->xcoord2pos($lowval);

                my $h = $q3x - $q1x;
                my $y1 = $self->{oy} - $yaxis->fetch_dis($x-$width/2 + $j*$barW + (1-$size)/2*$barW );
                my $y2 = $self->{oy} - $yaxis->fetch_dis($x-$width/2 + ($j+0.5)*$barW );
                my $y3 = $self->{oy} - $yaxis->fetch_dis($x-$width/2 + ($j+1)*$barW - (1-$size)/2*$barW );
                my $w = $y3 - $y1;
            }
            else
            {
                my $q3y = $self->ycoord2pos($q3);
                my $q2y = $self->ycoord2pos($q2);
                my $q1y = $self->ycoord2pos($q1);
                my $upy = $self->ycoord2pos($upval);
                my $lowy = $self->ycoord2pos($lowval);

                my $h = ($q1y - $q3y);
                my $x1 = $self->{ox} + $xaxis->fetch_dis($x-$width/2 + $j*$barW + (1-$size)/2*$barW );
                my $x2 = $self->{ox} + $xaxis->fetch_dis($x-$width/2 + ($j+0.5)*$barW);
                my $x3 = $self->{ox} + $xaxis->fetch_dis($x-$width/2 + ($j+1)*$barW - (1-$size)/2*$barW );
                my $w = ($x3-$x1);

                # box 
                $parent->rect(x=>$x1,y=>$q3y,width=>$w,height=>$h,
                        style=>{stroke=>$color,fill=>$fill_col,'stroke-width'=>1});

                # median
                $parent->line(x1=>$x1,y1=>$q2y,x2=>$x3,y2=>$q2y,
                        style=>{stroke=>$color,'stroke-width'=>2});

                # upper side to upper quartile
                $parent->line(x1=>$x2,x2=>$x2,y1=>$q3y,y2=>$upy,
                        style=>{stroke=>$color,'stroke-width'=>1});

                # lower side to lower quartile
                $parent->line(x1=>$x2,x2=>$x2,y1=>$q1y,y2=>$lowy,
                        style=>{stroke=>$color,'stroke-width'=>1});

                # abnormal vaule
                foreach my$i (@abnormal)
                {
                    my $iy = $self->ycoord2pos($i);
                    $parent->circle(cx=>$x2,cy=>$iy,r=>2,style=>{fill=>"#000"});
                }
            }
        }
    }
}

# boxplot
sub boxplot
{
    my ($self,%param) = @_;
    my $opts = restore_cmd(\%param);

    if (exists $param{group})
    {
        $self->mboxplot(%param);
        return 1;
    }

    my ($par,$newdata,$xval,$names) = $self->doInitAes(\%param);
    my @xval = @$xval;
    my @names = @$names;
    
    # default fill and col
    my $col = $#{$par->{col}} != -1 ? $par->{col} : ["#000"];
    my $fill = $par->{fill} || ["none"];
    my $width = $par->{width} || 0.6;
    my $parent = $par->{parent};
    
    $self->legend(fill=>$fill,color=>$col,shape=>[19],label=>\@names);
    
    unless ($param{draw})
    {
        push @{$self->{eval}} , "boxplot($opts)";
        return 1;
    }

    my $xaxis = $self->{xaxis};
    my $yaxis = $self->{yaxis};
    foreach my$i( 0 .. $#names )
    {
        my $name = $names[$i];
        my $x = $xval[$i];
        my $color = loop_arr($col,$i);
        my $fill_col = loop_arr($fill,$i);

        my @val = @{$newdata->{$name}};
        my ($q1,$q2,$q3) = SBV::STAT::quartile(\@val);
        my $iqr = $q3 - $q1;

        my $up = $q3 + 1.5*$iqr;
        my $low = $q1 - 1.5*$iqr;
        
        my ($upval,$lowval,@abnormal);
        foreach (@val){if ($_ >= $low){$lowval = $_;last;}else{push @abnormal , $_;}}
        foreach (reverse @val){if ($_ <= $up){$upval = $_;last;}else{push @abnormal , $_;}}
        
        if ($self->{conf}->{flip})
        {
            my $q3x = $self->xcoord2pos($q3);
            my $q2x = $self->xcoord2pos($q2);
            my $q1x = $self->xcoord2pos($q1);
            my $upx = $self->xcoord2pos($upval);
            my $lowx = $self->xcoord2pos($lowval);
            
            my $w = $self->{yaxis}->{unit} * $width;
            my $h = ($q3x - $q1x);

            my $y2 = $self->ycoord2pos($x);
            my $y1 = $y2 - $w/2;
            my $y3 = $y2 + $w/2;

            $parent->rect(x=>$q1x,y=>$y1,width=>$h,height=>$w,
                style=>"stroke:$color;fill:$fill_col;stroke-width:1");
            
            $parent->line(x1=>$q2x,x2=>$q2x,y1=>$y1,y2=>$y3,
                style=>"stroke:$color;stroke-width:2");

            $parent->line(x1=>$q3x,x2=>$upx,y1=>$y2,y2=>$y2,
                style=>"stroke:$color;stroke-width:2");

            $parent->line(x1=>$lowx,x2=>$q1x,y1=>$y2,y2=>$y2,
                style=>"stroke:$color;stroke-width:2");

            foreach my$i (@abnormal)
            {
                my $ix = $self->xcoord2pos($i);
                $parent->circle(cx=>$ix,cy=>$y2,r=>2,style=>{fill=>"#000"});
            }
        }
        else
        {
            my $q3y = $self->ycoord2pos($q3);
            my $q2y = $self->ycoord2pos($q2);
            my $q1y = $self->ycoord2pos($q1);
            my $upy = $self->ycoord2pos($upval);
            my $lowy = $self->ycoord2pos($lowval);

            my $w = $self->{xaxis}->{unit} * $width;
            my $h = ($q1y - $q3y);

            my $x2 = $self->xcoord2pos($x);
            my $x1 = $x2 - $w/2;
            my $x3 = $x2 + $w/2;

            # box 
            $parent->rect(x=>$x1,y=>$q3y,width=>$w,height=>$h,
                    style=>{stroke=>$color,fill=>$fill_col,'stroke-width'=>1});

            # median
            $parent->line(x1=>$x1,y1=>$q2y,x2=>$x3,y2=>$q2y,
                    style=>{stroke=>$color,'stroke-width'=>2});

            # upper side to upper quartile
            $parent->line(x1=>$x2,x2=>$x2,y1=>$q3y,y2=>$upy,
                    style=>{stroke=>$color,'stroke-width'=>1});

            # lower side to lower quartile
            $parent->line(x1=>$x2,x2=>$x2,y1=>$q1y,y2=>$lowy,
                    style=>{stroke=>$color,'stroke-width'=>1});

            # abnormal vaule
            foreach my$i (@abnormal)
            {
                my $iy = $self->ycoord2pos($i);
                $parent->circle(cx=>$x2,cy=>$iy,r=>2,style=>{fill=>"#000"});
            }
        }
    }
}

# bubble
sub bubble
{
    my $self = shift;
    my %param = @_;
    my $opts = restore_cmd(\%param);

    my ($par,$newx,$xval,$yval) = $self->doInitAes2(\%param);
    my @xval = @$xval;
    my @yval = @$yval;
    
    # fetch the z val
    my @zval = doFetchZval($par);

    # default fill and col
    my $col = $par->{col} || ["#000"];
    my $fill = $par->{fill} || ["#000"];
    my $level = $par->{level};
    my $parent = $par->{parent};
    my $stroke_width = defined $par->{stroke_width} ? $par->{stroke_width} : 1;
    $self->legend(fill=>$fill,color=>$col,shape=>[1],stroke_width=>$stroke_width);
    
    unless ($param{draw})
    {
        push @{$self->{eval}} , "bubble($opts)";
        return 1;
    }
    
    # the z val zoom size, turn to the raidus
    my $zoom = $par->{zoom};

    foreach my$i( 0 .. $#xval )
    {
        my $x = $newx->{$xval[$i]};
        my $y = $yval[$i];
        my $r = $zval[$i]*$zoom; 
        my ($cx,$cy) = $self->coord2pos($x,$y);

        my $color = loop_arr($col,$level->[$i]);
        my $fill_col = loop_arr($fill,$level->[$i]);
        
        $parent->circle(cx=>$cx,cy=>$cy,r=>$r,
            style=>{'stroke-width'=>$stroke_width,stroke=>$color,fill=>$fill_col});
    }

}

# lines
sub lines
{
    my $self = shift;
    my %param = @_;
    my $opts = restore_cmd(\%param);

    my ($par,$newx,$xval,$yval) = $self->doInitAes2(\%param);
    my @xval = @$xval;
    my @yval = @$yval;

    # default col
    my $col = $par->{col} || ["#000"];
    my $parent = $par->{parent};
    my $stroke_width = defined $par->{stroke_width} ? $par->{stroke_width} : 2;
    my $stroke_dashes = defined $par->{stroke_dashes} ? $par->{stroke_dashes} : "";
    my $level = $par->{level};
    my @levels = uniq_arr($level);
    $self->legend(color=>$col,shape=>[17],stroke_width=>$stroke_width,stroke_dashes=>$stroke_dashes);
    
    unless ($param{draw})
    {
        push @{$self->{eval}} , "lines($opts)";
        return 1;
    }
    
    my ($xcor,$ycor);
    foreach my$i( 0 .. $#xval )
    {
        my $x = $newx->{$xval[$i]};
        my $y = $yval[$i];
        my $lvs = $level->[$i];
        my ($rectx,$recty) = $self->coord2pos($x,$y);
        push @{$xcor->{$lvs}} , $rectx;
        push @{$ycor->{$lvs}} , $recty;
    }
    
    foreach my$i (0 .. $#levels)
    {
        my $color = loop_arr($col,$i);
        my $points = $parent->get_path(x=>$xcor->{$levels[$i]},y=>$ycor->{$levels[$i]},-type=>'polyline');
        my $style = "stroke:$color;stroke-width:$stroke_width;fill:none;";
        $style.= "stroke-dasharray:$stroke_dashes;";
        my $polyline = $parent->polyline(%$points,style=>$style);
    }

}

# maplot
sub maplot
{
    my ($self,%param) = @_;
    my $opts = restore_cmd(\%param);

    my ($par,$mval,$aval) = $self->doInitAes_maplot(\%param);
    unless ($param{draw})
    {
        push @{$self->{eval}} , "maplot($opts)";
        return 1;
    }
    
    my @xval = @$aval;
    my @yval = @$mval;

    my $fill = $par->{fill} || ["#000"];
    my $color = $par->{color} || ["#000"];
    my $shape = $par->{shape} || [1];
    my $conf = $par->{conf} || {};
    my $parent = $par->{parent};

    my ($xcor,$ycor);
    my $symid = SBV::STONE::SYMBOL::new($shape->[0],fill=>$fill->[0],color=>$color->[0]);
    foreach my$i( 0 .. $#xval )
    {
        my $x = $xval[$i];
        my $y = $yval[$i];
        my ($rectx,$recty) = $self->coord2pos($x,$y);
        push @$xcor , $rectx;
        push @$ycor , $recty;
    }
    
    SBV::DRAW::points($xcor,$ycor,$symid,$conf,$parent);
}

# Ribbons
sub ribbon 
{
    my $self = shift;
    my %param = @_;
    my $opts = restore_cmd(\%param);

    my ($par,$newx,$xval,$ymax) = $self->doInitAes2(\%param);
    my @xval = @$xval;
    my @ymax = @$ymax;
    
    # default fill and col
    my $col = $par->{col} || ["#000"];
    my $fill = $par->{fill} || ["#000"];
    my $opacity = $par->{opacity} || 0.5;
    my $level = $par->{level};
    my @levels = uniq_arr($level);
    my $parent = $par->{parent};
    
    $self->legend(color=>$col,fill=>$fill,shape=>[0],opacity=>$opacity);
    unless ($param{draw})
    {
        push @{$self->{eval}} , "ribbon($opts)";
        return 1;
    }
    
    #fetch the ymin val, if not set the ymin is the bottom value of y axis
    my @ymin = doFetchYmin($par);
    my $edgeY = 0;
    my $yaxis_min = $self->{yaxis}->{min};
    my $yaxis_max = $self->{yaxis}->{max};

    if ($yaxis_max < 0)
    {
        $edgeY = $yaxis_max;
    }
    elsif ($yaxis_min > 0)
    {
        $edgeY = $yaxis_min;    
    }

    my ($xcor,$ycor);
    foreach my$i( 0 .. $#xval )
    {
        my $x = $newx->{$xval[$i]};
        my $y = $ymax[$i];
        my $lvs = $level->[$i];
        my ($rectx,$recty) = $self->coord2pos($x,$y);
        push @{$xcor->{$lvs}} , $rectx;
        push @{$ycor->{$lvs}} , $recty;
    }
    
    for (my$i=$#xval;$i>=0;$i--)
    {
        my $x = $newx->{$xval[$i]};
        my $y = @ymin ? $ymin[$i] : $edgeY;
        my $lvs = $level->[$i];
        my ($rectx,$recty) = $self->coord2pos($x,$y);
        push @{$xcor->{$lvs}} , $rectx;
        push @{$ycor->{$lvs}} , $recty;
    }

    foreach my$i (0 .. $#levels)
    {
        my $color = loop_arr($col,$i);
        my $fill_col = loop_arr($fill,$i);

        my $points = $parent->get_path(x=>$xcor->{$levels[$i]},y=>$ycor->{$levels[$i]},-type=>'polygon');
        $parent->polygon(%$points,style=>{stroke=>$color,fill=>$fill_col,'fill-opacity'=>$opacity});
    }
    
    return 1;
}

*area = \&ribbon;

# polygon 
sub polygon
{
    my $self = shift;
    my %param = @_;
    my $opts = restore_cmd(\%param);

    my ($par,$newx,$xval,$ymax) = $self->doInitAes2(\%param);
    my @xval = @$xval;
    my @ymax = @$ymax;
    
    # default fill and col
    my $col = $par->{col} || ["#000"];
    my $fill = $par->{fill} || ["#000"];
    my $opacity = $par->{opacity} || 0.5;
    my $level = $par->{level};
    my @levels = uniq_arr($level);
    my $parent = $par->{parent};
    
    $self->legend(color=>$col,fill=>$fill,shape=>[0],opacity=>$opacity);
    
    unless ($param{draw})
    {
        push @{$self->{eval}} , "polygon($opts)";
        return 1;
    }

    my ($xcor,$ycor);
    foreach my$i( 0 .. $#xval )
    {
        my $x = $newx->{$xval[$i]};
        my $y = $ymax[$i];
        my $lvs = $level->[$i];
        my ($rectx,$recty) = $self->coord2pos($x,$y);
        push @{$xcor->{$lvs}} , $rectx;
        push @{$ycor->{$lvs}} , $recty;
    }
    
    foreach my$i (0 .. $#levels)
    {
        my $color = loop_arr($col,$i);
        my $fill_col = loop_arr($fill,$i);

        my $points = $parent->get_path(x=>$xcor->{$levels[$i]},y=>$ycor->{$levels[$i]},-type=>'polygon');
        $parent->polygon(%$points,style=>{stroke=>$color,fill=>$fill_col,'fill-opacity'=>$opacity});
    }
    
    return 1;
}

# text
sub text
{
    my $self = shift;
    my %param = @_;
    my $opts = restore_cmd(\%param);

    my ($par,$newx,$xval,$yval) = $self->doInitAes2(\%param);
    my @xval = @$xval;
    my @yval = @$yval;
    
    # fetch the z val as the label
    my @zval = doFetchZval($par);

    # default fill and col
    my $col = $par->{col} || ["#000"];
    my $fill = $par->{fill} || ["#000"];
    $fill = ["#000"] if ($fill->[0] eq "none");
    my $level = $par->{level};
    my $parent = $par->{parent};
    # the font style 
    my $angle = $par->{angle} || 0;
    my $hjust = exists $par->{hjust} ? $par->{hjust} : 0.5;
    my $vjust = exists $par->{vjust} ? $par->{vjust} : 0.5;

    my %fstyle = ();
    $fstyle{'font-size'} = $par->{size} if (defined $par->{size});
    $fstyle{'font-family'} = $par->{family} if (defined $par->{family});
    $fstyle{'font-weight'} = $par->{weight} if (defined $par->{weight});
    $fstyle{'font-style'} = $par->{style} if (defined $par->{style});
    my $font = SBV::Font->new(\%fstyle);
    my $fontH = $font->fetch_text_height;
    
    $self->legend(fill=>$fill,color=>['none'],shape=>[64],
        fstyle=>$fstyle{'font-style'},
        fsize=>$fstyle{'font-size'},
        fweight=>$fstyle{'font-weight'},
        ffamily=>$fstyle{'font-family'});
    
    unless ($param{draw})
    {
        push @{$self->{eval}} , "text($opts)";
        return 1;
    }

    foreach my$i( 0 .. $#xval )
    {
        my $x = $newx->{$xval[$i]};
        my $y = $yval[$i];
        my $label = $zval[$i]; 
        my $fontW = $font->fetch_text_width($label);
        my $fill_col = loop_arr($fill,$level->[$i]);

        my ($cx,$cy) = $self->coord2pos($x,$y);
        my $textx = $cx - $fontW * $hjust; 
        my $texty = $cy + $fontH * $vjust;
        
        $font->setAttr({fill=>$fill_col});
        my $text = $parent->text(x=>$textx,y=>$texty,style=>$font->toStyle)->cdata($label);
        $text->setAttribute("transform","rotate($angle,$cx,$cy)") if ($angle != 0);
    }
    
}

#-------------------------------------------------------------------------------
# init data and other parameter
# for bar (stat = 'max','min','mean','sum' ....), 
# crossbar(other range graph), boxplot etc. 
# used to classify the data
#-------------------------------------------------------------------------------
sub doInitAes
{
    my $self = shift;
    my $param = shift;
    
    my $par = $self->localPar($param,1);
    my $data = $par->{data};
    ERROR('ggplot2_no_data') if (!defined $data);
    
    # x name and y name
    my $xname = $par->{x};
    my $yname = $par->{y};
    my @vars = $data->names;
    if (! defined $xname || ! defined $yname)
    {
        $xname = shift @vars;
        $yname = shift @vars;
    }
    
    # x val is as string or not
    my $xstr = exists $par->{xnames} ? $par->{xnames} : 0;
        
    # x val and y val
    my @xval = @{$data->{col}->{$xname}};
    my @yval = @{$data->{col}->{$yname}};
    
    my $newdata = {};
    my @names;
    for (0 .. $#xval)
    {
        push @names , $xval[$_] if (! defined $newdata->{$xval[$_]});
        push @{$newdata->{$xval[$_]}} , $yval[$_];
    }
    
    if ($xstr)
    {
        @names = @{$par->{order}} if ($par->{order});
        @xval = map { $_ + 0.5 } 0 .. $#names;
        $self->{ticktext} = \@names;
        $self->xlim(0,$#xval+1,1) unless ($param->{draw});
    }
    else
    {
        @names = sort {$a<=>$b} @names;
        @xval = @names;    
        $self->xlim(min(\@xval),max(\@xval)) unless ($param->{draw});
    }
    
    $self->ylim(min(\@yval),max(\@yval)) unless($param->{draw});
    return ($par,$newdata,\@xval,\@names);    
}

sub doInitAes_bar
{
    my $self = shift;
    my $param = shift;
    
    my $par = $self->localPar($param,1);
    my $data = $par->{data};
    ERROR('ggplot2_no_data') if (!defined $data);
    
    # x name and y name
    my $xname = $par->{x};
    my $yname = $par->{y};
    my @vars = $data->names;
    if (! defined $xname || ! defined $yname)
    {
        $xname = shift @vars;
        $yname = shift @vars;
    }
    
    # x val is as string or not
    my $xstr = exists $par->{xnames} ? $par->{xnames} : 0;
        
    # x val and y val
    my @xval = @{$data->{col}->{$xname}};
    my @yval = @{$data->{col}->{$yname}};
    
    my $newdata = {};
    my @names;
    for (0 .. $#xval)
    {
        push @names , $xval[$_] if (! defined $newdata->{$xval[$_]});
        push @{$newdata->{$xval[$_]}} , $yval[$_];
    }
    
    if ($xstr)
    {
        @names = @{$par->{order}} if ($par->{order});
        @xval = map { $_ + 0.5 } 0 .. $#names;
        $self->{ticktext} = \@names;
        $self->xlim(0,$#xval+1,1) unless ($param->{draw});
    }
    else
    {
        @names = sort {$a<=>$b} @names;
        @xval = @names;    
        $self->xlim(min(\@xval),max(\@xval)) unless ($param->{draw});
    }
    
    my @vals;
    my $stat = $par->{stat} || "mean";
    foreach my $x (keys %$newdata)
    {
        push @vals , fetch_y($stat,$newdata->{$x});
    }

    $self->ylim(min(\@vals),max(\@vals)) unless($param->{draw});
    return ($par,$newdata,\@xval,\@names);    
}

sub doInitAes_bar_group
{
    my $self = shift;
    my $param = shift;
    
    my $par = $self->localPar($param,1);
    my $data = $par->{data};
    ERROR('ggplot2_no_data') if (!defined $data);

    # x name and y name
    my $xname = $par->{x};
    my $yname = $par->{y};
    my @vars = $data->names;
    if (! defined $xname || ! defined $yname)
    {
        $xname = $vars[0];
        $yname = $vars[1];
    }
    
    $par->{'stat'} ||= "mean";

    # x val is as string or not
    my $xstr = exists $par->{xnames} ? $par->{xnames} : 0;
        
    # x val and y val
    my @xval = @{$data->{col}->{$xname}};
    my @yval = @{$data->{col}->{$yname}};
    
    my @group = exists $par->{group} ? @{$data->{col}->{$par->{group}}} : map { 1 } 0 .. $#xval;
    my @factors = uniq_arr (\@group);
    $par->{factor} = \@factors;

    my $newdata = {};
    my @names;
    for (0 .. $#xval)
    {
        push @names , $xval[$_] if (! defined $newdata->{$xval[$_]});
        push @{$newdata->{$xval[$_]}->{$group[$_]}} , $yval[$_];
    }
    
    if ($xstr)
    {
        @names = @{$par->{order}} if ($par->{order});
        @xval = map { $_ + 0.5 } 0 .. $#names;
        $self->{ticktext} = \@names;
        $self->xlim(0,$#xval+1,1) unless ($param->{draw});
    }
    else
    {
        @names = sort {$a<=>$b} @names;
        @xval = @names;    
        $self->xlim(min(\@xval),max(\@xval)) unless ($param->{draw});
    }
    
    unless ($param->{draw})
    {
        if ($param->{pileup})
        {
            my @minusVals;
            my @plusVals;
            foreach my$xitem (keys %$newdata)
            {
                my $minus_val = 0;
                my $plus_val = 0;
                foreach my$group (keys %{$newdata->{$xitem}})    
                {
                    my $val = fetch_y($par->{'stat'},$newdata->{$xitem}->{$group});
                    if ($val  <= 0){$minus_val += $val}else{$plus_val += $val}
                }
                push @minusVals , $minus_val;
                push @plusVals , $plus_val;
            }
            $self->ylim(min(\@minusVals),max(\@plusVals));
            my $temp = max(\@plusVals);
            if (max(\@plusVals) == 1){print "OK\n"}
        }
        else
        {
            my @vals;
            foreach my$xitem (keys %$newdata)
            {
                foreach my$group (keys %{$newdata->{$xitem}})
                {
                    my $val = fetch_y($par->{'stat'},$newdata->{$xitem}->{$group});
                    push @vals , $val;
                }
            }
            $self->ylim(min(\@vals),max(\@vals));
        }
        
    }

    return ($par,$newdata,\@xval,\@names);    
}

sub doInitAes_group
{
    my $self = shift;
    my $param = shift;
    
    my $par = $self->localPar($param,1);
    my $data = $par->{data};
    ERROR('ggplot2_no_data') if (!defined $data);
    
    # x name and y name
    my $xname = $par->{x};
    my $yname = $par->{y};
    my @vars = $data->names;
    if (! defined $xname || ! defined $yname)
    {
        $xname = $vars[0];
        $yname = $vars[1];
    }
    
    # x val is as string or not
    my $xstr = exists $par->{xnames} ? $par->{xnames} : 0;
        
    # x val and y val
    my @xval = @{$data->{col}->{$xname}};
    my @yval = @{$data->{col}->{$yname}};
    
    my @group = exists $par->{group} ? @{$data->{col}->{$par->{group}}} : map { 1 } 0 .. $#xval;
    my @factors = uniq_arr (\@group);
    $par->{factor} = \@factors;

    my $newdata = {};
    my @names;
    for (0 .. $#xval)
    {
        push @names , $xval[$_] if (! defined $newdata->{$xval[$_]});
        push @{$newdata->{$xval[$_]}->{$group[$_]}} , $yval[$_];
    }
    
    if ($xstr)
    {
        @names = @{$par->{order}} if ($par->{order});
        @xval = map { $_ + 0.5 } 0 .. $#names;
        $self->{ticktext} = \@names;
        $self->xlim(0,$#xval+1,1) unless ($param->{draw});
    }
    else
    {
        @names = sort {$a<=>$b} @names;
        @xval = @names;    
        $self->xlim(min(\@xval),max(\@xval)) unless ($param->{draw});
    }
    
    unless ($param->{draw})
    {
        $self->ylim(min(\@yval),max(\@yval));
    }
    
    return ($par,$newdata,\@xval,\@names);
}

#-------------------------------------------------------------------------------
#  init data and other parameter 1
#  for density 
#-------------------------------------------------------------------------------
sub doInitAes_density
{
    my $self = shift;
    my $param = shift;
    
    my $par = $self->localPar($param,1);
    my $data = $par->{data};
    ERROR('ggplot2_no_data') if (!defined $data);

    my @vars = $data->names;
    my $xname = $par->{x} || $vars[0];
    
    my $xstr = exists $par->{xnames} ? $par->{xnames} : 0;
    my @xval = @{$data->{col}->{$xname}};
    
    my $newdata = {};
    my @names;
    for (0 .. $#xval)
    {
        push @names , $xval[$_] if (! defined $newdata->{$xval[$_]});
        $newdata->{$xval[$_]} ++;
    }

    if ($xstr)
    {
        @names = @{$par->{order}} if ($par->{order});
        @xval = map { $_ + 0.5 } 0 .. $#names;
        $self->xlim(0,$#xval+1,1) unless ($param->{draw});
    }
    else
    {
        @names = sort {$a<=>$b} @names;
        @xval = @names;
        $self->xlim(min(\@xval),max(\@xval)) unless ($param->{draw});
    }
    
    # get the density 
    my $sum = 0;
    for my$name(@names)
    {
        ERROR('ggplot2_order_err',$name) if (! exists $newdata->{$name});
        $sum += $newdata->{$name};
    }

    for my$name(@names)
    {
        my $density = nearest 0.001 , $newdata->{$name}/$sum;
        $newdata->{$name} = $density;
    }
    
    my @densitys = values (%$newdata);
    $self->ylim(min(\@densitys),max(\@densitys)) unless ($param->{draw});

    return ($par,$newdata,\@xval,\@names);
}

#-------------------------------------------------------------------------------
# init data and other parameter 2
# for point, lines, bubble etc.
# used to save the position of xval(is String)
#-------------------------------------------------------------------------------
sub doInitAes2
{
    my $self = shift;
    my $param = shift;
    
    my $par = $self->localPar($param);
    my $data = $par->{data};
    ERROR('ggplot2_no_data') if (!defined $data);
    
    my (@xval,@yval);

    # x name, y name 
    my $xname = $par->{x};
    my $yname = $par->{y};
    my @vars = $data->names;
    
    my $axis_lim = 1;
    if (ref $xname eq "ARRAY" && ref $yname eq "ARRAY")
    {
        @xval = @$xname;
        @yval = @$yname;
        $axis_lim = 0;
    }
    elsif (! defined $xname || ! defined $yname)
    {
        $xname = shift @vars;
        $yname = shift @vars;
        @xval = @{$data->{col}->{$xname}};
        @yval = @{$data->{col}->{$yname}};
    }
    elsif (-1 != aindex(\@vars,$xname) && -1 != aindex(\@vars,$yname))
    {
        @xval = @{$data->{col}->{$xname}};
        @yval = @{$data->{col}->{$yname}};
    }
    else
    {
        ERROR('no_exists_field');    
    }
    
    # x val is as string or not
    my $xstr = exists $par->{xnames} ? $par->{xnames} : 0;
    
    # turn x val to coord if x val is string
    my %newx;
    my $temp = 0.5;
    my @names;
    if ($xstr)
    {
        foreach (@xval)
        {
            if (! exists $newx{$_})
            {
                push @names , $_;
                $newx{$_} = $temp;
                $temp += 1;
            }
        }
        
        $self->{ticktext} = \@names unless ($param->{draw} || $axis_lim == 0);
        $self->xlim(0,$#names+1,1) unless ($param->{draw} || $axis_lim == 0);
    }
    else
    {
        foreach (@xval)
        {
            $newx{$_} = $_;    
        }
        $self->xlim(min(\@xval),max(\@xval)) unless ($param->{draw} || $axis_lim == 0);
    }
    
    if (defined $par->{stat})
    {
        my $newdata = {};
        my @names;
        my @yval2;
        for (0 .. $#xval)
        {
            push @names , $xval[$_] if (! defined $newdata->{$xval[$_]});
            push @{$newdata->{$xval[$_]}} , $yval[$_];
        }

        foreach my$v(@names)
        {
            push @yval2 , ggplot2_stat($newdata->{$v},$par->{stat});    
        }
        $self->ylim(min(\@yval2),max(\@yval2)) unless ($param->{draw} || $axis_lim==0);
        return ($par,\%newx,\@names,\@yval2);
    }

    $self->ylim(min(\@yval),max(\@yval)) unless ($param->{draw} || $axis_lim==0);
    return ($par,\%newx,\@xval,\@yval);
}


# maplot 
sub doInitAes_maplot
{
    my $self = shift;
    my $param = shift;
    
    my $par = $self->localPar($param);
    my $data = $par->{data};
    ERROR('ggplot2_no_data') if (!defined $data);
    
    # x name, y name 
    my $xname = $par->{x};
    my $yname = $par->{y};
    
    my @vars = $data->names;
    if (! defined $xname || ! defined $yname)
    {
        $xname = shift @vars;
        $yname = shift @vars;
    }
        
    # x val and y val
    my @xval = @{$data->{col}->{$xname}};
    my @yval = @{$data->{col}->{$yname}};
    
    my (@mval,@aval);

    foreach my$i (0 .. $#xval)
    {
        next if ($xval[$i] == 0 || $yval[$i] == 0);
        my $m = log2($xval[$i]) - log2($yval[$i]);
        my $a = 0.5 * (log2($xval[$i]) + log2($yval[$i]));
        push @aval , $a;
        push @mval , $m;
    }
    
    $self->xlim(min(\@aval),max(\@aval)) unless ($param->{draw});
    $self->ylim(min(\@mval),max(\@mval)) unless ($param->{draw});
    return ($par,\@aval,\@mval);
}


#-------------------------------------------------------------------------------
#  fetch the z val
#  for the group/classification information or text labels
#-------------------------------------------------------------------------------
sub doFetchZval
{
    my $par = shift;
    my $data = $par->{data};
    my @vars = $data->names;
    
    my $zname = $par->{z} || $vars[2];
    return @$zname if (ref $zname eq "ARRAY");
    
    ERROR("ggplot2_no_z") if (! defined $zname);
    
    my @zval = @{$data->{col}->{$zname}};

    return @zval;
}

# fetch y min val 
# for ribbon y min 
sub doFetchYmin
{
    my $par = shift;
    my $data = $par->{data};
    my @vars = $data->names;

    my $ymin_name = $par->{ymin};
    if (! defined $ymin_name)
    {
        return ();
    }
    else
    {
        return @{$data->{col}->{$ymin_name}};    
    }
}

#-------------------------------------------------------------------------------
#  stat the array with specific method
#-------------------------------------------------------------------------------
sub ggplot2_stat
{
    my $array = shift;
    my $method = shift;

    if ($method eq "mean")
    {
        return mean($array);
    }
    elsif ($method eq "max")
    {
        return max($array);    
    }
    elsif ($method eq "min")
    {
        return min($array);    
    }
    elsif ($method eq "sum")
    {
        return sum($array);    
    }
    elsif ($method eq "var")
    {
        return var($array);    
    }
    else
    {
        ERROR('ggplot2_stat_method_err',$method);    
    }
}

# restore the cmd 
sub restore_cmd
{
    my ($val) = @_;

    if (ref $val eq "")
    {
        $val = "\'$val\'";
        return $val;
    }
    elsif (ref $val eq "ARRAY")
    {
        my @temp = map {restore_cmd($_)} @$val;
        my $line = join "," , @temp;
        return "[$line]";
    }
    elsif (ref $val eq "HASH")
    {
        my $temp = "draw=>1";
        foreach my$key(keys %$val)
        {
            $temp .= ",$key=>" . restore_cmd($val->{$key});
        }
        return $temp;
    }
    else
    {
        return $val;    
    }
}

# fetch line style
# for abline, hline, vline
sub fetch_line_style
{
    my (%par) = @_;
    
    return $par{style} if ($par{style});

    my $stroke = $par{col} || "#000";
    $stroke = SBV::Colors::fetch_color($stroke);
    my $stroke_width = defined $par{stroke_width} ? $par{stroke_width} : 1;
    
    my $style = "stroke:$stroke;stroke-width:$stroke_width;";
    $style .= "stroke-dasharray:$par{stroke_dashes}" if ($par{stroke_dashes});

    return $style;
}

# 
sub fetch_range_shape
{
    my ($type) = @_;

    if ($type eq "linerange")
    {
        return 20;    
    }
    elsif ($type eq "pointrange")
    {
        return 21;    
    }
    elsif ($type eq "crossbar")
    {
        return 22;    
    }
    elsif ($type eq "errbar")
    {
        return 23;    
    }
}
