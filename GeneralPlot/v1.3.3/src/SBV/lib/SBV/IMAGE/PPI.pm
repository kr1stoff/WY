package SBV::IMAGE::PPI;
#------------------------------------------------+
#    [APM] This moudle is generated by amp.pl    |
#    [APM] Created time: 2013-12-10 15:27:50     |
#------------------------------------------------+
=pod

=head1 Name

SBV::IMAGE::PPI -- draw ppi visualization figure

=head1 Synopsis

This module is not meant to be used directly

=head1 Feedback

Author: Peng Ai
Email:  aipeng0520@163.com

=head1 Version

Version history

=head2 v1.0

Date: 2013-12-10 15:27:50

=cut

use strict;
use warnings;
require Exporter;

use Math::Round;
use FindBin;
use lib "$FindBin::RealBin";
use lib "$FindBin::RealBin/lib";
use lib "$FindBin::RealBin/../";
use lib "$FindBin::RealBin/../lib";

use SBV::DEBUG;
use SBV::Constants;
use SBV::STAT;

sub new 
{
	my ($class,$file,$conf) = @_;
	my $obj = {};

	$obj->{conf} = $conf;
	($obj->{links},$obj->{nodes}) = _load_data_file($file,$conf);
	bless $obj , $class;
	$obj->load_conf($conf);

	return $obj;
}

sub load_conf
{
	my ($self,$conf) = @_;
	
	$self->{ox} = $conf->{ox} or die;
	$self->{oy} = $conf->{oy} or die;
	$self->{tw} = $conf->{tw} or die;
	$self->{th} = $conf->{th} or die;
	$self->{oty} = $conf->{oty} or die;
	
	$self->{angle_offset} = $conf->{angle_offset};
	$self->title($conf->{title}) if ($conf->{title});
	$self->legend(SBV::CONF::fetch_first_conf('legend',$self->{conf})) if ($conf->{show_legend});
	
	# load target nodes file
	if ($conf->{target_nodes_file})
	{
		my $file = check_path($conf->{target_nodes_file});
		$self->load_target_file($file);
	}

	# load nodes definition file
	if ($conf->{node_defs_file})
	{
		my $file = check_path($conf->{node_defs_file});
		$self->load_defs_file($file);
	}

}

sub load_defs_file
{
	my ($self,$file) = @_;
	my $nodes = $self->{nodes};
	
	open FH,$file or die "$!";
	while(<FH>)
	{
		chomp;
		next if ($_ eq "");
		my ($name,$opts) = split /\t/;

		if (defined $opts && exists $nodes->{$name})
		{
			my @attrs = split /;/ , $opts;
			foreach my$attr(@attrs)
			{
				my ($tag,$val) = split /=/ , $attr;
				$nodes->{$name}->{$tag} = $val;
			}

		}
	}
	close FH;
}

sub load_target_file
{
	my ($self,$file) = @_;
	
	my %target;
	open FH,$file or die;
	while(<FH>)
	{
		chomp;
		next if ($_ eq "");
		my @arr = split /,/;
		$target{$_} = 1 foreach (@arr);
	}
	close FH;

	my $nodes = $self->{nodes};
	foreach my$name(keys %$nodes)
	{
		$nodes->{$name}->{show_node} = 0 unless $target{$name};	
	}
}

sub plot
{
	my ($self,$parent) = @_;
	my $conf = $self->{conf};
	my $nodes = $self->{nodes};
	my @target = grep {$nodes->{$_}->{show_node} == 1} keys %$nodes;

	my $ppiGroup = $parent->group(class=>"ppi",id=>"ppi_$SBV::idnum");
	$SBV::idnum ++;

	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};
	
	# draw title
	my $font = SBV::Font->fetch_font('CLASStitle');	
	my $textH = $font->fetch_text_height;
	if (defined $self->{title})
	{
		my $textW = $font->fetch_text_width($self->{title});
		my $x = $self->{ox} + $self->{tw}/2 - $textW/2;
		my $y = $self->{conf}->{oty} + $vi + $textH;
		$ppiGroup->text(x=>$x,y=>$y,class=>"title")->cdata($self->{title});
	}
	
	# draw datasets
	my @datasets = _load_datasets($conf,$nodes);

	# get the datasets sum width (cantain the internal gap)
	my $dataWidth = 0;
	if ($#datasets >= 0)
	{
		for(@datasets) {
			$dataWidth += $_->{width} + 2*$hi;
		}

		$dataWidth += 2*$hi;
	}
	
	my @size = map {$nodes->{$_}->{size}} @target;
	my $max_size = max(\@size);

	# draw basic circle line
	my $R = $self->{tw} > $self->{th} ? $self->{th} : $self->{tw};
	my $r = $R/2;
	my $radius = $r - $dataWidth - $hi*2 - $max_size;
	my $cx = $self->{ox} + $self->{tw}/2;
	my $cy = $self->{oy} - $self->{th}/2;
	$ppiGroup->circle(cx=>$cx,cy=>$cy,r=>$radius,style=>"stroke:#987;stroke-width:1;stroke-dasharray:6 6;fill:none");
	
	my $start = $self->{angle_offset} + 90;
	my $num = scalar @target;
	my $unit_angle = nearest 0.00001 , 360 / $num;

	# creat new plolar coord system for circular tree
	my $polar = SBV::Coordinate::POLAR->new($cx,$cy,parent=>$ppiGroup);

	# save the options
	my %par = (unitA=>$unit_angle,parent=>$ppiGroup,cx=>$cx,cy=>$cy,radius=>$radius,polar=>$polar);

	# draw nodes
	my $ncx = $cx;
	my $ncy = $cy - $radius;
	my $order = 0;
	
	my %angle;
	foreach my$name(@target)
	{
		my $node = $nodes->{$name};

		my $angle = $start + $unit_angle * $order;
		$angle{$name} = $angle;
		$order ++;
		
		# draw node circle
		my $style = _fetch_node_style($node);
		$ppiGroup->circle(cx=>$ncx,cy=>$ncy,r=>$node->{size},
			style=>"$style",transform=>"rotate($angle,$cx,$cy)",class=>"node");
		
		# draw node label
		if ($node->{show_label})
		{
			my $label_font = SBV::Font->new($node->{label_theme});
			my $label_width = $label_font->fetch_text_width($node->{label});
			my $label_height = $label_font->fetch_text_height();

			my $arc = nearest 0.00001 , ($TWOPI*$angle/360);
			my $textx = nearest 0.00001 , ($cx + sin($arc)*$radius) - $label_width/2;
			my $texty = nearest 0.00001 , ($cy - cos($arc)*$radius) + $label_height/2;
			SBV::DRAW::theme_text($ppiGroup,$textx,$texty,$node->{label_theme},$node->{label});
		}
	}

	$par{angle} = \%angle;
	
	# draw links
	my $links = $self->{links};
	foreach my$link(@$links)
	{
		my ($name1,$name2,$attrs) = @$link;
		next unless ($nodes->{$name1}->{show_node} && $nodes->{$name2}->{show_node});

		my $r1 = $radius-$nodes->{$name1}->{size}-$vi*2;
		my $r2 = $radius-$nodes->{$name2}->{size}-$vi*2;
		my ($x1,$y1) = _fetch_coord($cx,$cy,$r1,$angle{$name1});
		my ($x2,$y2) = _fetch_coord($cx,$cy,$r2,$angle{$name2});
		
		my $style = _fetch_link_style($attrs);
		$ppiGroup->path(d=>"M$x1 $y1 C$x1 $y1 $cx $cy $x2 $y2",style=>$style);
	}
	
	# add datasets 
	my %func = (
		heatmap => \&_add_heatmap
	);

	my $dataR = $radius + $max_size + 2*$hi;
	foreach my $dataset(@datasets)
	{
		&{$func{$dataset->{type}}}($dataset,$dataR,%par);
		$dataR += $dataset->{width} + $hi * 2;
	}

	# 
	if (defined $self->{legend})
	{
		$self->{legend}->location($self);
		$self->{legend}->draw($ppiGroup);
	}
}

sub title
{
	my ($self,$str) = @_;
	my $font = SBV::Font->fetch_font('CLASStitle');
	my $textH = $font->fetch_text_height;

	if ($str)
	{
		$self->{th} -= $textH + $SBV::conf->{vspace}*2;
		$self->{oty} += $textH + $SBV::conf->{vspace}*2;
		$self->{title} = $str;
	}
	elsif (defined $self->{title})
	{
		$self->{oty} -= $textH + $SBV::conf->{vspace}*2;
		$self->{th} += $textH + $SBV::conf->{vspace}*2;
		$self->{title} = undef;
	}
}

sub legend
{
	my ($self,$lconf) = @_;
	my $legend = SBV::STONE::LEGEND->new(conf=>$lconf);
	$self->{legend} = $legend;
	$self->{tw} -= $legend->{width};
}

sub _load_data_file
{
	my ($file,$conf) = @_;
	my $sep = "\t";
	
	# set nodes default attributes
	my $node_attrs = {
		show_node => 1,
		color => $conf->{color},
		fill => $conf->{fill},
		size => $conf->{size},
		show_label => $conf->{show_label},
		label_theme => $conf->{label_theme}
	};

	my $links;
	my $nodes;
	open FH,$file or die "$!";
	while(<FH>)
	{
		chomp;
		next if ($_ eq "");
		my ($name1,$name2,$opts) = (split /$sep/ , $_);
		$name1 =~ s/ //g;
		$name2 =~ s/ //g;

		# set links default attributes
		my $link_attrs = {
			thickness => $conf->{link_thickness},
			color => $conf->{link_color}
		};
		
		if ($opts)
		{
			my @attrs = split /;/ , $opts;
			foreach my$attr(@attrs)
			{
				my ($tag,$val) = split /=/ , $attr;
				$link_attrs->{$tag} = $val;
			}
		}

		unless (exists $nodes->{$name1})
		{
			foreach my$attr (keys %$node_attrs)
			{
				$nodes->{$name1}->{$attr} = $node_attrs->{$attr};	
			}
			$nodes->{$name1}->{label} = $name1;
		}
		
		unless (exists $nodes->{$name2})
		{
			foreach my$attr (keys %$node_attrs)
			{
				$nodes->{$name2}->{$attr} = $node_attrs->{$attr};	
			}
			$nodes->{$name2}->{label} = $name2;
		}
		
		push @$links , [$name1,$name2,$link_attrs];
	}
	close FH;

	return ($links,$nodes);
}

sub _fetch_node_style
{
	my $hash = shift;
	my $color = SBV::Colors::fetch_color($hash->{color});
	my $fill = SBV::Colors::fetch_color($hash->{fill});
	return "fill:$fill;stroke:$color;stroke-width:1";
}

sub _fetch_link_style
{
	my $hash = shift;
	my $color = SBV::Colors::fetch_color($hash->{color});
	my $width = $hash->{thickness};
	return "stroke:$color;stroke-width:$width;fill:none";
}

sub _fetch_coord
{
	my ($cx,$cy,$r,$angle) = @_;
	my $arc = nearest 0.0001 , $angle * $TWOPI / 360;
	my $x = nearest 0.01 , $cx + sin($arc)*$r;
	my $y = nearest 0.01 , $cy - cos($arc)*$r;

	return ($x,$y);
}

sub _load_datasets
{
	my ($conf,$nodes) = @_;
	my @datasets = ();
	
	return () if (! $conf->{datasets});
	$conf = SBV::CONF::fetch_first_conf("datasets",$conf,0);

	return () if (! $conf->{dataset});

	# init parameter
	if (ref $conf->{dataset} eq "ARRAY")
	{
		foreach my$subconf(@{$conf->{dataset}})
		{
			my $dataset = _load_dataset($conf,$subconf,$nodes);
			push @datasets , $dataset if (defined $dataset);
		}
	}
	elsif (ref $conf->{dataset} eq "HASH")
	{
		my $dataset = _load_dataset($conf,$conf->{dataset},$nodes);
		push @datasets , $dataset if (defined $dataset);
	}

	return @datasets;
}

sub _load_dataset
{
	my ($conf,$subconf,$nodes) = @_;
	my $dataset = undef;

	if (! defined $subconf->{file})
	{
		WARN("the dataset file is not exists, will be skiped!");
		return $dataset;
	}

	my $file = check_path($subconf->{file});

	my $type  = $subconf->{type} || $conf->{type};
	my $format = $subconf->{format} || $conf->{format};
	my $color = $subconf->{color} || $conf->{color};
	my $width = $subconf->{width} || $conf->{width};
	my $height = $subconf->{height} || $conf->{height};
	my $show = exists $subconf->{show} ? $subconf->{show} : 1;
	#my @color = split /[\s\,\t]+/ , $color;
	#@color = map { SBV::Colors::fetch_color($_) } @color;
	my @color = SBV::Colors::fetch_brewer_color($color);
    $dataset->{type} = $type;
	$dataset->{color} = \@color;
	$dataset->{format} = $format;
	$dataset->{show} = $show;
	$dataset->{width} = $width;
	$dataset->{height} = $height;

	# read the dataset file 
	my $data = SBV::DATA->new(-file=>$file,-format=>$format);
	
	foreach my$name($data->names)
	{
		next unless (exists $nodes->{$name} && $nodes->{$name}->{show_node} == 1);
		$dataset->{data}->{$name} = $data->{$name};
	}
	
	return $dataset;
}


#-------------------------------------------------------------------------------
#  add dataset on ppi figure
#-------------------------------------------------------------------------------

sub _add_heatmap
{
	my ($dataset,$r,%par) = @_;

	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};

	my $angle = $dataset->{height} * $par{unitA};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my $polar = $par{polar};
	my @colors = @{ $dataset->{color} };
	
	my @values = values %{$dataset->{data}};
	my $col_num = scalar @{$values[0]};
	my @nums;
	map { splice(@nums,0,0,@$_) } @values;
	my $max = max(\@nums);
	my $min = min(\@nums);
	my $block_width = $width/$col_num;
	
	foreach my$id(keys %{$dataset->{data}})
	{
		my @vals = @{$dataset->{data}->{$id}};
		my $a = $par{angle}->{$id};
		foreach my$index(0 .. $#vals)
		{
			my $rectr = $r + $index * $block_width;
			my $ratio = ($vals[$index]-$min)/($max-$min);
			my $color = SBV::Colors::fetch_gradient_color($ratio,@colors);
			$polar->prect($rectr,$a-$angle/2,$rectr+$block_width,$a+$angle/2,style=>"fill:$color",class=>"heatmap",theta_type=>"angle");
		}
	}
}
