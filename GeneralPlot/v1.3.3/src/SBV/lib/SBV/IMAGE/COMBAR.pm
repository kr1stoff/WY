package SBV::IMAGE::COMBAR;
#-------------------------------------------------+
#    [APM] This moudle was generated by amp.pl    |
#    [APM] Created time: 2015-10-31 13:30:05      |
#-------------------------------------------------+
=pod

=head1 Name

COMBAR -- draw combination bar plot

=head1 Synopsis

This module is not meant to be used directly

=head1 Feedback

Author: Peng Ai
Email:  aipeng0520@163.com

=head1 Version

Version history

=head2 v1.0

Date: 2015-10-31 13:30:05

=cut

use strict;
use warnings;
require Exporter;
our @ISA = qw(Exporter);

use FindBin;
use lib "$FindBin::RealBin";
use lib "$FindBin::RealBin/lib";
use lib "$FindBin::RealBin/../";
use lib "$FindBin::RealBin/../lib";

use SBV::STAT qw/min max loop_arr sum/;

sub new 
{
	my ($class,$file,$conf) = @_;
	
	my $combarv = {};
	_load_file($combarv,$file,$conf);
	$combarv->{conf} = $conf;
	bless $combarv , $class;
	return $combarv
}

sub plot 
{
	my $class = shift;
	my $parent = shift;
	my $conf = $class->{conf};

	my @samples = $class->samples;
	my @group = $class->group;
	my @allterms = $class->allterm;

	my $width = $conf->{tw};
	my $height = $conf->{th};
	
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};
	
	# calculate the unit width for each sample(column) 
	my $term_font = SBV::Font->fetch_font("term");
	my $term_width = $term_font->fetch_max_text_width(\@allterms);
	my $title_font = SBV::Font->fetch_font("title");
	my $tick_font = SBV::Font->fetch_font("tick");
	my $title_height = $title_font->fetch_text_height;
	my $tick_height = $tick_font->fetch_text_height;
	
	my $unit_width = ($width - $title_height - $term_width - 2*$hi - $conf->{tick_size_y})/($#samples + 1);
	$class->{unit_width} = $unit_width;

	# calculate the unit height for each term(row)
	my $unit_height = ($height - ($title_height*2) - $vi - ($#group +1)*($tick_height+2*$vi))/($#allterms+1);

	# set the ox and oy 
	my $ox = $conf->{ox} + $term_width + $hi + $conf->{tick_size_y} + $title_height + $hi;
	my $oy = $conf->{oty} + $tick_height + $vi;
	
	# fetch the ticks (use this scale whene free_x == 0) 
	my $scale;

	if ($conf->{xlim})
	{
		my ($min,$max) = split /\s+/,$conf->{xlim};
		$scale = SBV::STAT::dividing($min,$max,-ntrue=>1);
	}
	else 
	{
		my @allvalues = $class->values;
		my @sum = map { my@tmp = split /;/,$_; sum(\@tmp); } @allvalues;
		my $max = max(\@sum);
		$scale = SBV::STAT::dividing(0,$max,-ntrue=>0);
	}
	
	if ($conf->{percent_x})
	{
		$scale = SBV::STAT::dividing(0,100,-ntrue=>0,-xtrue=>0);
		$conf->{free_x} = 0;
	}
	
	# set the stroke style 
	my $stroke_width = $conf->{stroke_width} || 0;
	my $stroke_color = $conf->{stroke} ? SBV::Colors::fetch_color($conf->{stroke}) : "black";
	my $stroke_style = "stroke:$stroke_color;stroke-width:$stroke_width;";

	# draw sample names
	if ($conf->{display_colnames})
	{
		foreach my$i(0 .. $#samples)
		{
			my $textw = $title_font->fetch_text_width($samples[$i]);
			my $textx = $ox + $unit_width*$i + $unit_width/2 - $textw/2;
			my $texty = $oy - $vi;
			my $style = $title_font->toStyle;
			$parent->text(x=>$textx,y=>$texty,class=>"title")->cdata($samples[$i]);
		}
	}
	
	# draw the box and term 
	my $y = $oy;
	foreach my$group (@group)
	{
		my @terms = $class->terms($group);
		my $height = @terms * $unit_height;
		
		# draw class names 
		if ($conf->{display_rownames})
		{
			my $textw = $title_font->fetch_text_width($group);
			my $textx = $conf->{ox} + $title_height;
			my $texty = $y + $height/2 + $textw/2;
			my $style = $title_font->toStyle;
			$parent->text(x=>$textx,y=>$texty,class=>"title",transform=>"rotate(-90,$textx,$texty)")->cdata($group);
		}

		# draw main box 
		foreach my$i (0 .. $#samples)
		{
			next unless $class->{data}{$samples[$i]}{$group};
			$parent->rect(x=>$ox+$i*$unit_width,y=>$y,width=>$unit_width,height=>$height,class=>"main");
		}

		# draw term and its ticks 
		foreach my$i (0 .. $#terms)
		{
			my $termw = $term_font->fetch_text_width($terms[$i]);
			my $termx = $conf->{ox} + $title_height + $hi + $term_width - $termw;
			my $termy = $y + $i*$unit_height + $unit_height/2 + $term_font->fetch_text_height/2;
			$parent->text(x=>$termx,y=>$termy,class=>"term")->cdata($terms[$i]);

			# draw y ticks 
			foreach my$j(0 .. $#samples)
			{
				next unless $class->{data}{$samples[$j]}{$group};
				my $ticky = $y + $i*$unit_height + $unit_height/2;
				my $tickx = $ox+$j*$unit_width;
				$parent->line(x1=>$tickx,x2=>$tickx-$conf->{tick_size_y},y1=>$ticky,y2=>$ticky,class=>"tick");
			}
		}
		
		# draw bar and x ticks 
		foreach my$i (0 .. $#samples)
		{
			next unless $class->{data}{$samples[$i]}{$group};
			my @values = map {  $class->value($samples[$i],$group,$_) } @terms;
			my @temp = split /;/,$values[0];
			my $temp_number = scalar @temp;
			my @sum = map { my@tmp = split /;/,$_; sum(\@tmp); } @values;
			my $max = max(\@sum);
			$scale = SBV::STAT::dividing(0,$max) if (1 == $conf->{free_x});

			# top x axis ticks 
			my %axis_par = (parent=>$parent,ox=>$ox+$i*$unit_width,
				oy=>$y,length=>$unit_width,start=>0,translate=>0,
				tick=>$scale,bone=>0,size=>$conf->{tick_size_x},
				show_tick_label=>0,side=>"right");
			my $axis1 = SBV::STONE::AXIS->new(%axis_par);
			$axis1->plot;
			
			# bottom x axis ticks 
			%axis_par = (parent=>$parent,ox=>$ox+$i*$unit_width,
				oy=>$y+$height,length=>$unit_width,start=>0,translate=>0,
				tick=>$scale,bone=>0,size=>$conf->{tick_size_x},
				show_tick_label=>0,skip_first_tick=>0,side=>"left");
			my $axis2 = SBV::STONE::AXIS->new(%axis_par);
			$axis2->plot;
			
			%axis_par = (parent=>$parent,ox=>$ox+$i*$unit_width,
				oy=>$y+$height,length=>$unit_width,start=>0,translate=>0,
				tick=>$scale,bone=>0,size=>$conf->{tick_size_x},
				show_tick_label=>1,skip_first_tick=>0,show_tick_line=>0,side=>"right");
			if ($conf->{percent_x})
			{
				$axis_par{unit_label} = "%";
				$axis_par{skip_last_tick} = 0;
			}
			my $axis3 = SBV::STONE::AXIS->new(%axis_par);
			$axis3->plot;
			
			# set the bar colors and draw bar 
			my $num = $temp_number == 1 ? scalar @terms : $temp_number;
			my @colors = SBV::Colors::rainbow($num);
			if ($conf->{colors})
			{
				#@colors = split /\s+/,$conf->{colors};
				#@colors = map {SBV::Colors::fetch_color($_)} @colors;
                @colors = SBV::Colors::fetch_brewer_color($conf->{colors});
			}

			foreach my$j(0 .. $#terms)
			{
				my $val = $class->value($samples[$i],$group,$terms[$j]);
				my $barx = $ox + $i*$unit_width;
				my $bary = $y + $j*$unit_height + $unit_height/2 - ($conf->{size}*$unit_height)/2;
				
				if ($temp_number == 1)
				{
					my $bar_size = $axis3->fetch_coord($val) - $barx;
					my $color = loop_arr(\@colors,$j);
					$parent->rect(x=>$barx,y=>$bary,width=>$bar_size,height=>$conf->{size}*$unit_height,style=>"fill:$color;$stroke_style");
				}
				elsif ($temp_number == 2 && $conf->{percent_x})
				{
					my ($up,$down) = split /;/,$val;

					my $bar_height = $conf->{size}*$unit_height;
					
					# draw left bar 
					my $up_bar_size = $axis3->fetch_coord($up) - ($ox + $i*$unit_width);
					my $up_bar_color = $colors[0];
					$parent->rect(x=>$barx,y=>$bary,width=>$up_bar_size,height=>$bar_height,style=>"fill:$up_bar_color;$stroke_style");

					my $down_bar_color = $colors[1];
					my $down_bar_size = $axis3->fetch_coord($down) - ($ox + $i*$unit_width);
					my $down_bar_x = $barx + $axis3->fetch_coord(100 - $down) - ($ox + $i*$unit_width);
					$parent->rect(x=>$down_bar_x,y=>$bary,width=>$down_bar_size,height=>$bar_height,style=>"fill:$down_bar_color;$stroke_style");
				}
				else 
				{
					my @numbers = split /;/,$val;
					foreach my $k (0 .. $#numbers)
					{
						my $bar_size = $axis3->fetch_coord($numbers[$k]) - ($ox + $i*$unit_width);
						my $color = $colors[$k];
						$parent->rect(x=>$barx,y=>$bary,width=>$bar_size,height=>$conf->{size}*$unit_height,style=>"fill:$color;$stroke_style");
						$barx += $bar_size;
					}
				}
			}
		}
		
		$y += $height + 2*$vi + $tick_height;
	}
	
	# draw x lab 
	my $xlab = $conf->{xlab} || "Number of genes";
	my $xlabw = SBV::Font->fetch_font("xlab")->fetch_text_width($xlab);
	my $xlabx = $ox + (($#samples+1)*$unit_width)/2 - $xlabw/2;
	my $xlaby = $conf->{oy};
	$parent->text(x=>$xlabx,y=>$xlaby,class=>"xlab")->cdata($xlab);
	
	# add legend
	if ($conf->{legend})
	{
		my $legend = SBV::STONE::LEGEND->new(conf=>$conf->{legend});
		$legend->location($conf);
		$legend->draw($parent);
	}
}

sub _load_file
{
	my ($class,$file,$conf) = @_;

	my (%samples,%group);
	
	$conf->{min_total_size} ||= 1;

	my %flags;
	open IN,$file or die $!;
	<IN> if ($conf->{header});
	while(<IN>)
	{
		chomp;
		my ($term,$number,$sample,$group) = split /\t/;
		next if (defined $flags{$group}{$term} && 1 == $flags{$group}{$term});
		
		my @temp = split /;/,$number;
		my $sum = sum(\@temp);

		if ($sum < $conf->{min_total_size})
		{
			$flags{$group}{$term} = 0;
		}
		else
		{
			$flags{$group}{$term} = 1;
		}
	}
	close IN;

	open IN,$file or die $!;
	<IN> if ($conf->{header});
	while(<IN>)
	{
		chomp;
		my ($term,$number,$sample,$group) = split /\t/;
		next unless (1 == $flags{$group}{$term});

		unless ($class->{number_count})
		{
			my @temp = split /;/,$number;
			my $count = scalar @temp;
			$class->{number_count} = $count;
		}
		
		$class->{data}{$sample}{$group}{$term} = $number;
		push @{$class->{sample}} , $sample unless $samples{$sample};
		$samples{$sample} = 1;
		push @{$class->{group}} , $group unless $group{$group};
		$group{$group} = 1;
		push @{$class->{$sample}{allterm}} , $term;
		push @{$class->{term}{$sample}{$group}} , $term;
		push @{$class->{values}} , $number;
	}
	close IN;
}

sub samples
{
	my $class = shift;
	return @{$class->{sample}};
}

sub group
{
	my $class = shift;
	return @{$class->{group}};
}

sub terms
{
	my $class = shift;
	my $group = shift;
	my @samples = $class->samples;
	
	my %terms;
	my $i;
	foreach my $sample (@samples)
	{
		foreach (@{$class->{term}{$sample}{$group}})
		{
			$terms{$_} = ++ $i unless $terms{$_};
		}
	}
	
	my @terms = sort {$terms{$a}<=>$terms{$b}} keys %terms;
	
	return @terms;
	#return @{$class->{term}{$samples[0]}{$group}};
}

sub allterm
{
	my $class = shift;
	my @samples = $class->samples;
	
	my %hash;
	my $i;
	foreach my $sample (@samples)
	{
		foreach (@{$class->{$sample}{allterm}})
		{
			$hash{$_} = ++ $i unless $hash{$_};
		}
	}
	
	my @allterms = sort {$hash{$a}<=>$hash{$b}} keys %hash;
	return @allterms;
}

sub value
{
	my ($class,$sample,$group,$term) = @_;
	
	if ($class->{data}{$sample}{$group}{$term})
	{
		return $class->{data}{$sample}{$group}{$term};
	}
	else 
	{
		my $count = $class->{number_count};
		my @temp = map { "0" } 1 .. $count;
		return ${[ join ";",@temp ]}[0];
	}
}

sub values
{
	my $class = shift;
	return @{$class->{values}};
}
