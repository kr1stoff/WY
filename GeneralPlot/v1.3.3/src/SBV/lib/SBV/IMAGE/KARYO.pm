package SBV::IMAGE::KARYO;
#------------------------------------------------+
#    [APM] This moudle is generated by amp.pl    |
#    [APM] Created time: 2013-11-04 15:06:23     |
#------------------------------------------------+
=pod

=head1 Name

SBV::IMAGE::KARYO -- the module to draw karyotype figure

=head1 Synopsis

This module is not meant to be used directly

=head1 Feedback

Author: Peng Ai
Email:  aipeng0520@163.com

=head1 Version

Version history

=head2 v1.0

Date: 2013-11-04 15:06:23

=cut


use strict;
use warnings;
require Exporter;

use Math::Round;
use Math::Cephes qw(:trigs);
use FindBin;
use lib "$FindBin::RealBin";
use lib "$FindBin::RealBin/lib";
use lib "$FindBin::RealBin/..";
use lib "$FindBin::RealBin/../lib";

use SBV::STAT;
use SBV::DEBUG;
use SBV::CONF;
use SBV::Constants;

sub new 
{
    my ($class,$data,$conf) = @_;
    my $object = {};
    
    $object->{data} = $data;
    $object->{conf} = $conf;

    bless $object , $class;
    return $object;
}

sub plot
{
    my ($self,$parent,%opts) = @_;
    my $conf = $self->{conf};
    $self->{parent} = $parent;
    my $model = $opts{model} || $conf->{model};
        
    SBV::DRAW::background($conf,$parent);
    my $group = $parent->group(id=>"karyo$SBV::idnum");
    $SBV::idnum ++;
    $self->{group} = $group;

    if ($model eq "normal" || $model eq "horizontal")
    {
        $self->normal_karyo("normal");    
    }
    elsif ($model eq "vertical")
    {
        $self->normal_karyo("vertical");
    }
    elsif ($model eq "circular")
    {
        $self->circular_karyo;
    }
    
    #chrlocJS();
    
    # add legend
    if ($conf->{legend})
    {
        my $legend = SBV::STONE::LEGEND->new(conf=>$conf->{legend});
        $legend->location($conf);
        $legend->draw($parent);
    }
}

sub chrlocJS
{
    my $js = <<JS;
var svgdoc;
var svgns = "http://www.w3.org/2000/svg";
var isIE = document.all?true:false;
var prompt;
var line;
var group; 
var link;

function hlg_onmouseover(evt,y1,y2,label)
{
    svgdoc = evt.target.ownerDocument;
    line = evt.target;
    group = line.parentElement;
    line.setAttribute("style","stroke:#f00;stroke-width:3");
    var x = line.getAttribute("x1");

    prompt = svgdoc.createElementNS(svgns,"g");
    group.appendChild(prompt);

    link =  svgdoc.createElementNS(svgns,"line");
    link.setAttribute("x1",x);
    link.setAttribute("x2",x);
    link.setAttribute("y1",y1);
    link.setAttribute("y2",y2);
    link.setAttribute("style","stroke:#f00;stroke-width:2");
    prompt.appendChild(link);
}

function hlg_onmouseout(evt)
{
    svgdoc = evt.target.ownerDocument;
    line.setAttribute("style","stroke:#000;stroke-width:2");
    prompt.removeChild(link);
    group.removeChild(prompt);
}
JS
    $SBV::svg->script(type=>"text/javascript")->CDATA($js);
}

sub normal_karyo
{
    my $self = shift;
    my $model = shift;
    my $conf = $self->{conf};
    my $data = $self->{data};
    my $parent = $self->{group};
    
    # load datasets 
    my $ideogram = $conf->{ideogram};
    $data = parse_ideogram($data,$ideogram);
    $data = parse_ticks($data,$conf);
    $data = parse_highlights($data,$conf);
    
    my @links = parse_links($conf);
    my @plots = parse_plots($conf);
    
    my @chrorder = fetch_chromosomes_order($data,$ideogram);
    my @chrsize = map { $data->{$_}->{size} } @chrorder;
    
    # set the width and height
    my $karyoW = $conf->{tw};
    my $karyoH = $conf->{th};
    my $ox = $conf->{ox};
    my $oty = $conf->{oty};
    my $cx = $conf->{ox} + $karyoW/2;
    my $cy = $conf->{oty} + $karyoH/2;
    
    if ($model eq "vertical")
    {
        $parent->setAttribute("transform","rotate(90,$cx,$cy)");
        ($karyoW,$karyoH) = ($karyoH,$karyoW);
        $ox = $cx - $karyoW/2;
        $oty = $cy - $karyoH/2;
    }

    my $chr_unit_h = $karyoH / ($#chrorder+1);
    my ($chr_label_w,$chr_label_h) = fetch_chr_label_size($data,\@chrorder,$ideogram);
    my $hspace = $SBV::conf->{hspace};
    my $label_font = SBV::Font->fetch_font('chr_label');
    my $zoom = ($karyoW - $chr_label_w - $hspace*3)/max(\@chrsize);
    my $thickness = $ideogram->{thickness};
    my $start = SBV::CONF::fetch_size($conf->{start},$chr_unit_h);

    $conf->{orientation} = "left";
    if ($conf->{orientation} eq "left")
    {
        my $y = nearest 0.01 , ($oty + $start);
        my $x = $ox;
        my $rectx = nearest 0.01 , ($x + $chr_label_w + $hspace*2);
        foreach my$chr(@chrorder)
        {
            $data->{$chr}->{ycoord} = $y;
            my $reverse = $data->{$chr}->{reverse};
            
            # draw label 
            if ($ideogram->{show_label} && $ideogram->{show})
            {
                my $label = $ideogram->{label_with_tag} ? $data->{$chr}->{label} : $chr;
                my ($textx,$texty);

                if ($ideogram->{label_parallel})
                {
                    $textx = $x + $chr_label_w - $label_font->fetch_text_width($label) + $hspace;
                    $texty = $y + $chr_label_h/2;
                    $parent->text(class=>"chr_label",x=>$textx,y=>$texty)->cdata($label);
                }
                else
                {
                    $textx = $x + $chr_label_w + $hspace;
                    $texty = $y + $chr_label_h/2;
                    $parent->text(class=>"chr_label",x=>$textx,y=>$texty,transform=>"rotate(-90,$textx,$texty)")->cdata($label);
                }
            }
            
            my $upy = $y - $thickness/2;
            my $downy = $y + $thickness/2;
            my $width = nearest 0.01 , $zoom * $data->{$chr}->{size};
            $data->{$chr}->{upcoord} = $upy;
            $data->{$chr}->{downcoord} = $downy;
            $data->{$chr}->{width} = $width;
            
            # draw tick
            my$ticks = $data->{$chr}->{ticks};
            if ($ticks && $ideogram->{show})
            {
                foreach my$tick (@$ticks)
                {
                    my $orientation = $tick->{orientation} || "up";
                    my $offset = $tick->{offset} || 0;
                    my $size = $tick->{size};
                    my $bone = 0 == $offset ? 0 : 1;
                    my $transx = $rectx;
                    my $transy;
                    my $side;

                    if ($orientation eq "up")
                    {
                        $transy = $upy - $offset;
                        $side = "left";
                    }
                    elsif ($orientation eq "down")
                    {
                        $transy = $downy + $offset;
                        $side = "right";
                    }
                    else
                    {
                        ERROR('ticks_orientation_err',$orientation);
                    }
                    
                    my $min_tick = 0;
                    my $start = 0;

                    if ($data->{$chr}->{sta} > 1 && $tick->{show_true_ticks})
                    {
                        $min_tick = int ($data->{$chr}->{sta} * $tick->{label_multiplier} + 1);
                        $start = ($min_tick - $data->{$chr}->{sta} * $tick->{label_multiplier})/($tick->{spacing}*$tick->{label_multiplier});
                    }

                    my $tickObj = $parent->group(class=>"ticks",transform=>"translate($transx,$transy)");
                    my $axis = SBV::STONE::AXIS->new(ox=>0,oy=>0,length=>$width,bone=>$bone,
                        size=>$size,start=>$start,show_tick_label=>$tick->{show_label},side=>$side,
                        tick=>"$min_tick $data->{$chr}->{size} $tick->{spacing}",skip_first_tick=>0,unit_label=>$tick->{unit_label},
                        multiple=>$tick->{label_multiplier},parent=>$tickObj,theme=>$tick->{tick_label_theme});
                    
                    if ($reverse)
                    {
                        #my $label_theme = "angle:-180";
                        my $label_theme = "$tick->{tick_label_theme}" if ($tick->{tick_label_theme});
                        $side = $side eq "left" ? "right" : "left";
                        $axis->aes(ox=>$width,angle=>180,side=>$side,theme=>$label_theme);
                    }

                    $axis->plot();
                }
            }
            
            # draw chr ideogram
            my $fill = $ideogram->{chromosomes_color} ? $data->{$chr}->{color} : "none";
            my $stroke = $ideogram->{chromosomes_stroke_color} // "#000"; 
            $stroke = $fill if ($stroke eq "fill");
            my $style = "fill:$fill;stroke-width:$ideogram->{chromosomes_stroke_width};stroke:$stroke";
            my $recty = $upy;
            my $rx = $ideogram->{chromosomes_rounded_ends} ? $thickness/2 : 0;
            my $ry = $rx;
            $parent->rect(x=>$rectx,y=>$recty,width=>$width,height=>$thickness,rx=>$rx,ry=>$ry,
                style=>$style,class=>"ideogram") if ($ideogram->{show});
            
            # draw highlights
            if (my$highlights = $data->{$chr}->{highlights})
            {
                foreach my$hl (@$highlights)
                {
                    my ($hl_x,$hl_y,$hl_w,$hl_h,$shape);

                    if ($hl->{ideogram})
                    {
                        $hl_y = $upy;
                        $hl_h = $thickness;
                    }
                    else
                    {
                        my ($loc0,$loc1) = ($hl->{loc0},$hl->{loc1});
                        $loc0 = $loc0 < 0  ? $upy + $loc0 : $downy + $loc0;
                        $loc1 = $loc1 < 0  ? $upy + $loc1 : $downy + $loc1;
                        ($loc0,$loc1) = ($loc1,$loc0) if ($loc0 > $loc1);
                        $hl_y = $loc0;
                        $hl_h = $loc1 - $loc0;
                    }

                    my ($sta,$end) = ($hl->{start},$hl->{end});
                    $hl_x = 0 == $reverse ? cal_coord($data,$chr,$sta,$zoom,$rectx) : cal_coord($data,$chr,$end,$zoom,$rectx);
                    $hl_w = cal_dis($sta,$end,$zoom); 
                    
                    if ($sta == $end)
                    {
                        $hl_w = $hl->{radius} ? $hl->{radius} * 2 : 8;
                        $hl_x -= $hl_w/2;
                    }

                    delete $hl->{width};
                    delete $hl->{height};
                    my $symid = SBV::STONE::SYMBOL::new($hl->{shape},width=>$hl_w,height=>$hl_h,%$hl);
                    my $hlg = $parent->group(class=>"highlights")->use(x=>$hl_x,y=>$hl_y,width=>$hl_w,height=>$hl_h,'-href'=>"#$symid");
                }
            }
            
            $y = nearest 0.01 , ($y + $chr_unit_h);
        }

        # draw links 
        my $linksObj = $parent->group(class=>"links");
        foreach my$link (@links)
        {
            my ($chr1,$sta1,$end1,$chr2,$sta2,$end2,$attrs) = @$link;
            my $x1 = cal_coord($data,$chr1,$sta1,$zoom,$rectx);
            my $x2 = cal_coord($data,$chr1,$end1,$zoom,$rectx);
            my $x3 = cal_coord($data,$chr2,$end2,$zoom,$rectx);
            my $x4 = cal_coord($data,$chr2,$sta2,$zoom,$rectx);
            my $y1 = $data->{$chr1}->{ycoord};
            my $y2 = $data->{$chr2}->{ycoord};
            
            if ($y1 < $y2)
            {
                $y1 += $attrs->{loc0};
                $y2 -= $attrs->{loc1};
                my @xcoord = ($x1,$x2,$x3,$x4);
                my @ycoord = ($y1,$y1,$y2,$y2);
                SBV::DRAW::area(\@xcoord,\@ycoord,parent=>$linksObj,%$attrs);
            }
            elsif ($y1 > $y2)
            {
                $y1 -= $attrs->{loc0};
                $y2 += $attrs->{loc1};
                my @xcoord = ($x1,$x2,$x3,$x4);
                my @ycoord = ($y1,$y1,$y2,$y2);
                SBV::DRAW::area(\@xcoord,\@ycoord,parent=>$linksObj,%$attrs);
            }
            else  # y1 = y2 (chr1 = chr2)
            {
                ($x1,$x2) = ($x2,$x1) if ($x1 > $x2);
                ($x3,$x4) = ($x4,$x3) if ($x3 > $x4);

                if ($x2 > $x3)
                {
                    vital_warn("to draw the link, two regions in the same chr can't be overlaped,[$end1 > $sta2]");
                    next;
                }
                
                $y1 += $attrs->{loc0};
                $y = $y2 + $attrs->{loc1} * 4;
                
                my $qx1 = ($x1+$x4)/2;
                my $qx2 = ($x3+$x2)/2;
                my $pathd = "M$x1,$y1 Q$qx1,$y,$x4,$y1 H$x3 Q$qx2,$y,$x2,$y1 Z";
                SBV::DRAW::path($pathd,parent=>$linksObj,%$attrs);
            }
        }
        
        # draw plots
        my $plotsObj = $parent->group(class=>"plots");
        foreach my$plot(sort {$a->{z} <=> $b->{z}} @plots)
        {
            my $plotObj = $plotsObj->group(class=>"plot");

            foreach my$chr(keys %{$plot->{data}})
            {
                next unless defined $data->{$chr}->{display};
                _add_plot($data,$plot,$chr,$zoom,$rectx,$plotObj);
            }
        }
    }
}

sub circular_karyo 
{
    my $self = shift;
    my $conf = $self->{conf};
    my $data = $self->{data};
    my $parent = $self->{group};
    my $vspace = $SBV::conf->{vspace};

    # load datasets 
    my $ideogram = $conf->{ideogram};
    $data = parse_ideogram($data,$ideogram);
    $data = parse_ticks($data,$conf);
    $data = parse_highlights($data,$conf);
    
    my @links = parse_links($conf);
    my @plots = parse_plots($conf);
    
    my @chrorder = fetch_chromosomes_order($data,$ideogram);
    my @chrsize = map { $data->{$_}->{size} } @chrorder;
    
    # 
    my $cx = $conf->{ox} + $conf->{tw}/2;
    my $cy = $conf->{oty} + $conf->{th}/2;

    my ($chr_label_w,$chr_label_h) = fetch_chr_label_size($data,\@chrorder,$ideogram);
    my $hspace = $SBV::conf->{hspace};
    my $label_font = SBV::Font->fetch_font('chr_label');
    my $label_h = $label_font->fetch_text_height;
    my $thickness = $ideogram->{thickness};

    my $Gsize = sum(\@chrsize); # whole genome size
    my $GCsize = $Gsize; # global cirle size
    my $leaf = $conf->{ideogram}->{spacing};
    
    for my$i(0 .. $#chrorder)
    {
        my $id1 = $chrorder[$i];
        my $id2 = $chrorder[$i+1] || $chrorder[0];
        my $spacing = ideogram_spacing($id1,$id2,$leaf,$Gsize);
        $GCsize += $spacing;
    }
    
    my $zoom = 360 / $GCsize;

    # draw 
    my $polar = SBV::Coordinate::POLAR->new($cx,$cy,parent=>$parent);
    my $rotation = $conf->{rotation};
    my $radius = $conf->{radius};
    
    my $clip_width = $conf->{clip_width} || 50;

    # define the clip path
    my $clip_id = "ideogram_clip";
    my $clip = $SBV::defs->clipPath(id=>$clip_id,style=>"evenodd",clipPathUnits=>"UserSpaceOnUse");
    my $clipy1 = $cy - $radius - $thickness/2 - 2;
    my $clipy2 = 0;
    my $clipr1 = $thickness/2 + $radius + 2;
    my $clipr2 = $cy;
    my $clipx1 = $cx - 1;

    $clip->path(d=>"M$cx $clipy1 A$clipr1 $clipr1 $TWOPI 1 1 $clipx1 $clipy1 L$clipx1 $clipy2 A$clipr2 $clipr2  $TWOPI 1 0 $cx $clipy2",style=>"stroke-width:0;fill:#fff");

    my $angle = $rotation;
    foreach my$i(0 .. $#chrorder)
    {
        my $id1 = $chrorder[$i];
        my $id2 = $chrorder[$i+1] || $chrorder[0];
        my $angle2 = $angle + $zoom * $data->{$id1}->{size};
        my $reverse = $data->{$id1}->{reverse};
        $data->{$id1}->{angle} = $angle;
        $data->{$id1}->{angle2} = $angle2;
        $data->{$id1}->{radius} = $radius unless $data->{$id1}->{radius};
        $data->{$id1}->{thickness} = $thickness unless $data->{$id1}->{thickness};
        my $outer_r = $data->{$id1}->{radius} + $data->{$id1}->{thickness}/2; 
        my $inner_r = $data->{$id1}->{radius} - $data->{$id1}->{thickness}/2;
        $data->{$id1}->{outer_r} = $outer_r;
        $data->{$id1}->{inner_r} = $inner_r;

        # draw ideogram
        my $fill  = $ideogram->{chromosomes_color} ? $data->{$id1}->{color} : "none";
        my $stroke = $ideogram->{chromosomes_stroke_color} // "#000"; 
        $stroke = $fill if ($stroke eq "fill");
        my $style = "fill:$fill;stroke-width:$ideogram->{chromosomes_stroke_width};stroke:$stroke";
        $polar->fan($outer_r,$angle,$inner_r,$angle2,style=>$style,class=>"ideogram") if ($ideogram->{show});
        
        # draw highlights
        if (my$highlights = $data->{$id1}->{highlights})
        {
            foreach my$hl (@$highlights)
            {
                my ($r0,$r1);
                if ($hl->{ideogram})
                {
                    $r0 = $outer_r;
                    $r1 = $inner_r;
                }
                else
                {
                    $r0 = SBV::CONF::fetch_size($hl->{r0},$radius);
                    $r1 = SBV::CONF::fetch_size($hl->{r1},$radius);
                }
                
                my $sta = cal_coord($data,$id1,$hl->{start},$zoom,$angle);
                my $end = cal_coord($data,$id1,$hl->{end},$zoom,$angle);
                ($sta,$end) = ($end,$sta) if ($reverse == 1);

                my $fill = $hl->{fill} || "#000";
                $fill = SBV::Colors::fetch_color($fill);
                my $stroke = $hl->{color} || "#000";
                $stroke = SBV::Colors::fetch_color($stroke);
                my $stroke_width = $hl->{stroke_width} || 0;
                my $style = "fill:$fill;stroke:$stroke;stroke-width:$stroke_width;";
                my $arrow = $hl->{arrow} || 0;
                $polar->fan($r0,$sta,$r1,$end,class=>"highlights",style=>$style,arrow=>$arrow);
            }
        }
        
        # draw label 
        if ($ideogram->{show_label} && $ideogram->{show})
        {
            my $label = $ideogram->{label_with_tag} ? $data->{$id1}->{label} : $id1;
            my $label_r = SBV::CONF::fetch_size($ideogram->{'label_radius'},$radius);
            my $theta = $ideogram->{label_center} ? ($angle + $angle2)/2 : $angle;
            my $label_w = $label_font->fetch_text_width($label);

            if ($ideogram->{label_parallel})
            {
                $label_r = $label_r == $radius ? $label_r - $label_h/2 : $radius < $radius ? $label_r - $label_h : $label_r;
                #$label_r -= $label_h if ($label_r < $radius);
                $polar->text($label_r,$theta,$label_w/2,$label,class=>"chr_label",parallel=>1);
            }
            else
            {
                $label_r = $label_r == $radius ? $label_r - $label_w/2 : $radius < $radius ? $label_r - $label_w : $label_r;
                #$label_r -= $label_w if ($label_r < $radius);
                $polar->text($label_r,$theta,$label_h/2,$label,class=>"chr_label");
            }
        }
        
        # draw tick
        my$ticks = $data->{$id1}->{ticks};
        if ($ticks && $ideogram->{show})
        {
            foreach my$tick (@$ticks)
            {
                my $tick_font = SBV::Font->new($tick->{tick_label_theme});
                my $tick_h = $tick_font->fetch_text_height;

                my $orientation = $tick->{orientation};
                my $offset = $tick->{offset};
                my $tick_thick = $tick->{thickness};
                my $tick_size = $tick->{size};
                my $spacing = $tick->{spacing};
                my $power = $tick->{label_power} || 1;
                my $label_multiplier = $tick->{label_multiplier};
                my $size = $tick->{size};
                my $unit_label = $tick->{unit_label} || "";

                if ($orientation eq "outer")
                {
                    my $r0 = $outer_r + $offset;
                    my $r1 = $r0 + $size;
                    my $tick_start = $tick->{show_true_ticks} ? $data->{$id1}->{sta} : 0;
                    my $tick_end = $tick->{show_true_ticks} ? $data->{$id1}->{end}  : $data->{$id1}->{size};
                    for (my$i = $tick_start; $i<$tick_end; $i+= $spacing)
                    {
                        my $tick_label = $power == 1 ? $i : $power ** $i;
                        $tick_label = int ($tick_label * $label_multiplier);
                        $tick_label .= $unit_label;
                        my $tick_theta = cal_coord($data,$id1,$i,$zoom,$angle);
                        $polar->line($r0,$tick_theta,$r1,$tick_theta,style=>"stroke-width:$tick_thick;stroke:#000");

                        if ($tick->{show_label} && $tick->{label_parallel})
                        {
                            my $tick_w = $tick_font->fetch_text_width($tick_label);
                            $polar->text($r1+$vspace,$tick_theta,$tick_w/2,$tick_label,
                                parallel=>1,theme=>$tick->{tick_label_theme});
                        }
                        elsif ($tick->{show_label} && ! $tick->{label_parallel})
                        {
                            my $tick_w = $tick_font->fetch_text_width($tick_label);
                            $polar->text($r1+$vspace,$tick_theta,$tick_h/2,$tick_label,
                                parallel=>0,theme=>$tick->{tick_label_theme});
                        }
                    }
                }
                elsif ($orientation eq "inner")
                {
                    my $r0 = $inner_r - $offset;
                    my $r1 = $r0 - $size;

                    my $tick_start = $tick->{show_true_ticks} ? $data->{$id1}->{sta} : 0;
                    my $tick_end = $tick->{show_true_ticks} ? $data->{$id1}->{end}  : $data->{$id1}->{size};
                    for (my$i = $tick_start; $i<$tick_end; $i+= $spacing)
                    {
                        my $tick_label = $power == 1 ? $i : $power ** $i;
                        $tick_label = int ($tick_label * $label_multiplier);
                        $tick_label .= $unit_label;
                        my $tick_theta = cal_coord($data,$id1,$i,$zoom,$angle);
                        $polar->line($r0,$tick_theta,$r1,$tick_theta,style=>"stroke-width:$tick_thick;stroke:#000");

                        if ($tick->{show_label})
                        {
                            my $tick_w = $tick_font->fetch_text_width($tick_label);
                            $polar->text($r1-$vspace-$tick_h,$tick_theta,$tick_w/2,$tick_label,
                                theme=>$tick->{tick_label_theme},parallel=>1);
                        }
                        elsif ($tick->{show_label} && ! $tick->{label_parallel})
                        {
                            my $tick_w = $tick_font->fetch_text_width($tick_label);
                            $polar->text($r1+$vspace,$tick_theta,$tick_h/2,$tick_label,
                                parallel=>0,theme=>$tick->{tick_label_theme});
                        }
                    }
                }
            }
        }
        
        $angle = $angle2 + $zoom * ideogram_spacing($id1,$id2,$leaf,$Gsize);
    }
    
    # draw total ticks for all chrs (connect all chrs together)
    # spacing of all chrs must be 0 (besides between last and first)
    if ($conf->{ticks}->{whole})
    {
        my $tick = $conf->{ticks}->{whole};
        my $tick_font = SBV::Font->new($tick->{tick_label_theme});
        my $tick_h = $tick_font->fetch_text_height;

        my $orientation = $tick->{orientation};
        my $offset = $tick->{offset};
        my $tick_thick = $tick->{thickness};
        my $tick_size = $tick->{size};
        my $spacing = $tick->{spacing};
        my $label_multiplier = $tick->{label_multiplier};
        my $size = $tick->{size};
        my $unit_label = $tick->{unit_label} || "";
        
        my $id1 = $chrorder[0];
        my $outer_r = $data->{$id1}->{outer_r};
        my $inner_r = $data->{$id1}->{inner_r};
        my $tick_start = 0;
        my $tick_end   = sum( [ map { $data->{$_}->{size} } @chrorder ] );
        
        if ($orientation eq "outer")
        {
            my $r0 = $outer_r + $offset;
            my $r1 = $r0 + $size;
            for (my$i = $tick_start; $i<$tick_end; $i+= $spacing)
            {
                my $tick_label = int ($i * $label_multiplier);
                $tick_label .= $unit_label;
                my $tick_theta = cal_coord($data,$id1,$i,$zoom,$angle);
                $polar->line($r0,$tick_theta,$r1,$tick_theta,style=>"stroke-width:$tick_thick;stroke:#000");

                if ($tick->{show_label} && $tick->{label_parallel})
                {
                    my $tick_w = $tick_font->fetch_text_width($tick_label);
                    $polar->text($r1+$vspace,$tick_theta,$tick_w/2,$tick_label,
                            parallel=>1,theme=>$tick->{tick_label_theme});
                }
                elsif ($tick->{show_label} && ! $tick->{label_parallel})
                {
                    my $tick_w = $tick_font->fetch_text_width($tick_label);
                    $polar->text($r1+$vspace,$tick_theta,$tick_h/2,$tick_label,
                            parallel=>0,theme=>$tick->{tick_label_theme});
                }
            }
        }
        elsif ($orientation eq "inner")
        {
            my $r0 = $inner_r - $offset;
            my $r1 = $r0 - $size;

            for (my$i = $tick_start; $i<$tick_end; $i+= $spacing)
            {
                my $tick_label = $i * $label_multiplier;
                $tick_label .= $unit_label;
                my $tick_theta = cal_coord($data,$id1,$i,$zoom,$angle);
                $polar->line($r0,$tick_theta,$r1,$tick_theta,style=>"stroke-width:$tick_thick;stroke:#000");

                if ($tick->{show_label})
                {
                    my $tick_w = $tick_font->fetch_text_width($tick_label);
                    $polar->text($r1-$vspace-$tick_h,$tick_theta,$tick_w/2,$tick_label,
                            theme=>$tick->{tick_label_theme},parallel=>1);
                }
                elsif ($tick->{show_label} && ! $tick->{label_parallel})
                {
                    my $tick_w = $tick_font->fetch_text_width($tick_label);
                    $polar->text($r1+$vspace,$tick_theta,$tick_h/2,$tick_label,
                            parallel=>0,theme=>$tick->{tick_label_theme});
                }
            }
        }
    }

    # draw plots
    my $plotsObj = $parent->group(class=>"plots");
    foreach my$plot(sort {$a->{z} <=> $b->{z}} @plots)
    {
        my $plotObj = $plotsObj->group(class=>"plot");
        $polar->parent($plotObj);

        foreach my$chr(keys %{$plot->{data}})
        {
            next unless defined $data->{$chr}->{display};
            _add_circular_plot($data,$plot,$chr,$zoom,$polar);
        }
    }
    
    # draw links
    my $linksObj = $parent->group(class=>"links");
    $polar->parent($linksObj);
    foreach my$link (@links)
    {
        my ($chr1,$sta1,$end1,$chr2,$sta2,$end2,$attrs) = @$link;
        my $r0 = SBV::CONF::fetch_size($attrs->{r0},$radius);
        my $r1 = SBV::CONF::fetch_size($attrs->{r1},$radius);

        my $Qangle1 = cal_coord($data,$chr1,$sta1,$zoom,$data->{$chr1}->{angle});
        my $Qangle2 = cal_coord($data,$chr1,$end1,$zoom,$data->{$chr1}->{angle});
        my $Rangle1 = cal_coord($data,$chr2,$sta2,$zoom,$data->{$chr2}->{angle});
        my $Rangle2 = cal_coord($data,$chr2,$end2,$zoom,$data->{$chr2}->{angle});
        
        if (abs($Qangle1-$Qangle2) < 0.1 && abs($Rangle1 - $Rangle2) < 0.1)
        {
            $polar->BCurve_line($r0,$Qangle1,$Qangle2,$r1,$Rangle1,$Rangle2,%$attrs);
        }
        else 
        {
            $polar->BCurve($r0,$Qangle1,$Qangle2,$r1,$Rangle1,$Rangle2,%$attrs);
        }
    }

}

sub ideogram_spacing
{
    my ($id1,$id2,$leaf,$Gsize) = @_;
    return 0 unless ($leaf);
    
    my $spacing = SBV::CONF::fetch_size($leaf->{default},$Gsize) || 0;
    
    if ($leaf->{pairwise}->{"$id1;$id2"} || $leaf->{pairwise}->{"$id2;$id1"})
    {
        my $tag = $leaf->{pairwise}->{"$id1;$id2"} ? "$id1;$id2" : "$id2;$id1";
        $spacing = SBV::CONF::fetch_size($leaf->{pairwise}->{"$tag"}->{spacing},$Gsize);
    }
    
    return $spacing;
}

# add plot to normal karyotype figure
sub _add_plot
{
    my ($data,$plot,$chr,$zoom,$ox,$parent)    = @_;

    my $type = $plot->{type};
    my %func = (
        scatter   => \&_add_scatter_plot,
        line      => \&_add_line_plot,
        histogram => \&_add_histogram_plot,
        heatmap   => \&_add_heatmap_plot,
        text      => \&_add_text_plot,
    );
    
    ERROR('err_plot_type') unless defined $func{$type};

    my $child = $parent->group(class=>"$chr\_plot");
    &{$func{$type}}($data,$plot,$chr,$zoom,$ox,$child);
}

sub _add_scatter_plot
{
    my ($data,$plot,$chr,$zoom,$ox,$parent) = @_;
    my $records = $plot->{data}->{$chr};
    
    # get the min and max value of the data
    my @vals = map { $$_[2] } @$records;
    my $min = defined $plot->{min} ? $plot->{min} : min(\@vals);
    my $max = defined $plot->{max} ? $plot->{max} : max(\@vals);
    my $tick = defined $plot->{tick} ? $plot->{tick} :  SBV::STAT::dividing($min,$max,-xtrue=>1);
    my $show_tick_label = $plot->{show_tick_label} || 0;
    my $show_tick_line = $plot->{show_tick_line} || 0;
    my $show_axis_bone = $plot->{show_axis_bone} || 0;
    my $tick_offset = $plot->{axis_offset} || 0;
    my $axis_ox = $ox + $tick_offset;

    # create the y axis for val
    my $y1 = cal_y_coord($data,$chr,$plot->{loc0});
    my $y2 = cal_y_coord($data,$chr,$plot->{loc1});
    my $len = abs ($y1 - $y2);
    my $orientation = $y1 > $y2 ? "down" : "up";
    my $angle = $y1 > $y2 ? -90 : 90;
    my $axis = SBV::STONE::AXIS->new(
        bone => $show_axis_bone,
        ox=>$axis_ox,oy=>$y1,length=>$len,
        tick=>$tick,
        angle=>$angle,
        start => 0,
        show_tick_label=>$show_tick_label,
        show_tick_line=>$show_tick_line,
        skip_first_tick => 0,
        skip_last_tick => 0,
        size=>8,
        side=>"left",
    );
    $axis->plot(parent=>$parent);
    add_background_and_axis($axis,$plot,$data->{$chr}->{width});

    foreach (@$records)
    {
        my ($sta,$end,$val,$attrs) = @$_;
        my $x = cal_coord($data,$chr,($sta+$end)/2,$zoom,$ox);
        next if ($val > $max || $val < $min);
        my $dis = $axis->fetch_dis($val);
        my $y = $y1 < $y2 ? $y1 + $dis : $y1 - $dis;
        my $radius = $attrs->{radius} || 2;
        my $shape = defined $attrs->{shape} ? $attrs->{shape} : 1;
        
        if ($shape == 1)
        {
            $attrs->{color} ||= "#000";
            $attrs->{fill} ||= "none";
            my $color = SBV::Colors::fetch_color($attrs->{color});
            my $fill = SBV::Colors::fetch_color($attrs->{fill});
            $parent->circle(cx=>$x,cy=>$y,r=>$radius,
                style=>"fill:$fill;stroke:$color;stroke-width:$attrs->{stroke_width}");
        }
        else 
        {
            my $symid = SBV::STONE::SYMBOL::new($shape,width=>$radius*2,height=>$radius*2,%$attrs);
            $parent->group(class=>"scatter")->use(x=>$x-$radius,y=>$y-$radius,
                width=>$radius*2,height=>$radius*2,'-href'=>"#$symid");
        }
    }
}

sub _add_line_plot
{
    my ($data,$plot,$chr,$zoom,$ox,$parent) = @_;
    my $records = $plot->{data}->{$chr};
    
    # get the min and max value of the data
    my @vals = map { $$_[2] } @$records;
    my $min = defined $plot->{min} ? $plot->{min} : min(\@vals);
    my $max = defined $plot->{max} ? $plot->{max} : max(\@vals);
    my $tick = SBV::STAT::dividing($min,$max,-xtrue=>1);
    
    my $show_tick_label = $plot->{show_tick_label} || 0;
    my $show_tick_line = $plot->{show_tick_line} || 0;

    # create the y axis for val
    my $y1 = cal_y_coord($data,$chr,$plot->{loc0});
    my $y2 = cal_y_coord($data,$chr,$plot->{loc1});
    my $len = abs ($y1 - $y2);
    my $orientation = $y1 > $y2 ? "down" : "up";
    my $angle = $y1 > $y2 ? -90 : 90;
    my $axis = SBV::STONE::AXIS->new(
        ox=>$ox,oy=>$y1,length=>$len,
        tick=>$tick,
        angle=>$angle,
        show_tick_label=>$show_tick_label,
        show_tick_line=>$show_tick_line,
        skip_first_tick => 0,
        skip_last_tick => 0,
        size=>8,
        side=>"left",
        #bgline=>$data->{$chr}->{width},
    );
    $axis->plot(parent=>$parent);
    add_background_and_axis($axis,$plot,$data->{$chr}->{width});

    my (@px,@py);
    foreach (sort {$a->[0] <=> $b->[0]} @$records)
    {
        my ($sta,$end,$val,$attrs) = @$_;
        my $x = cal_coord($data,$chr,($sta+$end)/2,$zoom,$ox);
        next if ($val > $max || $val < $min);
        my $dis = $axis->fetch_dis($val);
        my $y = $y1 < $y2 ? $y1 + $dis : $y1 - $dis;
        push @px , $x;
        push @py , $y;
    }
    
    # set the default color and stroke width
    my $color = defined $plot->{color} ? $plot->{color} : "000";
    $color = SBV::Colors::fetch_color($color);
    my $swidth = defined $plot->{stroke_width} ? $plot->{stroke_width} : 1;
    
    return if ($#px == -1);
    my $points = $parent->get_path(x=>\@px,y=>\@py,-type=>'polyline');
    $parent->polyline(%$points,fill=>'none',style=>"stroke:$color;stroke-width:$swidth");
}

sub _add_histogram_plot_back
{
    my ($data,$plot,$chr,$zoom,$ox,$parent) = @_;
    my $records = $plot->{data}->{$chr};
    
    # get the min and max value of the data
    my @vals = map { $$_[2] } @$records;
    my $min = defined $plot->{min} ? $plot->{min} : min(\@vals);
    my $max = defined $plot->{max} ? $plot->{max} : max(\@vals);
    my $tick = SBV::STAT::dividing($min,$max,-xtrue=>1);
    my $show_tick_label = $plot->{show_tick_label} || 0;
    my $show_tick_line = $plot->{show_tick_line} || 0;
    
    # create the y axis for val
    my $y1 = cal_y_coord($data,$chr,$plot->{loc0});
    my $y2 = cal_y_coord($data,$chr,$plot->{loc1});
    my $len = abs ($y1 - $y2);
    my $orientation = $y1 > $y2 ? "down" : "up";
    my $angle = $y1 > $y2 ? -90 : 90;
    
    my $axis = SBV::STONE::AXIS->new(
        ox=>$ox,oy=>$y1,length=>$len,
        tick=>$tick,
        angle=>$angle,
        show_tick_label=>$show_tick_label,
        show_tick_line=>$show_tick_line,
        start => 0,
        skip_first_tick => 0,
        skip_last_tick => 0,
        size=>8,
        side=>"left",
        #bgline=>$data->{$chr}->{width},
    );
    $axis->plot(parent=>$parent);
    
    add_background_and_axis($axis,$plot,$data->{$chr}->{width});

    foreach (@$records)
    {
        my ($sta,$end,$val,$attrs) = @$_;
        next if ($val > $max || $val < $min);
        my $x1 = cal_coord($data,$chr,$sta,$zoom,$ox);
        my $x2 = cal_coord($data,$chr,$end,$zoom,$ox);
        my $x = $x1 > $x2 ? $x2 : $x1;
        my $barw = abs($x1-$x2);

        my $dis = $axis->fetch_dis($val);
        my $y = $y1 < $y2 ? $y1 : $y1 - $dis;
        
        my $style = SBV::CONF::fetch_styles(%$attrs);
        $parent->rect(x=>$x,y=>$y,width=>$barw,height=>$dis,style=>$style);
    }
        
}

sub _add_histogram_plot
{
    my ($data,$plot,$chr,$zoom,$ox,$parent) = @_;
    my $records = $plot->{data}->{$chr};
    
    # get the min and max value of the data
    my @vals = map { $$_[2] } @$records;
    my $min = defined $plot->{min} ? $plot->{min} : min(\@vals);
    my $max = defined $plot->{max} ? $plot->{max} : max(\@vals);
    my $y1 = cal_y_coord($data,$chr,$plot->{loc0});
    my $y2 = cal_y_coord($data,$chr,$plot->{loc1});
    
    if ($max <= 0)
    {
        $min = abs($min);
        $max = abs($max);
        ($min,$max) = ($max,$min);
        @vals = map { abs($_) } @vals;
        ($y1,$y2) = ($y2,$y1);
    }
    elsif ($min <= 0 && $max >= 0)
    {
        # ($y1,$y2) = ($y2,$y1) if ($y1>$y2);
    }


    my $tick = SBV::STAT::dividing($min,$max,-xtrue=>1);
    my $show_tick_label = $plot->{show_tick_label} || 0;
    my $show_tick_line = $plot->{show_tick_line} || 0;
    
    # create the y axis for val
    my $len = abs ($y1 - $y2);
    my $orientation = $y1 > $y2 ? "up" : "down";
    my $angle = $y1 > $y2 ? -90 : 90;

    my $axis = SBV::STONE::AXIS->new(
        ox=>$ox,oy=>$y1,length=>$len,
        tick=>$tick,
        angle=>$angle,
        show_tick_label=>$show_tick_label,
        show_tick_line=>$show_tick_line,
        start => 0,
        skip_first_tick => 0,
        skip_last_tick => 0,
        size=>8,
        side=>"left",
        #bgline=>$data->{$chr}->{width},
    );
    $axis->plot(parent=>$parent);
    
    add_background_and_axis($axis,$plot,$data->{$chr}->{width});

    foreach (@$records)
    {
        my ($sta,$end,$val,$attrs) = @$_;
        next if ($val > $max || $val < $min);
        my $x1 = cal_coord($data,$chr,$sta,$zoom,$ox);
        my $x2 = cal_coord($data,$chr,$end,$zoom,$ox);
        my $x = $x1 > $x2 ? $x2 : $x1;
        my $barw = abs($x1-$x2) == 0 ? $plot->{width} : abs($x1-$x2);

        my $dis = $axis->fetch_dis($val);
        my $y = $y1 < $y2 ? $y1 : $y1 - $dis;

        if ($max > 0 && $min <0)
        {
            if ($val > 0)
            {
                $dis = $axis->fetch_dis($val) - $axis->fetch_dis(0);
                $y = $y2;
            }
            else 
            {
                $dis = $axis->fetch_dis(0) - $axis->fetch_dis($val);
                $y = $y1 - $axis->fetch_dis(0);
            }
        }
        
        my $style = SBV::CONF::fetch_styles(%$attrs);
        $parent->rect(x=>$x,y=>$y,width=>$barw,height=>$dis,style=>$style);
    }
}

sub _add_heatmap_plot
{
    my ($data,$plot,$chr,$zoom,$ox,$parent) = @_;
    my $records = $plot->{data}->{$chr};
    
    # get the min and max value of the data
    my @vals = map { $$_[2] } @$records;
    my $min = defined $plot->{min} ? $plot->{min} : min(\@vals);
    my $max = defined $plot->{max} ? $plot->{max} : max(\@vals);
    my $tick = SBV::STAT::dividing($min,$max,-xtrue=>1);
    
    #my @fills = SBV::CONF::fetch_val($plot,"fill");
    #@fills = map { SBV::Colors::fetch_color($_) } @fills;
    my @fills = SBV::Colors::fetch_brewer_color($plot->{fill});
    my $fill_unm = scalar @fills;

    foreach (@$records)
    {
        my ($sta,$end,$val,$attrs) = @$_;
        next if ($val > $max || $val < $min);

        # fetch x coord
        my $x1 = cal_coord($data,$chr,$sta,$zoom,$ox);
        my $x2 = cal_coord($data,$chr,$end,$zoom,$ox);
        my $x = $x1 > $x2 ? $x2 : $x1;
        my $barw = abs($x1-$x2);
    
        # fetch loc0 and loc1 coord
        my $y1 = cal_y_coord($data,$chr,$attrs->{loc0});
        my $y2 = cal_y_coord($data,$chr,$attrs->{loc1});
        my $len = abs ($y1 - $y2);
        my $y = $y1 > $y2 ? $y2 : $y1;
        
        # get gradient color
        my $ratio = ($val - $min) / ($max - $min);
        my $index = int ($#fills * $ratio);
        my $fill = $#fills == 1 ? SBV::Colors::fetch_gradient_color($ratio,@fills) : $fills[$index];
        my $styles = SBV::CONF::fetch_styles(%$attrs,fill=>$fill);

        $parent->rect(x=>$x,y=>$y,width=>$barw,height=>$len,style=>$styles);
    }
}

sub _add_text_plot
{
    my ($data,$plot,$chr,$zoom,$ox,$parent) = @_;
    my $records = $plot->{data}->{$chr};
    $plot->{snuggle_layer} = 1 unless $plot->{snuggle_layer};
    
    my $flagx1 = 0;
    my $flagx2 = 0;
    my $hi = $SBV::conf->{hspace};
    my $vi = $SBV::conf->{vspace};
    my $texty = 0;
    foreach (sort {$a->[0] <=> $b->[0]} @$records)
    {
        my ($sta,$end,$val,$attrs) = @$_;
        my $x = cal_coord($data,$chr,($sta+$end)/2,$zoom,$ox);
        
        my $lineStyle;
        $lineStyle .= "stroke-width:$attrs->{link_thickness};" if ($attrs->{link_thickness});
        
        if ($attrs->{link_color})
        {
            $attrs->{link_color} = SBV::Colors::fetch_color($attrs->{link_color});
            $lineStyle .= "stroke:$attrs->{link_color}";
        }

        if ($attrs->{ideogram_highlights})
        {
            my $x1 = cal_coord($data,$chr,$sta,$zoom,$ox);    
            my $x2 = cal_coord($data,$chr,$end,$zoom,$ox);
            ($x1,$x2) = ($x2,$x1) if ($x1 > $x2);
            my $y1 = $data->{$chr}->{upcoord};
            my $y2 = $data->{$chr}->{downcoord};
            
            my $linky1 = $y1 - 20;
            my $linky2 = $y1;

            my $hlg = $parent->group(class=>"chrloc",
                onmousemove=>"hlg_onmouseover(evt,$linky1,$linky2,\'$val\');",
                onmouseout=>"hlg_onmouseout(evt);");
            my $line = $hlg->line(x1=>$x,x2=>$x,y1=>$y1,y2=>$y2);
            $line->setAttribute(style=>$lineStyle) if ($lineStyle);
        }

        # fetch loc0 and loc1 coord
        my $y1 = cal_y_coord($data,$chr,$attrs->{loc0});
        my $y2 = cal_y_coord($data,$chr,$attrs->{loc1});
        $attrs->{theme} = "angle:-90" unless ($attrs->{theme});    

        my $font = SBV::Font->new($attrs->{theme});
        my $textH = $font->fetch_text_height;
        my $textW = $font->fetch_text_width($val);
        ($textW,$textH) = true_size($textW,$textH,$font->{'font-angle'});
        
        # draw text
        my $textx1 = $x - $textW/2;
        my $textx2 = $x + $textW/2;
        my $textx = $font->{'font-angle'} == -90 ? $textx2 : $textx1;
        my $overlap = 0;
        $overlap = 1 if ($textx1 >= $flagx1 && $textx1 <= $flagx2);
        $overlap = 1 if ($textx2 >= $flagx1 && $textx2 <= $flagx2);
        $overlap = 0 if ($plot->{allow_overlap});
        $flagx1 = $textx1 unless ($overlap);
        $flagx2 = $textx2 unless ($overlap);
        my $layer = 1;

        if ($attrs->{loc0} < 0)
        {
            my $linkLen = $y1 - $data->{$chr}->{downcoord} - $vi;
            $linkLen = $attrs->{link_length} if ($attrs->{link_length} && $attrs->{link_length} < $linkLen);
            
            if ($overlap == 0)
            {
                $layer = 1;
                # draw label
                $texty = $y1 + $textH;
                my $self_texty = $font->{'font-angle'} == 90 ? $texty - $textH : $texty;
                SBV::DRAW::theme_text($parent,$textx,$self_texty,$attrs->{'theme'},$val) if ($texty < $y2);

                # draw link
                if ($attrs->{show_links})
                {
                    my $links = $parent->line(x1=>$x,x2=>$x,y1=>$y1-$vi,y2=>$y1-$vi-$linkLen);
                    $links->setAttribute("style",$lineStyle) if ($lineStyle);
                }

                $texty += $vi;
            }
            else
            {
                $layer ++;
                next if ($layer > $plot->{snuggle_layer});
                
                # draw link
                if ($attrs->{show_links})
                {
                    if ($texty + $linkLen < $y2)
                    {
                        my $links = $parent->line(x1=>$x,x2=>$x,y1=>$texty,y2=>$texty + $linkLen);
                        $links->setAttribute("style",$lineStyle) if ($lineStyle);
                    }
                    $texty += $linkLen;
                }
                
                $texty += $vi;

                # draw label 
                $texty += $textH;
                my $self_texty = $font->{'font-angle'} == 90 ? $texty - $textH : $texty;
                SBV::DRAW::theme_text($parent,$textx,$self_texty,$attrs->{'theme'},$val) if ($texty < $y2);
                $texty += $vi;
            }
        }
        else
        {
            my $linkLen = $data->{$chr}->{upcoord} - $y1 - $vi;
            $linkLen = $attrs->{link_length} if ($attrs->{link_length} && $attrs->{link_length} < $linkLen);
            
            if (0 == $overlap)
            {
                $layer = 1;
                # draw label
                $texty = $y1;
                my $self_texty = $font->{'font-angle'} == 90 ? $texty - $textH : $texty;
                SBV::DRAW::theme_text($parent,$textx,$self_texty,$attrs->{'theme'},$val) if ($texty - $textH > $y2);

                # draw link
                if ($attrs->{show_links})
                {
                    my $links = $parent->line(x1=>$x,x2=>$x,y1=>$y1+$vi,y2=>$y1+$vi+$linkLen);
                    $links->setAttribute("style",$lineStyle) if ($lineStyle);
                }

                $texty -= $vi;
                $texty -= $textH;
            }
            else
            {
                $layer ++;
                next if ($layer > $plot->{snuggle_layer});
                # draw link
                if ($attrs->{show_links})
                {
                    if ($texty - $linkLen > $y2)
                    {
                        my $links = $parent->line(x1=>$x,x2=>$x,y1=>$texty,y2=>$texty - $linkLen);
                        $links->setAttribute("style",$lineStyle) if ($lineStyle);
                    }
                    $texty -= $linkLen;
                }
                
                $texty -= $vi;

                # draw label 
                my $self_texty = $font->{'font-angle'} == 90 ? $texty - $textH : $texty;
                SBV::DRAW::theme_text($parent,$textx,$self_texty,$attrs->{'theme'},$val) if ($texty - $textH > $y2);
                $texty -= $textH;
                $texty -= $vi;
            }
        }
    }
    
}

# add backgrounds and axes to plot (histogram,line,scatter)
sub add_background_and_axis
{
    my ($axis,$plot,$width) = @_;

    add_background($axis,$plot,$width) if ($plot->{backgrounds});
    add_axis($axis,$plot,$width) if ($plot->{axes});
} 

sub add_background
{
    my ($axis,$plot,$width) = @_;
    return unless $plot->{backgrounds}->{background};
    my @backgrounds = SBV::CONF::extract_conf($plot->{backgrounds},'background');
    my $parent = $axis->{parent};
    my $ox = $axis->{ox};
    
    foreach my$bg(@backgrounds)
    {
        my ($y0,$y1,$color);
        if (defined $bg->{y0} && $bg->{y0} > $axis->{min} && $bg->{y0} < $axis->{max})
        {
            $y0 = $bg->{y0};
        }
        else
        {
            $y0 = $axis->{min};
        }

        if (defined $bg->{y1} && $bg->{y1} > $axis->{min} && $bg->{y1} < $axis->{max})
        {
            $y1 = $bg->{y1};
        }
        else
        {
            $y1 = $axis->{max};
        }

        my $ycoord0 = fetch_yaxis_coord($axis,$y0);
        my $ycoord1 = fetch_yaxis_coord($axis,$y1);
        my $recty = $ycoord0 > $ycoord1 ? $ycoord1 : $ycoord0;
        $color = $bg->{color} || "vvlgrey";
        $color = SBV::Colors::fetch_color($color);
        $parent->rect(x=>$ox,y=>$recty,width=>$width,height=>abs($ycoord0-$ycoord1),style=>"stroke-width:0;fill:$color");
    }
}

sub add_axis
{
    my ($yaxis,$plot,$width) = @_;
    return unless $plot->{axes}->{axis};
    my @axes = SBV::CONF::extract_conf($plot->{axes},'axis');
    my $parent = $yaxis->{parent};
    my $ox = $yaxis->{ox};
    
    foreach my$axis(@axes)
    {
        my ($y0,$y1,$color);
        if (defined $axis->{y0} && $axis->{y0} > $yaxis->{min} && $axis->{y0} < $yaxis->{max})
        {
            $y0 = $axis->{y0};
        }
        else
        {
            $y0 = $yaxis->{min};
        }

        if (defined $axis->{y1} && $axis->{y1} > $yaxis->{min} && $axis->{y1} < $yaxis->{max})
        {
            $y1 = $axis->{y1};    
        }
        else
        {
            $y1 = $yaxis->{max};
        }
        
        my $ycoord0 = fetch_yaxis_coord($yaxis,$y0);
        my $ycoord1 = fetch_yaxis_coord($yaxis,$y1);
        $color = $axis->{color} || "lgrey";
        $color = SBV::Colors::fetch_color($color);
        my $swidth = $axis->{thickness} || 1;
        my $spacing = $axis->{spacing};
        $spacing = SBV::CONF::fetch_size($spacing,abs($ycoord1-$ycoord0));

        my $style = "stroke:$color;stroke-width:$swidth";
        my $i;
        if ($ycoord0 > $ycoord1)
        {
            for ($i=$ycoord0;$i>=$ycoord1;$i-=$spacing)
            {
                $parent->line(x1=>$ox,x2=>$ox+$width,y1=>$i,y2=>$i,style=>$style);
            }
        }
        else
        {
            for ($i=$ycoord0;$i<$ycoord1+$spacing;$i+=$spacing)
            {
                $parent->line(x1=>$ox,x2=>$ox+$width,y1=>$i,y2=>$i,style=>$style);
            }
        }
    }

}

sub fetch_yaxis_coord
{
    my ($axis,$val) = @_;
    my $angle = $axis->{angle};
    my $oy = $axis->{oy};
    my $dis = $axis->fetch_dis($val);

    my $coord = $angle == -90 ? $oy - $dis : $oy + $dis;
    return $coord;
}

# add plot figure to circular karyo map
sub _add_circular_plot
{
    my ($data,$plot,$chr,$zoom,$polar) = @_;
    my $type = $plot->{type};
    
    my %func = (
        scatter   => \&_add_circular_scatter_plot,
        line      => \&_add_circular_line_plot,
        histogram => \&_add_circular_histogram_plot,
        heatmap   => \&_add_circular_heatmap_plot,
        text      => \&_add_circular_text_plot,
    );
    
    ERROR('err_plot_type') unless defined $func{$type};
    &{$func{$type}}($data,$plot,$chr,$zoom,$polar);
}

sub _add_circular_scatter_plot
{
    my ($data,$plot,$chr,$zoom,$polar) = @_;
    my $records = $plot->{data}->{$chr};
    
    # get the min and max value of the data
    my @vals = map { $$_[2] } @$records;
    my $min = defined $plot->{min} ? $plot->{min} : min(\@vals);
    my $max = defined $plot->{max} ? $plot->{max} : max(\@vals);
    my $tick = SBV::STAT::dividing($min,$max,-xtrue=>1);

    my $r0 = SBV::CONF::fetch_size($plot->{r0},$data->{$chr}->{radius});
    my $r1 = SBV::CONF::fetch_size($plot->{r1},$data->{$chr}->{radius});
    my $len = abs($r1 - $r0);
    
    add_circular_background_and_axis($plot,$polar,$data,$chr);

    foreach (@$records)
    {
        my ($sta,$end,$val,$attrs) = @$_;
        next if ($val > $max || $val < $min);
        my $a = cal_coord($data,$chr,($sta+$end)/2,$zoom,$data->{$chr}->{angle});
        my $r = $r0 < $r1 ? $r0 + ($val-$min)*$len/($max-$min) : $r0 - ($val-$min)*$len/($max-$min); 
        my ($x,$y) = $polar->polar2pos($r,$a,"angle");
        my $radius = $attrs->{radius} || 2;

        if ($attrs->{clip}){
            my $style = SBV::CONF::attrs2style(%$attrs);
            $polar->{parent}->group(class=>"scatter")->circle(cx=>$x,cy=>$y,r=>$radius,
                style=>$style,
                "clip-path"=>"url(#ideogram_clip)",
                );
        }else{
            my $shape = defined $attrs->{shape} ? $attrs->{shape} : 1;
            my $symid = SBV::STONE::SYMBOL::new($shape,width=>$radius*2,height=>$radius*2,%$attrs);
            $polar->{parent}->group(class=>"scatter")->use(x=>$x-$radius,y=>$y-$radius,
                width=>$radius*2,height=>$radius*2,'-href'=>"#$symid");
        
        }

        if ($attrs->{show_val}){
            my $font = SBV::Font->new($attrs->{theme});
            my $label_w = $font->fetch_text_width($attrs->{val});
            $polar->text($r+$radius+2,$a,$label_w/2,$attrs->{val},parallel=>1);
        }
    }
}

sub _add_circular_line_plot
{
    my ($data,$plot,$chr,$zoom,$polar) = @_;
    my $records = $plot->{data}->{$chr};
    
    # get the min and max value of the data
    my @vals = map { $$_[2] } @$records;
    my $min = defined $plot->{min} ? $plot->{min} : min(\@vals);
    my $max = defined $plot->{max} ? $plot->{max} : max(\@vals);
    my $tick = SBV::STAT::dividing($min,$max,-xtrue=>1);

    my $r0 = SBV::CONF::fetch_size($plot->{r0},$data->{$chr}->{radius});
    my $r1 = SBV::CONF::fetch_size($plot->{r1},$data->{$chr}->{radius});
    my $len = abs($r1 - $r0);
    
    my (@px,@py);
    add_circular_background_and_axis($plot,$polar,$data,$chr);
    foreach (@$records)
    {
        my ($sta,$end,$val,$attrs) = @$_;
        next if ($val > $max || $val < $min);
        my $a = cal_coord($data,$chr,($sta+$end)/2,$zoom,$data->{$chr}->{angle});
        my $r = $r0 < $r1 ? $r0 + ($val-$min)*$len/($max-$min) : $r0 - ($val-$min)*$len/($max-$min); 
        my ($x,$y) = $polar->polar2pos($r,$a,"angle");
        push @px , $x;
        push @py , $y;
    }
    
    my $color = defined $plot->{color} ? $plot->{color} : "000";
    $color = SBV::Colors::fetch_color($color);
    my $swidth = defined $plot->{stroke_width} ? $plot->{stroke_width} : 1;

    return if ($#px == -1);
    my $points = $polar->{parent}->get_path(x=>\@px,y=>\@py,-type=>'polyline');
    $polar->{parent}->polyline(%$points,fill=>'none',style=>"stroke:$color;stroke-width:$swidth");
}

sub _add_circular_histogram_plot_back
{
    my ($data,$plot,$chr,$zoom,$polar) = @_;
    my $records = $plot->{data}->{$chr};
    
    # get the min and max value of the data
    my @vals = map { $$_[2] } @$records;
    my $min = defined $plot->{min} ? $plot->{min} : min(\@vals);
    my $max = defined $plot->{max} ? $plot->{max} : max(\@vals);
    my $tick = SBV::STAT::dividing($min,$max,-xtrue=>1);

    my $r0 = SBV::CONF::fetch_size($plot->{r0},$data->{$chr}->{radius});
    my $r1 = SBV::CONF::fetch_size($plot->{r1},$data->{$chr}->{radius});
    my $len = abs($r1 - $r0);
    
    add_circular_background_and_axis($plot,$polar,$data,$chr);
    foreach (@$records)
    {
        my ($sta,$end,$val,$attrs) = @$_;
        next if ($val > $max || $val < $min);
        my $a1 = cal_coord($data,$chr,$sta,$zoom,$data->{$chr}->{angle});
        my $a2 = cal_coord($data,$chr,$end,$zoom,$data->{$chr}->{angle});
        my $style = SBV::CONF::fetch_styles(%$attrs);
        
        if ($r0 < $r1)
        {
            my $r = $r0 + ($val-$min)*$len/($max-$min); 
            $polar->fan($r0,$a1,$r,$a2,style=>$style);
        }
        else
        {
            my $r = $r0 - ($val-$min)*$len/($max-$min);
            $polar->fan($r0,$a1,$r,$a2,style=>$style);
        }
    }
}

sub _add_circular_histogram_plot
{
    my ($data,$plot,$chr,$zoom,$polar) = @_;
    my $records = $plot->{data}->{$chr};
    
    # get the min and max value of the data
    my @vals = map { $$_[2] } @$records;
    my $min = defined $plot->{min} ? $plot->{min} : min(\@vals);
    my $max = defined $plot->{max} ? $plot->{max} : max(\@vals);

    my $r0 = SBV::CONF::fetch_size($plot->{r0},$data->{$chr}->{radius});
    my $r1 = SBV::CONF::fetch_size($plot->{r1},$data->{$chr}->{radius});
    
    if ($max<= 0)
    {
        @vals = map { abs($_) } @vals;
        ($r0,$r1) = ($r1,$r0);
        $min = abs($min);
        $max = abs($max);
        ($min,$max) = ($max,$min);
    }
    elsif ($max >=0 && $min <= 0)
    {
        ($r0,$r1) = ($r1,$r0) if ($r0 > $r1);
    }

    my $tick = SBV::STAT::dividing($min,$max,-xtrue=>1);
    my $len = abs($r1 - $r0);
    
    add_circular_background_and_axis($plot,$polar,$data,$chr);
    foreach (@$records)
    {
        my ($sta,$end,$val,$attrs) = @$_;
        next if ($val > $max || $val < $min);
        my $a1 = cal_coord($data,$chr,$sta,$zoom,$data->{$chr}->{angle});
        my $a2 = cal_coord($data,$chr,$end,$zoom,$data->{$chr}->{angle});
        my $style = SBV::CONF::fetch_styles(%$attrs);

        if ($max >= 0 && $min <= 0)
        {
            my $r_mid = $r1 - ($max - 0)*$len/($max-$min);
            my $r = $r_mid + $val*$len/($max-$min);
            $polar->fan($r_mid,$a1,$r,$a2,style=>$style);
        }
        else 
        {
            if ($r0 < $r1)
            {
                my $r = $r0 + ($val-$min)*$len/($max-$min); 
                $polar->fan($r0,$a1,$r,$a2,style=>$style);
            }
            else
            {
                my $r = $r0 - ($val-$min)*$len/($max-$min);
                $polar->fan($r0,$a1,$r,$a2,style=>$style);
            }
        }
    }
}

sub _add_circular_heatmap_plot
{
    my ($data,$plot,$chr,$zoom,$polar) = @_;
    my $records = $plot->{data}->{$chr};
    
    # get the min and max value of the data
    my @vals = map { $$_[2] } @$records;
    my $min = defined $plot->{min} ? $plot->{min} : min(\@vals);
    my $max = defined $plot->{max} ? $plot->{max} : max(\@vals);
    my $tick = SBV::STAT::dividing($min,$max,-xtrue=>1);

    my $r0 = SBV::CONF::fetch_size($plot->{r0},$data->{$chr}->{radius});
    my $r1 = SBV::CONF::fetch_size($plot->{r1},$data->{$chr}->{radius});
    my $len = abs($r1 - $r0);
    
    #my @fills = SBV::CONF::fetch_val($plot,"fill");
    #@fills = map { SBV::Colors::fetch_color($_) } @fills;
    my @fills = SBV::Colors::fetch_brewer_color($plot->{fill});
    my $fill_unm = scalar @fills;
    
    my $color = $plot->{color} || "000";
    $color = SBV::Colors::fetch_color($color);
    my $swidth = $plot->{stroke_width} || 1;
    
    foreach ( @$records)
    {
        my ($sta,$end,$val,$attrs) = @$_;
        next if ($val > $max || $val < $min);
        my $a1 = cal_coord($data,$chr,$sta,$zoom,$data->{$chr}->{angle});
        my $a2 = cal_coord($data,$chr,$end,$zoom,$data->{$chr}->{angle});
        
        # get gradient color
        my $ratio = ($val - $min) / ($max - $min);
        my $index = int ($#fills * $ratio);
        my $fill = ( $#fills == 2 || $#fills == 1 ) ? SBV::Colors::fetch_gradient_color($ratio,@fills) : $fills[$index];
        my $style = "stroke:$fill;stroke-width:$swidth;fill:$fill";
        $polar->fan($r0,$a1,$r1,$a2,style=>$style);
    }
}

sub _add_circular_text_plot
{
    my ($data,$plot,$chr,$zoom,$polar) = @_;
    my $records = $plot->{data}->{$chr};
    $plot->{snuggle_layer} = 1 unless $plot->{snuggle_layer};

    my $flaga1 = 0;
    my $flaga2 = 0;
    my $hi = $SBV::conf->{hspace};
    my $vi = $SBV::conf->{vspace};
    my $textr = 0;

    foreach (sort {$a->[0] <=> $b->[0]} @$records)
    {
        my ($sta,$end,$val,$attrs) = @$_;
        my $a = cal_coord($data,$chr,($sta+$end)/2,$zoom,$data->{$chr}->{angle});
        my $lineStyle;
        $lineStyle .= "stroke-width:$attrs->{link_thickness};" if ($attrs->{link_thickness});
        if ($attrs->{link_color})
        {
            $attrs->{link_color} = SBV::Colors::fetch_color($attrs->{link_color});
            $lineStyle .= "stroke:$attrs->{link_color}";
        }
        
        if ($attrs->{ideogram_highlights})
        {
            my $a1 = cal_coord($data,$chr,$sta,$zoom,$data->{$chr}->{angle});
            my $a2 = cal_coord($data,$chr,$end,$zoom,$data->{$chr}->{angle});
            ($a1,$a2) = ($a2,$a1) if ($a1>$a2);
            
            my $r1 = $data->{$chr}->{outer_r};
            my $r2 = $data->{$chr}->{inner_r};

            $polar->line($r1,$a,$r2,$a,style=>$lineStyle);
        }
        
        # fetch r0 and r1 coord
        my $r0 = SBV::CONF::fetch_size($plot->{r0},$data->{$chr}->{radius});
        my $r1 = SBV::CONF::fetch_size($plot->{r1},$data->{$chr}->{radius});
        $textr = $r0 if ($textr == 0);

        my $font = SBV::Font->new($attrs->{theme});
        my $textH = $font->fetch_text_height;
        my $textW = $font->fetch_text_width($val);
        
        my $parallel = $attrs->{label_parallel} // 0;
        my $trans = $parallel ? $textW/2 : $textH/2;

        # draw text
        my $texta1 = $a - 360*atan($textW/2/$textr)/$TWOPI;
        my $texta2 = $a + 360*atan($textW/2/$textr)/$TWOPI;
        my $texta = $a;
        my $overlap = 0;
        $overlap = 1 if ($texta1 >= $flaga1 && $texta1 <= $flaga2);
        $overlap = 1 if ($texta2 >= $flaga1 && $texta2 <= $flaga2);
        $overlap = 0 if ($plot->{allow_overlap});
        $flaga1 = $texta1 unless ($overlap);
        $flaga2 = $texta2 unless ($overlap);
        my $layer = 1;
            
        if ($r0 <= $data->{$chr}->{inner_r})
        {
            my $linkLen = $data->{$chr}->{inner_r} - $r0 - $vi;
            $linkLen = $attrs->{link_length} if ($attrs->{link_length} && $attrs->{link_length} < $linkLen);
            
            if ($overlap == 0)
            {
                $layer = 1;
                # draw label
                $textr = $r0 - $textH;
                $polar->text($textr,$texta,$trans,$val,parallel=>$parallel,theme=>$attrs->{theme});

                # draw link
                if ($attrs->{show_links})
                {
                    $polar->line($r0+$vi+$linkLen,$a,$r0+$vi,$a,style=>$lineStyle);
                }

                $textr -= $vi;
            }
            else
            {
                $layer ++;
                next if ($layer > $plot->{snuggle_layer});
                
                # draw link
                if ($attrs->{show_links})
                {
                    if ($attrs->{show_links})
                    {
                        if ($textr - $linkLen > $r1)
                        {
                            $polar->line($textr,$a,$textr-$linkLen,$a,style=>$lineStyle);
                        }
                        $textr -= $linkLen;
                    }
                }
                
                $textr -= $vi;
                $textr -= $textH;

                $polar->text($textr,$texta,$trans,$val,parallel=>$parallel,theme=>$attrs->{theme}) if ($textr > $r1);
                $textr -= $vi;
            }
        }
        elsif ($r0 >= $data->{$chr}->{outer_r})
        {
            my $linkLen = $r0 - $data->{$chr}->{outer_r} - $vi;
            $linkLen = $attrs->{link_length} if ($attrs->{link_length} && $attrs->{link_length} < $linkLen);

            if (0 == $overlap)
            {
                $layer = 1;

                # draw label
                $textr = $r0;
                $polar->text($textr,$texta,$trans,$val,parallel=>$parallel,theme=>$attrs->{theme});

                # draw link 
                if ($attrs->{show_links})
                {
                    $polar->line($r0-$vi,$a,$r0-$vi-$linkLen,$a,style=>$lineStyle);
                }

                $textr += $vi;
                $textr += $textH;
            }
            else
            {
                $layer ++;
                next if ($layer > $plot->{snuggle_layer});

                # draw link
                if ($attrs->{show_links})
                {
                    if ($textr + $linkLen < $r1)
                    {
                        $polar->line($textr,$a,$textr+$linkLen,$a,style=>$lineStyle);
                    }
                    $textr += $linkLen;
                }
                
                $textr += $vi;
                # draw label 
                $polar->text($textr,$texta,$trans,$val,parallel=>$parallel,theme=>$attrs->{theme}) if ($textr + $textH < $r1);

                $textr += $textH;
                $textr += $vi;
            }
        }

    }
}

sub add_circular_background_and_axis
{
    my ($plot,$polar,$data,$chr) = @_;

    add_circular_background($plot,$polar,$data,$chr) if ($plot->{backgrounds});
    add_circular_axis($plot,$polar,$data,$chr) if ($plot->{axes});
}

sub add_circular_background
{
    my ($plot,$polar,$data,$chr) = @_;
    return unless $plot->{backgrounds}->{background};
    my @backgrounds = SBV::CONF::extract_conf($plot->{backgrounds},'background');
    my $parent = $polar->{parent};
        
    my $min = SBV::CONF::fetch_size($plot->{r0},$data->{$chr}->{radius});
    my $max = SBV::CONF::fetch_size($plot->{r1},$data->{$chr}->{radius});
    ($min,$max) = ($max,$min) if ($min > $max);
    my $len = $max - $min;

    foreach my$bg(@backgrounds)
    {
        my $temp_y0 = $min + SBV::CONF::fetch_size($bg->{y0},$len) if (defined $bg->{y0});
        my $temp_y1 = $min + SBV::CONF::fetch_size($bg->{y1},$len) if (defined $bg->{y1});
        my ($y0,$y1,$color);
        if (defined $bg->{y0} && $temp_y0 > $min && $temp_y0 < $max)
        {
            $y0 = $temp_y0;
        }
        else
        {
            $y0 = $min;
        }

        if (defined $bg->{y1} && $temp_y1 > $min && $temp_y1 < $max)
        {
            $y1 = $temp_y1;    
        }
        else
        {
            $y1 = $max;    
        }
        
        $color = $bg->{color} || "vvlgrey";
        $color = SBV::Colors::fetch_color($color);

        $polar->fan($y0,$data->{$chr}->{angle},$y1,$data->{$chr}->{angle2},style=>"stroke-width:0;fill:$color");
    }
}

sub add_circular_axis
{
    my ($plot,$polar,$data,$chr) = @_;
    return unless $plot->{axes}->{axis};
    my @axes = SBV::CONF::extract_conf($plot->{axes},'axis');    
    
    my $min = SBV::CONF::fetch_size($plot->{r0},$data->{$chr}->{radius});
    my $max = SBV::CONF::fetch_size($plot->{r1},$data->{$chr}->{radius});
    ($min,$max) = ($max,$min) if ($min > $max);
    my $len = abs($max - $min);
    
    foreach my$axis(@axes)
    {
        my $temp_y0 = $min + SBV::CONF::fetch_size($axis->{y0},$len) if (defined $axis->{y0});
        my $temp_y1 = $min + SBV::CONF::fetch_size($axis->{y1},$len) if (defined $axis->{y1});
        my ($y0,$y1,$color);
        if (defined $axis->{y0} && $temp_y0 > $min && $temp_y0 < $max)
        {
            $y0 = $temp_y0;
        }
        else
        {
            $y0 = $min;
        }

        if (defined $axis->{y1} && $temp_y1 > $min && $temp_y1 < $max)
        {
            $y1 = $temp_y1;    
        }
        else
        {
            $y1 = $max;    
        }
        
        $color = $axis->{color} || "lgrey";
        $color = SBV::Colors::fetch_color($color);
        my $swidth = $axis->{thickness} || 1;        
        my $spacing = $axis->{spacing};
        $spacing = SBV::CONF::fetch_size($spacing,$len);

        my $style = "stroke:$color;stroke-width:$swidth;fill:none";
        my $i;
        
        if ($y0 > $y1)
        {
            for ($i=$y0;$i>=$y1;$i-=$spacing)
            {
                $polar->pline($i,$data->{$chr}->{angle},$data->{$chr}->{angle2},style=>$style);    
            }
        }
        else
        {
            for ($i=$y0;$i<=$y1;$i+=$spacing)
            {
                $polar->pline($i,$data->{$chr}->{angle},$data->{$chr}->{angle2},style=>$style);
            }
        }
    }
}

#-------------------------------------------------------------------------------
# parse the ideogram conf to set the ideogram content
#-------------------------------------------------------------------------------
sub parse_ideogram
{
    my ($data,$conf) = @_;
    
    if ($conf->{show_chromosomes_default})
    {
        foreach my$chr(keys %$data)
        {
            $data->{$chr}->{display} = 1;
        }
    }

    if ($conf->{chromosomes})
    {
        my @records = split /;/ , $conf->{chromosomes};
        foreach my$record(@records)
        {
            my ($display,$chr) = $record =~ /([!-]?)(.+?)$/;
            $display = $display ? 0 : 1;
            $data->{$chr}->{display} = $display;
            delete $data->{$chr} unless ($display);
        }
    }

    if ($conf->{chromosomes_reverse})
    {
        my @chrs = split /;/ , $conf->{chromosomes_reverse};
        foreach my$chr(@chrs) { $data->{$chr}->{reverse} = 1 }
    }

    if ($conf->{chromosomes_break})
    {
        my @records = split /;/ , $conf->{chromosomes_break};
        foreach my$record(@records)
        {
            my ($chr,$region) = $record =~ /-([^:]+):(.+)/;    
            push @{ $data->{$chr}->{breaks} } , $region;
        }
    }

    return $data;
}

# parse the ideogram order from parameter or file
sub fetch_chromosomes_order
{
    my ($data,$conf) = @_;
    
    my @chrorder = sort { $data->{$a}->{display_order} <=> $data->{$b}->{display_order} } keys %$data;

    my @order;
    if ($conf->{chromosomes_order})
    {
        @order  = split /;/ , $conf->{chromosomes_order};
    }
    elsif ($conf->{chromosomes_order_file})
    {
        my $file = check_path($conf->{chromosomes_order_file});
        open FH,$file or die "can't open file $file $!";
        @order = <FH>;
        chomp @order;
        close FH;
    }
    
    if (@order)
    {
        my $fst = shift @order;
        my $index = aindex(\@chrorder,$fst);
        @chrorder = map { if (-1 == aindex(\@order,$_)){$_}else{undef} } @chrorder;
        splice(@chrorder,$index+1,0,@order);
    }
    
    @chrorder = grep {defined $_ && $data->{$_}->{display}} @chrorder;
    return @chrorder;
}

# fetch the chr label size
sub fetch_chr_label_size
{
    my ($data,$order,$conf) = @_;
    
    return (0,0) unless ($conf->{show_label});

    my $font = SBV::Font->fetch_font('chr_label');
    my $chr_label_h = $font->fetch_text_height;
    my @labels = $conf->{label_with_tag} ? map { $data->{$_}->{label} } @$order : @$order;
    my $chr_label_w = $font->fetch_max_text_width(\@labels);
    
    if ($conf->{label_parallel})
    {
        return ($chr_label_w,$chr_label_h);
    }
    else
    {
        return ($chr_label_h,$chr_label_w);    
    }
}

# parse ticks conf
sub parse_ticks
{
    my ($data,$conf) = @_;
    return $data unless ($conf->{ticks});
    
    my $ticks = SBV::CONF::fetch_first_conf('ticks',$conf);
    return $data unless ($ticks->{tick});

    if (ref $ticks->{tick} eq "ARRAY")
    {
        foreach my$tick (@{$ticks->{tick}})
        {
            $data = _parse_tick($data,$ticks,$tick);    
        }
    }
    elsif (ref $ticks->{tick} eq "HASH")
    {
        $data = _parse_tick($data,$ticks,$ticks->{tick});    
    }

    return $data;
}

sub _parse_tick
{
    my ($data,$conf,$subconf) = @_;

    # inherit attr from ticks
    foreach my$key (keys %$conf)
    {
        next if ($key eq "tick");
        $subconf->{$key} = $conf->{$key} unless $subconf->{$key};
    }
    
    my $show = {};
    if ($subconf->{chromosomes})
    {
        my @chrs = split /;/ , $subconf->{chromosomes};
        foreach my$chr (@chrs)
        {
            if ($chr =~ /^-/)    
            {
                $show->{$chr} = 0;
            }
            else
            {
                $show->{$chr} = 1;
            }
        }
    }
    else
    {
        $show->{$_} = 1 foreach (keys %$data);    
    }

    foreach my$chr(keys %$data)
    {
        push @{$data->{$chr}->{ticks}} , $subconf if ($show->{$chr});    
    }
    
    return $data;
}

# parse highlights 
sub parse_highlights
{
    my ($data,$conf) = @_;
    return $data unless ($conf->{highlights});
    $conf = SBV::CONF::fetch_first_conf("highlights",$conf);
    return $data unless ($conf->{highlight});
    
    if (ref $conf->{highlight} eq "ARRAY")
    {
        foreach my$subconf (@{$conf->{highlight}})
        {
            $data = _parse_highlight($data,$conf,$subconf);
        }
    }
    elsif (ref $conf->{highlight} eq "HASH")
    {
        $data = _parse_highlight($data,$conf,$conf->{highlight});
    }
    
    return $data;
}

sub _parse_highlight
{
    my ($data,$conf,$subconf) = @_;

    return $data unless $subconf->{file};
    my $file = check_path($subconf->{file});

    # inherit attr from ticks
    foreach my$key (keys %$conf)
    {
        next if ($key eq "tick");
        $subconf->{$key} = $conf->{$key} unless $subconf->{$key};
    }
    
    # read highlights file
    open FH,$file or die;
    while(<FH>)
    {
        chomp;
        next if (/^#/);
        next if ($_ eq "");
        my ($chr,$sta,$end,$attrs) = split;
        next unless ($data->{$chr});
        
        my $attrs_hash = {};
        foreach my$name(keys %$subconf)
        {
            $attrs_hash->{$name} = $subconf->{$name} unless ($name eq "file");
        }

        ($sta,$end) = ($end,$sta) if ($sta > $end);
        $attrs_hash->{start} = $sta;
        $attrs_hash->{end} = $end;
        
        if ($attrs)
        {
            my @attrs = split /;/ , $attrs;
            foreach my$attr(@attrs)
            {
                my ($name,$val) = split /=/ , $attr;
                $val = SBV::Colors::fetch_color($val) if ($name eq "color" || $name eq "fill");
                $attrs_hash->{$name} = $val;
            }
        }
        
        push @{$data->{$chr}->{highlights}} , $attrs_hash; 
    }
    close FH;
    return $data;
}

# parse links
sub parse_links
{
    my $conf = shift;
    return () unless $conf->{links};
    $conf = SBV::CONF::fetch_first_conf("links",$conf);
    return () unless $conf->{link};

    my @links = ();
    if (ref $conf->{link} eq "ARRAY")
    {
        foreach my$subconf(@{$conf->{link}})
        {
            _parse_link(\@links,$conf,$subconf);
        }
    }
    elsif (ref $conf->{link} eq "HASH")
    {
        _parse_link(\@links,$conf,$conf->{link});
    }

    return @links;
}

sub _parse_link
{
    my ($links,$conf,$subconf) = @_;

    return unless $subconf->{file};
    my $file = check_path($subconf->{file});
    
    # inherit attr from ticks
    foreach my$key (keys %$conf)
    {
        next if ($key eq "link");
        $conf->{$key} = SBV::Colors::fetch_color($conf->{$key}) if ($key eq "color" || $key eq "fill");
        $subconf->{$key} = $conf->{$key} unless $subconf->{$key};
    }

    # read links file
    open FH,$file or die "can't open file $file $!";
    while(<FH>)
    {
        chomp;
        next if (/^#/);
        next if ($_ eq "");
        my ($chr1,$sta1,$end1,$chr2,$sta2,$end2,$attrs) = split;
        
        my $attrs_hash = {};
        foreach my$name(keys %$subconf)
        {
            $attrs_hash->{$name} = $subconf->{$name} unless ($name eq "file");
        }
        
        if ($attrs)
        {
            my @attrs = split /;/ , $attrs;
            foreach my$attr(@attrs)
            {
                my ($name,$val) = split /=/ , $attr;
                $val = SBV::Colors::fetch_color($val) if ($name eq "color" || $name eq "fill");
                $attrs_hash->{$name} = $val;
            }
        }
        
        push @$links , [$chr1,$sta1,$end1,$chr2,$sta2,$end2,$attrs_hash];
    }
    close FH;
}


#-------------------------------------------------------------------------------
#  parse the plots
#-------------------------------------------------------------------------------
sub parse_plots
{
    my ($conf) = @_;
    return () unless $conf->{plots};
    $conf = $conf->{plots};
    return () unless $conf->{plot};
    
    my @plots = ();
    if (ref $conf->{plot} eq "ARRAY")
    {
        foreach my$subconf(@{$conf->{plot}})
        {
            _parse_plot(\@plots,$conf,$subconf);
        }
    }
    elsif (ref $conf->{plot} eq "HASH")
    {
        _parse_plot(\@plots,$conf,$conf->{plot});
    }

    return @plots;
}

sub _parse_plot
{
    my ($plots,$conf,$subconf) = @_;
    
    return unless $subconf->{file};
    my $file = check_path($subconf->{file});
    
    # inherit attr from ticks
    foreach my$key (keys %$conf)
    {
        next if ($key eq "plot");
        $subconf->{$key} = $conf->{$key} unless $subconf->{$key};
    }
    
    ERROR('no_plot_type') unless $subconf->{'type'};
    
    # set the plot opts
    my $record = {};
    foreach my$name (keys %$subconf)
    {
        $record->{$name} = $subconf->{$name} unless ($name eq "file");
    }
    $record->{z} = 0 unless defined $record->{z};

    # read plot file
    open FH,$file or die "can't open file $file $!";
    while(<FH>)
    {
        chomp;
        next if (/^#/);
        next if ($_ eq "");

        my ($chr,$sta,$end,$val,$attrs) = split /\t/;

        my $attrs_hash = {};
        foreach my$name(keys %$subconf)
        {
            $attrs_hash->{$name} = $subconf->{$name} unless ($name eq "file");
        }
        
        if ($attrs)
        {
            my @attrs = split /;/ , $attrs;
            foreach my$attr(@attrs)
            {
                my ($name,$val) = split /=/ , $attr;
                $attrs_hash->{$name} = $val;
            }
        }

        push @{$record->{data}->{$chr}} , [$sta,$end,$val,$attrs_hash];
    }
    close FH;

    push @$plots , $record;
}

#-------------------------------------------------------------------------------
# calculate the coord
sub cal_coord
{
    my ($data,$chr,$pos,$zoom,$x) = @_;
    my $width = $data->{$chr}->{size} * $zoom;
    
    $pos = ($pos - $data->{$chr}->{sta} + 1) * $zoom;
    my $reverse = $data->{$chr}->{reverse};
    
    my $coord = 0 == $reverse ? $x + $pos : $x + $width - $pos;
    return nearest 0.01 , $coord;
}

sub cal_y_coord
{
    my ($data,$chr,$loc) = @_;
    
    if ($loc < 0)
    {
        return $data->{$chr}->{downcoord} - $loc;
    }
    else
    {
        return $data->{$chr}->{upcoord} - $loc;
    }
}

# calculate two position distance
sub cal_dis
{
    my ($pos1,$pos2,$zoom) = @_;
    return nearest 0.01 , $zoom * abs($pos2 - $pos1);
}
