package SBV::IMAGE::TREE;
#------------------------------------------------+
#    [APM] This moudle is generated by amp.pl    |
#    [APM] Created time: 2013-09-05 10:38:31     |
#------------------------------------------------+
=pod

=head1 Name

SBV::IMAGE::TREE

=head1 Synopsis

This module is not meant to be used directly

=head1 Feedback

Author: Peng Ai
Email:  aipeng0520@163.com

=head1 Version

Version history

=head2 v1.0

Date: 2013-09-05 10:38:31

=cut

use strict;
use warnings;
require Exporter;

use Bio::TreeIO;
use FindBin;
use Math::Round;

use lib "$FindBin::RealBin";
use lib "$FindBin::RealBin/lib";
use lib "$FindBin::RealBin/..";
use lib "$FindBin::RealBin/../lib";

use SBV::DEBUG;
use SBV::STAT;
use SBV::Constants;

sub new 
{
	my ($class,$file,$conf) = @_;
	my $treev = {};
	
	# load tree file 
	my $tree = _load_tree($file,$conf);
	my $id_trans = _load_ids($tree);
	$treev->{tree} = $tree;
	$treev->{conf} = $conf;
	$treev->{id_trans} = $id_trans;
	$conf->{align} = 1 if (! defined $conf->{align});

	bless $treev , $class;
	return $treev;
}

# load the tree file and set the outgroup
# if the outgroup is not exists witll use the default outgroup
sub _load_tree
{
	my ($file,$conf) = @_;
	my $format = $conf->{format};
	
	# check the tree file, and turn the scientific nonation to normal float number
	check_tree_file($file);

	my $treeio = Bio::TreeIO->new('-format'=>$format,-file=>$file);
	my $tree = $treeio->next_tree;
	my @leaves = $tree->get_leaf_nodes;

	if ($conf->{'outgroup'} && $conf->{'outgroup'} ne $leaves[0]->id)
	{
		foreach my$leaf(@leaves)
		{
			# re define the outgroup and re build the tree
			if ($leaf->id eq $conf->{'outgroup'})
			{
				return reroot_tree($tree,$leaf);
			}
		}

		WARN('the outgroup name is not exists in the tree file!',$conf->{'outgroup'});
	}
	
	return $tree;
}

# load the id and internal id
sub _load_ids
{
	my $tree = shift;
	my @leaves = $tree->get_leaf_nodes;
    my $leaves_num = scalar @leaves;
    timeLOG("sum read [$leaves_num] leaf nodes!");

	my $trans = {};

	foreach my$leaf (@leaves)
	{
		$trans->{$leaf->id} = $leaf;
	}

	return $trans;
}

# draw tree graph
sub plot
{
	my ($self,$parent) = @_;
	my $tree = $self->{tree};
	my $conf = $self->{conf};
	
	$conf->{model} = "normal" if (! exists $conf->{model});
	SBV::DRAW::background($conf,$parent);
	
	my $scale_group = $parent->group(id=>"tree$SBV::idnum");
	$SBV::idnum ++;
	
	my $group = $parent->group(id=>"tree$SBV::idnum");
	$SBV::idnum ++;

	my %func = ("normal"=>\&normal_tree,circular=>\&circular_tree,
		"inverted_circular"=>\&inverted_circular_tree,unrooted=>\&unrooted_tree);
    
	&{$func{$conf->{model}}}($self,$tree,$conf,$scale_group,$group);
	
	# add legend
	if ($conf->{legend})
	{
		my $legend = SBV::STONE::LEGEND->new(conf=>$conf->{legend});
		$legend->location($conf);
		$legend->draw($parent);
	}
}

#-------------------------------------
# draw the normal tree 
#-------------------------------------
sub normal_tree
{
	my ($self,$tree,$conf,$scale_group,$group) = @_;
	my %par;
	
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};
	
	# load color and leaf labels definition files
	my $defs = _load_defs($conf,$self->{id_trans});
	my @datasets = _load_datasets($conf,$self->{id_trans});
	my $axis_flag = 0;
	foreach my$dataset(@datasets)
	{
		if ($dataset->{type} eq "bar" || $dataset->{type} eq "boxplot" || $dataset->{type} eq "modify")
		{
			$axis_flag = 1;
			last;
		}
	}

	# set the width and height for the tree figure
	my $treeFW = $conf->{tw};
	my $treeFH = $conf->{th};
	my $x = $conf->{ox};
	my $y = $conf->{oty};
	my $cx = $conf->{ox} + $treeFW/2;
	my $cy = $conf->{oty} + $treeFH/2;
	
	if ($conf->{oriental} eq "top")
	{
		$group->setAttribute("transform","rotate(90,$cx,$cy)");
		($treeFW,$treeFH) = ($treeFH,$treeFW);
		$x = $cx - $treeFW/2;
		$y = $cy - $treeFH/2;
	}
	elsif ($conf->{oriental} eq "right")
	{
		my $matrix = SBV::DRAW::mirror($cx,$cy,$cx,0);
		$group->setAttribute("transform",$matrix);
	}
	elsif ($conf->{oriental} eq "bottom")
	{
		my $matrix = SBV::DRAW::mirror(0,$cy);
		$group->setAttribute("transform","rotate(-90,$cx,$cy)");
		($treeFW,$treeFH) = ($treeFH,$treeFW);
		$x = $cx - $treeFW/2;
		$y = $cy - $treeFH/2;
	}

	# get the datasets sum width (cantain the internal gap)
	my $dataWidth = 0;
	if ($#datasets >= 0)
	{
		for(@datasets) {
			next if ($_->{type} eq "pie");
			$dataWidth += $_->{width} + 2*$hi;
		}
		$dataWidth += 2*$hi;
	}

	# get the root node
	#my @nodes = $tree->get_root_node->each_Descendent;
	my $rootNode = $tree->get_root_node;
	
	# the root tail length
	my $tail = $conf->{tail} || 10;
	ERROR("negative_length_err",$tail) if ($tail < 0);
    
	my $treeL = tree_length($rootNode,$conf);
	my $unit = $conf->{unit} || (split /\s+/ , SBV::STAT::dividing(0,$treeL) )[2];
	my @leaves = $tree->get_leaf_nodes;
	
	# the unit height
	#my $unitH = $conf->{unit_height} || 20;
	my $unitH = _fetch_unitH($tree,$conf,$treeFH,$axis_flag);
	
	my @ids = map { 
		if(defined $defs->{$_->internal_id}->{label}->{font}){
			$defs->{$_->internal_id}->{label}->{font}
		} else { $_->id} 
	} @leaves;

	# set the unit length 
	my ($id_width,$tree_width);
	
	if ($conf->{tree_width})
	{
		$tree_width = $conf->{tree_width};
		$id_width = $treeFW - $tail - 3*$hi - $tree_width - $dataWidth;
		
		my $leaf_font = SBV::Font->fetch_font("leaf");
		my ($font_size,$unit) = $leaf_font->{'font-size'} =~ /(\d+)([a-z]+)/;
		my $raw_id_width = $leaf_font->fetch_max_text_width(\@ids);
		my $new_size = int $font_size*$id_width/$raw_id_width;
		$SBV::allStyle->{text}->{"CLASSleaf"}->{'font-size'} = $new_size;
	}
	else 
	{
		$id_width = SBV::Font->fetch_font("leaf")->fetch_max_text_width(\@ids);
		$tree_width = $treeFW - $id_width - $tail - 3*$hi - $dataWidth;
	}
	
	ERROR("tree_width_err") if ($tree_width <= 0);
	
	my $unitL = $tree_width / $treeL;
	my $svgH = ($#leaves) * $unitH + SBV::Font->fetch_font("leaf")->fetch_text_height;
	
	# draw branch length scale 
    my $unit_label = $unit;
    if ($conf->{clock_size}){
        my $timeL = $treeL/$conf->{clock_size};
        my $time_unit = (split /\s+/ , SBV::STAT::dividing(0,$timeL) )[2];
        $unit = $time_unit * $conf->{clock_size};
        $unit_label = $time_unit . "Mya";
    }

    if ($rootNode->height && ! $conf->{ignore_branch_length} && $conf->{show_distance_scale} && $conf->{scale_no_offset})
	{
		my $font = SBV::Font->fetch_font("scale");
		my $textH = $font->fetch_text_height;
		my $x2 = nearest 0.01 , ($x+$unit*$unitL);
		$scale_group->line(x1=>$x,x2=>$x2,y1=>$y,y2=>$y,class=>"scale");
		$scale_group->text(x=>$x2 + $hi,y=>$y+$textH/2,class=>"scale")->cdata($unit_label);
	}
	elsif ($rootNode->height && ! $conf->{ignore_branch_length} && $conf->{show_distance_scale})
	{
		# get font of scale
		my $font = SBV::Font->fetch_font("scale");
		my $textH = $font->fetch_text_height;
		
		$svgH += $textH/2 + $unitH;
		$y += $textH/2;

		my $x2 = nearest 0.01 , ($x+$unit*$unitL);
		$scale_group->line(x1=>$x,x2=>$x2,y1=>$y,y2=>$y,class=>"scale");
		$scale_group->text(x=>$x2 + $hi,y=>$y+$textH/2,class=>"scale")->cdata($unit_label);
		$y += $unitH;
	}
	else
	{
		$y += $unitH if ($axis_flag);
	}
	
	$y += $unitH/2;
	$svgH += $unitH;

	$par{unitH} = $unitH;
	$par{unitL} = $unitL;
	$par{idX} = $x + $tail + $tree_width + $hi;
	$par{idW} = $id_width;
	$par{treeL} = $treeL;
	$par{parent} = $group;
	$par{conf} = $conf;
	$par{rootNode} = $rootNode;
	$par{defs} = $defs;
	$par{treeY} = $y;

	# the main part
	# draw tree 
	my $py = _normal_tree($rootNode,$x + $tail,$y,\%par);
	
	# draw tail 
	my $id = "node_" . $rootNode->internal_id;
	$group->line(x1=>$x,x2=>$x+$tail,y1=>$py,y2=>$py,class=>"tail",id=>$id) if ($tail > 0);
	
	# add the HGT 
	if (my$hgt = $conf->{definition}->{hgt})
	{
		_add_HGT_arrow($hgt,$self->{id_trans},$group);
	}
	
	# add the datasets 
	my %func = (
		marker     => \&_add_tree_marker,
		bar        => \&_add_tree_bar,
		simple_bar => \&_add_tree_simple_bar,
		multi_bar  => \&_add_tree_multi_bar,
		circles    => \&_add_tree_circles,
		boxplot    => \&_add_tree_boxplot,
		pie        => \&_add_tree_pie,
		connection => \&_add_tree_connection,
		heatmap    => \&_add_tree_heatmap,
		modify     => \&_add_tree_modify
	);
	
	my $dataX = $par{idX} + $par{idW} + 2*$hi;
	foreach my $dataset(@datasets)
	{
		&{$func{$dataset->{type}}}($dataset,$dataX,%par) if ($dataset->{show} == 1);
		$dataX += $dataset->{width} + $hi*2 if ($dataset->{type} ne "pie");
		$dataX += 2*$hi if ($dataset->{show} == 0);
	}
	
}

sub _fetch_unitH
{
	my ($tree,$conf,$height,$axis_flag) = @_;
	
	my $unitH;
	my @leaves = $tree->get_leaf_nodes;
	my $label_font = SBV::Font->fetch_font("label");
	my $labelH = $label_font->fetch_text_height;

	if ($tree->get_root_node->height && ! $conf->{ignore_branch_length} && $conf->{show_distance_scale} && !$conf->{scale_no_offset})
	#if ($tree->get_root_node->height && ! $conf->{ignore_branch_length})
	{
		# get font of scale
		my $scale_font = SBV::Font->fetch_font("scale");
		my $scaleH = $scale_font->fetch_text_height;

		$unitH = ($height - $scaleH/2) / ($#leaves + 2);
	}
	elsif ($axis_flag)
	{
		$unitH = $height/($#leaves + 2);
	}
	else
	{
		$unitH = $height/($#leaves + 1);
	}

	return nearest 0.001 , $unitH;
}

sub _normal_tree
{
	my ($root,$ox,$oy,$par) = @_;
	
	my $unitL = $par->{unitL};
	my $unitH = $par->{unitH};
	my $parent = $par->{parent};
	my $conf = $par->{conf};

	my @nodes = $root->each_Descendent;
	
	my @py;
	my $py;
	my $tempy = $oy;
	
	foreach my$node(@nodes)
	{
		if ($node->is_Leaf)
		{
			_add_leaf($node,$ox,$tempy,$par);
			push @py , $tempy;
			$tempy += $unitH;
		}
		else 
		{
			my @subNodes = $node->get_all_Descendents;
			@subNodes  = grep { $_-> is_Leaf } @subNodes;
			my $nodeL = nearest 0.01 , (_get_branch_length($node,$conf) * $unitL);
			$py = _normal_tree($node,$ox+$nodeL,$tempy,$par);
			push @py , $py;
			my $nodeH = $#subNodes * $unitH;
			$tempy += $nodeH + $unitH;
		}
	}

	$py = ($py[0] + $py[-1])/2;
	_add_clade($root,$par,$ox,@py);
	return $py;
}

sub _normal_tree_bitree
{
	my ($root,$ox,$oy,$par) = @_;
	
	my $unitL = $par->{unitL};
	my $unitH = $par->{unitH};
	my $parent = $par->{parent};
	my $conf = $par->{conf};

	my ($left,$right) = $root->each_Descendent;
	my $leftL = nearest 0.01 , (_get_branch_length($left,$conf) * $unitL);
	my $rightL = nearest 0.01 , (_get_branch_length($right,$conf) * $unitL);

	my ($y1,$y2,$ymax,$ymin,$temp);
	if ($left->is_Leaf && $right->is_Leaf)
	{
		#($left,$right) = ($right,$left) if ($leftL < $rightL); # added at data 2014/08/13
		
		$y1 = $oy;
		$y2 = $oy + $unitH;
		$ymin = $y1 - $unitH/2;
		$ymax = $y2 + $unitH/2;
		
		_add_leaf($left,$ox,$y1,$par); # left leaf
		_add_leaf($right,$ox,$y2,$par); # right leaf
	}
	elsif ($left->is_Leaf)
	{
		$y1 = $oy;
		$ymin = $y1 - $unitH/2;
		($y2,$temp,$ymax) = _normal_tree($right,$ox+$rightL,$oy+$unitH,$par); # right tree
		_add_leaf($left,$ox,$y1,$par); #left leaf 
	}
	elsif ($right->is_Leaf)
	{
		$y1 = $oy;
		$ymin = $y1 - $unitH/2;
		
		#--------------------------------------------------------------------
		# left tree, but draw in the right , the leaf is default in left
		# this leaf order is very important
		#--------------------------------------------------------------------
		($y2,$temp,$ymax) = _normal_tree($left,$ox+$leftL,$oy+$unitH,$par);
		_add_leaf($right,$ox,$y1,$par);# right leaf
	}
	else
	{
		my @leftNodes = $left->get_all_Descendents;
		@leftNodes = grep { $_->is_Leaf } @leftNodes;

		my @rightNodes = $right->get_all_Descendents;
		@rightNodes = grep { $_->is_Leaf } @rightNodes;
		
		#($left,$right) = ($right,$left) if ($#leftNodes > $#rightNodes);
		
		if ($#leftNodes < $#rightNodes)
		{
			my $leftH = $#leftNodes * $unitH;
			($y1,$ymin,$temp) = _normal_tree($left,$ox+$leftL,$oy,$par);
			($y2,$temp,$ymax) = _normal_tree($right,$ox+$rightL,$oy+$leftH+$unitH,$par);
		}
		else 
		{
			my $rightH = $#rightNodes * $unitH;
			($y1,$ymin,$temp) = _normal_tree($right,$ox+$rightL,$oy,$par);
			($y2,$temp,$ymax) = _normal_tree($left,$ox+$leftL,$oy+$rightH+$unitH,$par);
		}
	}
	
	_add_clade($root,$ox,$y1,$y2,$ymin,$ymax,$par);
	return (($y1+$y2)/2,$ymin,$ymax);
}

# add the clade
sub _add_clade
{
	my ($root,$par,$x,@py) = @_;

	my $unitL = $par->{unitL};
	my $unitH = $par->{unitH};
	my $parent = $par->{parent};
	my $idX = $par->{idX};
	my $hi = $SBV::conf->{hspace};
	
	my $y1 = $py[0];
	my $y2 = $py[-1];
	my $ymin = $y1 - $unitH/2;
	my $ymax = $y2 + $unitH/2;
	
	# add the range 
	my $range = $parent->rect(x=>$x,y=>$ymin,width=>10,height=>$ymax-$ymin,class=>"range");

	my $y = ($y1+$y2)/2;
	my $clade_line1 = $parent->line(x1=>$x,x2=>$x,y1=>$y1,y2=>$y2,class=>"clade");
	
	my $root_len = $root eq $par->{rootNode} ? 0 : _get_branch_length($root,$par->{conf});

	my $clade_line2;
	my $x1 = $x;
	if ($root_len)
	{
		$x1 = nearest 0.01 , ($x-$root_len*$unitL);
		my $clade_line2_id = "node_" . $root->internal_id;
		$clade_line2 = $parent->line(x1=>$x1,x2=>$x,y1=>$y,y2=>$y,class=>"clade",id=>$clade_line2_id);
		_add_branch_length($root,$x1,$x,$y,$par);
		_add_bootstrap($root,$x,$y,$clade_line1,$clade_line2,$par);
	}

	# deal the definition
	if (my$def = $par->{defs}->{$root->internal_id})
	{
		if ($def->{clade})
		{
			$clade_line1->setAttribute("style","stroke:$def->{clade}->{color}");
			$clade_line2->setAttribute("style","stroke:$def->{clade}->{color}") if ($root_len);
		}
		
		if ($def->{range})
		{
			my ($width,$rectX);
			
			if (1 == $par->{conf}->{align})
			{
				if ($par->{conf}->{definition}->{cover} eq "full")
				{
					$rectX = $x1;
					$width = $idX - $x1 + $par->{idW};
				}
				else
				{
					$rectX = $idX;
					$width = $par->{idW};
				}
			}
			else
			{
				if ($par->{conf}->{definition}->{cover} eq "full")
				{
					$rectX = $x1;
					$width = $par->{idW};
				}
				else
				{
					return;
				}
			}
			
			$range->setAttribute("x",$rectX);
			$range->setAttribute("width",$width);
			$range->setAttribute("style","fill:$def->{range}->{color}");
			my $child1 = $parent->getFirstChild();
			$range = $parent->removeChild($range);
			$parent->insertBefore($range,$child1);
		}
	}
}

# add the leaf
# draw branch line and id
sub _add_leaf
{
	my($leaf,$x,$y,$par) = @_;
	
	my $unitL = $par->{unitL};
	my $unitH = $par->{unitH};
	my $parent = $par->{parent};
	my $idX = $par->{idX};
	my $idW = $par->{idW};
	my $conf = $par->{conf};
	my $defs = $par->{defs};
	
	my $leafL = nearest 0.01 ,(_get_branch_length($leaf,$conf) * $unitL);
	$leafL = 0 if ($leafL < 0);
	my $x2 = $x + $leafL;
	
	my $hi = $SBV::conf->{hspace};
	my $font = SBV::Font->fetch_font("leaf");
	my $textH = $font->fetch_text_height;
	
	# draw the range background for leaf and its branch
	my $range = $parent->rect(x=>$x,y=>$y-$unitH/2,width=>10,height=>$unitH,class=>"range");
	
	# draw leaf branch 
	my $leafLine_id = "node_" . $leaf->internal_id;
	my $leafLine = $parent->line(x1=>$x,x2=>$x2,y1=>$y,y2=>$y,class=>"leaf",id=>$leafLine_id);
    my $leaf_link_line;
	
	# draw leaf branch length value
	_add_branch_length($leaf,$x,$x2,$y,$par);
	
	# draw leaf id
	my $textX;
	if (0 == $conf->{align})
	{
		$textX = $x2+$SBV::conf->{hspace};
	}
	else
	{
		$textX = $idX;
        my $class = $conf->{linkage_type} eq "dotted" ? "linkage" : "leaf";
		$parent->line(x1=>$x2,x2=>$idX-$hi,y1=>$y,y2=>$y,
			class=>$class) if ($idX-$hi > $x2+$hi);
	}
	
	my $label = $leaf->id;
	if ( $defs->{$leaf->internal_id} && $defs->{$leaf->internal_id}->{label} && $defs->{$leaf->internal_id}->{label}->{font})
	{
		$label = $defs->{$leaf->internal_id}->{label}->{font};
	}
	my $leafText = $parent->text(x=>$textX,y=>$y+$textH/2,class=>"leaf")->cdata($label);
	
	# deal the definition
	if (my$def = $defs->{$leaf->internal_id})
	{
		if ($def->{clade})
		{
			$leafLine->setAttribute("style","stroke:$def->{clade}->{color}");
            $leaf_link_line->setAttribute("style","stroke:$def->{clade}->{color}") if ($leaf_link_line);
		}

		if ($def->{label})
		{
			my $def_font = $font;

			if ($def->{label}->{style})
			{
				$def_font = SBV::Font->new($def->{label}->{style});
			}

			if ($def->{label}->{color})
			{
				$def_font->setAttr({fill=>$def->{label}->{color}});
			}
			
			if ($def->{label}->{style} || $def->{label}->{color})
			{
				$leafText->setAttribute("style",$def_font->toStyle);
			}
		}
		
		if ($def->{range})
		{
			my $defconf = $conf->{'definition'};
			$range->setAttribute("x",$textX) if ($defconf->{cover} eq "label");

			my $width = 0;
			if ($defconf->{cover} eq "label")
			{
				$width = 1 == $conf->{align} ? $idW : $font->fetch_text_width($label);
			}
			else
			{
				$width = 1 == $conf->{align} ? ($idX-$x + $idW) : $x2-$x + $font->fetch_text_width($label);
			}
			
			$width = nearest 0.01 , $width;
			$range->setAttribute("width",$width);
			$range->setAttribute("style","fill:$def->{range}->{color};stroke:$def->{range}->{color}");
		}
	}
	
}

# add bootstrap
sub _add_bootstrap
{
	my ($node,$x,$y,$line1,$line2,$par) = @_;
	
	my $parent = $par->{parent};
	my $conf = $par->{conf};
	return unless (defined $conf->{bootstrap});
	
	my $bsconf = $conf->{bootstrap};
	my $bootstrap;
	
	if (defined $node->bootstrap)
	{
		$bootstrap = $node->bootstrap;
	}
	elsif (defined $node->id && $node->id =~ /[\d\.]+/)
	{
		$bootstrap = $node->id;
	}
	
	return unless defined $bootstrap;
	$bootstrap *= 100 if ($bootstrap <= 1);
	$bootstrap = int $bootstrap;

	my $font = SBV::Font->fetch_font("bootstrap");
	my $textH = $font->fetch_text_height;

	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};

	# draw bootstrap text
	if ($bsconf->{text})
	{
		my $threshold = $bsconf->{threshold} || 60;
		return if ($bootstrap < $threshold);
		
		my $textW = $font->fetch_text_width($bootstrap);
		$parent->text(x=>$x-$textW-$hi,y=>$y+$textH+$vi,class=>"bootstrap")->cdata($bootstrap);
	}
	# draw symbol
	elsif ($bsconf->{symbol})
	{
		my $symbol = _get_symbol($bsconf->{symbol},$bootstrap);
		return if ($symbol eq "");

		my $textW = $font->fetch_text_width($symbol);
		$parent->text(x=>$x-$textW-$hi,y=>$y+$textH+$vi,class=>"bootstrap")->cdata($symbol);
	}
	# draw color 
	elsif ($bsconf->{color})
	{
		my $color = _get_color($bsconf->{color},$bootstrap);
		$line1->setAttribute("style","stroke:$color");
		$line2->setAttribute("style","stroke:$color");
	}
}

# add branch length
sub _add_branch_length
{
	my ($node,$x1,$x2,$y,$par) = @_;
	
	return if (! $node->branch_length);
	
	my $conf = $par->{conf};
	
	return if (! $conf->{show_branch_length});
	
	my $unitL = $par->{unitL};
	my $parent = $par->{parent};
		
	my $font = SBV::Font->fetch_font('branch');
	my $textH = $font->fetch_text_height;
	
	my $bl = $node->branch_length;
	return if ($conf->{branch_length_cutoff} && $bl < $conf->{branch_length_cutoff});
	$bl = nearest $conf->{branch_length_nearest} , $bl if ($conf->{branch_length_nearest});

	my $textW = $font->fetch_text_width($bl);
	my $textX = ($x1+$x2)/2 - $textW/2;
	$parent->text(x=>$textX,y=>$y-$SBV::conf->{vspace},class=>"branch")->cdata($bl);
}

# add the HGT arrow 
sub _add_HGT_arrow
{
	my ($file,$trans,$parent) = @_;
	$file = check_path($file);
	
	open FH,$file or die "can't open file $file $!";
	while(<FH>)
	{
		chomp;
		my @arr = split /\t/;
		my $id1 = _trans_key($arr[0],"HGT",$trans);
		my $id2 = _trans_key($arr[1],"HGT",$trans);
		my $color = SBV::Colors::fetch_color($arr[2]);

		my $line1 = $SBV::svg->getElementByID("node_" . $id1);
		my $line2 = $SBV::svg->getElementByID("node_" . $id2);
		my $x1 = ($line1->getAttribute('x1') + $line1->getAttribute('x2')) / 2;
		my $x2 = ($line2->getAttribute('x1') + $line2->getAttribute('x2')) / 2;
		my $y1 = ($line1->getAttribute('y1') + $line1->getAttribute('y2')) / 2;
		my $y2 = ($line2->getAttribute('y1') + $line2->getAttribute('y2')) / 2;

		my $markid = SBV::DRAW::arrow(20,10,-zh=>0.5,-style=>"fill:$color",-class=>"arrow");
		$parent->line(x1=>$x1,x2=>$x2,y1=>$y1,y2=>$y2,
			style=>"stroke:$color",class=>"hgt",'marker-end'=>"url(#$markid)");
	}
	close FH;
}

#-------------------
# add datasets 
#------------------
# add tree marker
sub _add_tree_marker
{
	my ($dataset,$x,%par) = @_;
	
	my $height = $dataset->{height} * $par{unitH};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my $class = $dataset->{border} ? "selector" : "marker";

	foreach my$id(keys %{$dataset->{data}})
	{
		my $fill = $dataset->{data}->{$id};
		my $style = "fill:$fill;";

		my $y = $SBV::svg->getElementByID("node_" . $id)->getAttribute('y1');
		$parent->rect(x=>$x,y=>$y-$height/2,width=>$width,height=>$height,
			style=>$style,class=>$class);
	}
}

# add tree bar
sub _add_tree_bar
{
	my ($dataset,$x,%par) = @_;
	my $vi = $SBV::conf->{vspace};

	my $height = $dataset->{height} * $par{unitH};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my @color = @{ $dataset->{color} };
	my $oy = $par{treeY} - $vi - $par{unitH}/2;

	# create x axis 
	my @sum = map { sum($_) } values %{$dataset->{data}};
	my $max = max(\@sum);
	my $scale = SBV::STAT::dividing(0,$max);
	my %axis_par = (parent=>$parent,ox=>$x,oy=>$oy,length=>$width,tick=>$scale);
	my $axis = SBV::STONE::AXIS->new(%axis_par);
    $axis->aes(%{$dataset->{axis}});
	$axis->plot;

	foreach my$id(keys %{$dataset->{data}})
	{
		my $rectx = $x;
		my $recty = $SBV::svg->getElementByID("node_" . $id)->getAttribute('y1') - $height/2;
		my $i = 0;
		foreach my$num (@{$dataset->{data}->{$id}})
		{
			my $rectw = nearest 0.01 , ($axis->fetch_dis($num));
			my $color = loop_arr(\@color,$i);
			$parent->rect(x=>$rectx,y=>$recty,width=>$rectw,height=>$height,
				style=>"fill:$color",class=>"marker");
			$rectx += $rectw;
			$i ++;
		}
	}
}

sub _add_tree_simple_bar
{
	my ($dataset,$x,%par) = @_;	
	my $vi = $SBV::conf->{vspace};

	my $height = $dataset->{height} * $par{unitH};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my @color = @{ $dataset->{color} };
	my $oy = $par{treeY} - $vi - $par{unitH}/2;
	
	# create x axis 
	my @nums = map { $_->[0] } values %{$dataset->{data}};
	my $scale = SBV::STAT::dividing(\@nums,-xtrue=>1);
	my %axis_par = (parent=>$parent,ox=>$x,oy=>$oy,length=>$width,tick=>$scale);
	my $axis = SBV::STONE::AXIS->new(%axis_par);
    $axis->aes(%{$dataset->{axis}});
	$axis->plot;
	
	my $i = 0;
	foreach my$id(keys %{$dataset->{data}})
	{
		my $color = loop_arr(\@color,$i);
		my $rectx = $x;
		my $recty = $SBV::svg->getElementByID("node_" . $id)->getAttribute('y1') - $height/2;
		my $num = $dataset->{data}->{$id}->[0];
		my $rectw = nearest 0.01 , ($axis->fetch_dis($num));
		$parent->rect(x=>$rectx,y=>$recty,width=>$rectw,height=>$height,
			style=>"fill:$color",class=>"marker");
		$i ++;
	}
}

sub _add_tree_multi_bar
{
	my ($dataset,$x,%par) = @_;	
	my $vi = $SBV::conf->{vspace};

	my $height = $dataset->{height} * $par{unitH};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my @color = @{ $dataset->{color} };
	my $oy = $par{treeY} - $vi - $par{unitH}/2;
	
	my @values = values %{$dataset->{data}};
	my $bar_num = scalar @{$values[0]};
	my $bar_width = nearest 0.01 , ($width / $bar_num);
	
	for my$index (0 .. $bar_num-1)
	{
		my $color = loop_arr(\@color,$index);
		my @nums = map { $_->[$index] } values %{$dataset->{data}};
		my $scale = SBV::STAT::dividing(\@nums,-xtrue=>1);
		my %axis_par = (parent=>$parent,ox=>$x+$bar_width*$index,oy=>$oy,length=>$bar_width,tick=>$scale);
        my $axis = SBV::STONE::AXIS->new(%axis_par);
        $axis->aes(%{$dataset->{axis}});
		$axis->plot;

		foreach my$id(keys %{$dataset->{data}})
		{
			my $rectx = $x + $index*$bar_width;
			my $recty = $SBV::svg->getElementByID("node_" . $id)->getAttribute('y1') - $height/2;
			my $num = $dataset->{data}->{$id}->[$index];
			my $rectw = nearest 0.01 , ($axis->fetch_dis($num));
			$parent->rect(x=>$rectx,y=>$recty,width=>$rectw,height=>$height,
					style=>"fill:$color",class=>"marker");
		}
	}
}

sub _add_tree_circles
{
	my ($dataset,$x,%par) = @_;	
	my $vi = $SBV::conf->{vspace};

	my $height = $dataset->{height} * $par{unitH};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my @color = @{ $dataset->{color} };
	
	my @values = values %{$dataset->{data}};
	my $circle_num = scalar @{$values[0]};
	my $space = ($width - $circle_num * $height) / ($circle_num - 1);
	my @nums = map { $_->[0] } @values;
	my $max = max(\@nums);
	
	for my$index (0 .. $circle_num-1)
	{
		my $color = loop_arr(\@color,$index);
		foreach my$id(keys %{$dataset->{data}})
		{
			my $cx = nearest 0.01 , ($x + $index * ($space + $height) + $height/2);
			my $cy = $SBV::svg->getElementByID("node_" . $id)->getAttribute('y1');
			my $r = nearest 0.01 , ($height/2 * $dataset->{data}->{$id}->[$index] / $max); 
			$parent->circle(cx=>$cx,cy=>$cy,r=>$r,style=>"fill:$color",class=>"marker");
		}
	}
}

sub _add_tree_boxplot
{
	my ($dataset,$x,%par) = @_;	
	my $vi = $SBV::conf->{vspace};

	my $height = $dataset->{height} * $par{unitH};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my @color = @{ $dataset->{color} };
	my $oy = $par{treeY} - $vi - $par{unitH}/2;

	# create x axis 
	my @nums;
	map { splice(@nums,0,0,@$_) } values %{$dataset->{data}};
	my $scale = SBV::STAT::dividing(\@nums);
    my %axis_par = (parent=>$parent,ox=>$x,oy=>$oy,length=>$width,tick=>$scale);
	my $axis = SBV::STONE::AXIS->new(%axis_par);
    $axis->aes(%{$dataset->{axis}});
	$axis->plot;
	
	my $i = 0;
	foreach my$id(keys %{$dataset->{data}})
	{
		my $color = loop_arr(\@color,$i);

		my @val = @{ $dataset->{data}->{$id} };
		my ($q1,$q2,$q3) = SBV::STAT::quartile(\@val);
		my $iqr = $q3 - $q1;
		my $up = $q3 + 1.5*$iqr;
		my $low = $q1 - 1.5*$iqr;
		
		my ($upval,$lowval,@abnormal);
		foreach (@val){if ($_ >= $low){$lowval = $_;last;}else{push @abnormal , $_;}}
		foreach (reverse @val){if ($_ <= $up){$upval = $_;last;}else{push @abnormal , $_;}}

		my $y2 = $SBV::svg->getElementByID("node_" . $id)->getAttribute('y1');
		my $y1 = $y2 - $height/2;
		my $y3 = $y2 + $height/2;
		
		my $q3x = $x + $axis->fetch_dis($q3);
		my $q2x = $x + $axis->fetch_dis($q2);
		my $q1x = $x + $axis->fetch_dis($q1);
		my $upx = $x + $axis->fetch_dis($upval);
		my $lowx = $x + $axis->fetch_dis($lowval);
		my $w = ($q3x-$q1x);

		$parent->rect(y=>$y1,x=>$q1x,height=>$height,width=>$w,
			style=>{stroke=>$color,'stroke-width'=>1});
		$parent->line(y1=>$y1,x1=>$q2x,y2=>$y3,x2=>$q2x,
			style=>{stroke=>$color,'stroke-width'=>2});
		$parent->line(y1=>$y2,y2=>$y2,x1=>$q3x,x2=>$upx,
			style=>{stroke=>$color,'stroke-width'=>1});
		$parent->line(y1=>$y2,y2=>$y2,x1=>$q1x,x2=>$lowx,
			style=>{stroke=>$color,'stroke-width'=>1});
		foreach my$i (@abnormal)
		{
			my $ix = $x + $axis->fetch_dis($i);
			$parent->circle(cy=>$y2,cx=>$ix,r=>2,style=>{fill=>$color,'stroke-width'=>0});
		}

		$i ++;
	}	
}

sub _add_tree_pie
{
	my ($dataset,$x,%par) = @_;	

	my $height = $dataset->{height} * $par{unitH};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my @color = @{ $dataset->{color} };

	my $R = $par{unitH} * $dataset->{height};
	
	foreach my$id(keys %{$dataset->{data}})
	{
		my $x1 = $SBV::svg->getElementByID("node_" . $id)->getAttribute('x1');
		my $x2 = $SBV::svg->getElementByID("node_" . $id)->getAttribute('x2');
		my $cx = ($x1+$x2)/2;
		my $cy = $SBV::svg->getElementByID("node_" . $id)->getAttribute('y1');
		
		my @vals = @{$dataset->{data}->{$id}};
		my $sum = sum(\@vals);
		my $temp = 0;
		my $group = $parent->group();
		foreach my$i(0 .. $#vals)
		{
			my $color = loop_arr(\@color,$i);
			my %fan = (start=>$temp,color=>$color,r1=>0,class=>'pie',parent=>$group);
			SBV::DRAW::Fan($cx,$cy,$sum,$temp+$vals[$i],$R/2,%fan);
			$temp += $vals[$i];
		}
	}
}

sub _add_tree_heatmap
{
	my ($dataset,$x,%par) = @_;	
	
	my $height = $dataset->{height} * $par{unitH};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my @colors = @{ $dataset->{color} };

	my @values = values %{$dataset->{data}};
	my $col_num = scalar @{$values[0]};
	my @nums;
	map { splice(@nums,0,0,@$_) } @values;
	my $max = max(\@nums);
	my $min = min(\@nums);
	my $block_width = $width/$col_num;

	my $scale = $dataset->{scale} || "none";
	
	# fetch the column min and max ( for scale == column )
	my (@cmin,@cmax);
	if ($scale eq "column")
	{
		foreach my$i (0 .. $col_num-1)
		{
			my @temp = map { $_->[$i] } @values;
			push @cmin , min(\@temp);
			push @cmax , max(\@temp);
		}
	}
	
	foreach my$id(keys %{$dataset->{data}})
	{
		my @vals = @{$dataset->{data}->{$id}};
		
		if ($scale eq "row")
		{
			$min = min(\@vals);
			$max = max(\@vals);
		}
		my $recty = $SBV::svg->getElementByID("node_" . $id)->getAttribute('y1') - $height/2;
		foreach my$index(0 .. $#vals)
		{
			if ($scale eq "column")
			{
				$min = $cmin[$index];
				$max = $cmax[$index];
			}
			my $rectx = $x + $index * $block_width;
			
			my ($ratio,$color);
			
			if ($min != $max)
			{
				$ratio = ($vals[$index]-$min)/($max-$min);
				$color = SBV::Colors::fetch_gradient_color($ratio,@colors);
			}
			else 
			{
				$color = "none";
			}

			$parent->rect(x=>$rectx,y=>$recty,width=>$block_width,height=>$height,
				style=>"fill:$color",class=>"heatmap");
		}
	}
}

sub _add_tree_connection
{
		
}

sub _add_tree_modify
{
	my ($dataset,$x,%par) = @_;	
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};

	my $height = $dataset->{height} * $par{unitH};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my $oy = $par{treeY} - $vi - $par{unitH}/2;
	
	my $maxLen;
	if ($dataset->{format} eq "domain")
	{
		my @length = map {$_->[0]->[0]} values %{$dataset->{data}};
		$maxLen = max(\@length);
        
        my $scale = SBV::STAT::dividing(0,$maxLen);
        my %axis_par = (parent=>$parent,ox=>$x,oy=>$oy,length=>$width,tick=>$scale);
        my $axis = SBV::STONE::AXIS->new(%axis_par);
        $axis->aes(%{$dataset->{axis}});
        $axis->plot;
	}

	foreach my$id(keys %{$dataset->{data}})
	{
		my $y = $SBV::svg->getElementByID("node_" . $id)->getAttribute('y1');
		
		if ($dataset->{format} eq "domain")
		{
			my $len = $dataset->{data}->{$id}->[0]->[0];
			$parent->line(x1=>$x,x2=>$x+$len*$width/$maxLen,y1=>$y,y2=>$y) if $dataset->{bgline};

			foreach my$modify(@{$dataset->{data}->{$id}})
			{
				my ($len,$sta,$end,$shape,$color,$fill,$label) = @$modify;
				my $usex = $x + $sta/$maxLen * $width;
				my $usew = ($end-$sta+1)/$maxLen * $width;
				my $symid = SBV::STONE::SYMBOL::new($shape,height=>$height,width=>$usew,fill=>$fill,color=>$color);
				$parent->group()->use(x=>$usex,y=>$y-$height/2,width=>$usew,height=>$height,'-href'=>"#$symid");
			}
		}
		elsif ($dataset->{format} eq "symbol")
		{
			my $i = 0;
			foreach my$modify(@{$dataset->{data}->{$id}})
			{
				my ($shape,$color,$fill,$label) = @$modify;
				my $usex = $x + ($height+$hi) * $i;
				my $usew = $height;
				my $symid = SBV::STONE::SYMBOL::new($shape,height=>$height,width=>$usew,fill=>$fill,color=>$color);
				$parent->group()->use(x=>$usex,y=>$y-$height/2,width=>$usew,height=>$height,'-href'=>"#$symid");
				$i ++;
			}
		}
	}


}

#----------draw normal tree function done----------------------
#--------------------------------------------------------------

#-------------------------------------------------------------------------------
#  draw circular tree
#-------------------------------------------------------------------------------
sub circular_tree
{
	my ($self,$tree,$conf,$scale_group,$group) = @_;
	my %par;
	
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};

	# load color and leaf labels definition files
	my $defs = _load_defs($conf,$self->{id_trans});
	my @datasets = _load_datasets($conf,$self->{id_trans});
	
	# get the datasets sum width (cantain the internal gap)
	my $dataWidth = 0;

	if ($#datasets >= 0)
	{
		for(@datasets) {
			next if ($_->{type} eq "pie");
			$dataWidth += $_->{width} + 2*$hi;
		}
		$dataWidth += 2*$hi;
	}
	
	# get the root node
	#my @nodes = $tree->get_root_node->each_Descendent;
	my $rootNode = $tree->get_root_node;
	
	# the root tail length
	my $tail = $conf->{tail} || 10;
	ERROR("negative_length_err",$tail) if ($tail < 0);

	my $x = $conf->{ox};
	my $y = $conf->{oty};

	my $treeL = tree_length($rootNode,$conf);
	my $unit = $conf->{unit} || (split /\s+/ , SBV::STAT::dividing(0,$treeL) )[2];
	my @leaves = $tree->get_leaf_nodes;
	
	my @ids = map { 
		if(defined $defs->{$_->internal_id}->{label}->{font}){
			$defs->{$_->internal_id}->{label}->{font}
		} else { $_->id} 
	} @leaves;
	
	# the unit Angle
	my $unitA = $conf->{angle} / ($#leaves + 1);

	# set the radius and circle origin points coord
	my $or = $conf->{radius};
	my $R = $conf->{tw} > $conf->{th} ? $conf->{th} : $conf->{tw};
	my $r = $R/2;
	my $cx = $x + $conf->{tw}/2;
	my $cy = $y + $conf->{th}/2;
	
	# rotate the group
	if (my $rotation = $conf->{rotation})
	{
		$group->setAttribute("transform","rotate($rotation,$cx,$cy)");
	}
	
	# set the unit length 
	my ($id_width,$tree_width);
	
	if ($conf->{tree_width})
	{
		$tree_width = $conf->{tree_width};
		$id_width = $r - $or - $tail - 3*$hi - $tree_width - $dataWidth;
		
		my $leaf_font = SBV::Font->fetch_font("leaf");
		my ($font_size,$unit) = $leaf_font->{'font-size'} =~ /(\d+)([a-z]+)/;
		my $raw_id_width = $leaf_font->fetch_max_text_width(\@ids);
		my $new_size = int $font_size*$id_width/$raw_id_width;
		$SBV::allStyle->{text}->{"CLASSleaf"}->{'font-size'} = $new_size;
	}
	else 
	{
		$id_width = SBV::Font->fetch_font("leaf")->fetch_max_text_width(\@ids);
		$tree_width = $r - $or - $id_width - $tail - 3*$hi - $dataWidth;
	}
	
	my $unitL = $tree_width / $treeL;

	# creat new plolar coord system for circular tree
	my $polar = SBV::Coordinate::POLAR->new($cx,$cy,parent=>$group);

	# set the par
	$par{unitA} = $unitA;
	$par{unitL} = $unitL;
	$par{idR} = $or + $tail + $tree_width + $hi;
	$par{idW} = $id_width;
	$par{treeL} = $treeL;
	$par{unitH} = $polar->dist($par{idR}+$id_width-$or,0,$par{idR}+$id_width-$or,$unitA,-type=>"angle");
	$par{parent} = $group;
	$par{conf} = $conf;
	$par{rootNode} = $rootNode;
	$par{defs} = $defs;
	$par{cx} = $cx;
	$par{cy} = $cy;
	$par{r} = $r;
	$par{polar} = $polar;

	# draw branch length scale 
	if ($rootNode->height && ! $conf->{ignore_branch_length} && $conf->{show_distance_scale})
	{
		my $font = SBV::Font->fetch_font("scale");
		my $textH = $font->fetch_text_height;
		my $unit_len = $unit * $unitL;
		$polar->line($par{idR}-$hi,-$unitA,$par{idR}-$hi-$unit_len,-$unitA,class=>"scale");
		$polar->text($par{idR},-$unitA,$textH/2,$unit,class=>"scale");
	}

	# the main part
	# draw tree 
	my ($pa,$amin,$amax) = _circular_tree($rootNode,$or+$tail,0,\%par);
	
	# draw tail 
	my $id = "node_" . $rootNode->internal_id;
	$polar->line($or,$pa,$or+$tail,$pa,class=>"tail",id=>$id) if ($tail > 0);

	# add the HGT 
	if (my$hgt = $conf->{definition}->{hgt})
	{
		_add_HGT_arrow($hgt,$self->{id_trans},$group);
	}
	
	# add the datasets 
	my %func = (
		marker     => \&_add_circular_tree_marker,
		bar        => \&_add_circular_tree_bar,
		simple_bar => \&_add_circular_tree_simple_bar,
		multi_bar  => \&_add_circular_tree_multi_bar,
		circles    => \&_add_circular_tree_circles,
		boxplot    => \&_add_circular_tree_boxplot,
		pie        => \&_add_circular_tree_pie,
		connection => \&_add_circular_tree_connection,
		heatmap    => \&_add_circular_tree_heatmap,
		modify     => \&_add_circular_tree_modify
	);
	my $dataR = $par{idR} + $par{idW} + 2*$hi;
	
	foreach my $dataset(@datasets)
	{
		&{$func{$dataset->{type}}}($dataset,$dataR,%par);
		$dataR += $dataset->{width} + $hi * 2 if ($dataset->{type} ne "pie");
	}
}

sub _circular_tree
{
	my ($root,$r,$a,$par) = @_;
	
	my $unitL = $par->{unitL};
	my $unitA = $par->{unitA};
	my $polar = $par->{polar};
	my $parent = $par->{parent};
	my $conf = $par->{conf};
	
	my @nodes = $root->each_Descendent;
	
	my @pa;
	my $tempa = $a;
	my ($amin,$amax);
	foreach my $i (0 .. $#nodes)
	{
		my $node = $nodes[$i];
		my ($pa,$a1,$a2);
		if ($node->is_Leaf)
		{
			_add_circular_leaf($node,$r,$tempa,$par);
			push @pa , $tempa;
			$a1 = $tempa - $unitA/2;
			$tempa += $unitA;
			$a2 = $tempa + $unitA/2;
		}
		else
		{
			my $nodeL = nearest 0.01 , (_get_branch_length($node,$conf) * $unitL);
			my @subNodes = $node->get_all_Descendents;
			@subNodes  = grep { $_-> is_Leaf } @subNodes;
			($pa,$a1,$a2) = _circular_tree($node,$r+$nodeL,$tempa,$par);
			push @pa , $pa;
			my $nodeA = $#subNodes * $unitA;
			$tempa += $nodeA + $unitA;
		}

		$amin = $a1 if ($i == 0);
		$amax = $a2 if ($i == $#nodes);
	}
	
	my $pa = ($pa[0] + $pa[-1])/2;
	_add_circular_more_clade($root,$par,$r,$amin,$amax,@pa);
	return ($pa,$amin,$amax);
}

sub _add_circular_more_clade
{
	my ($root,$par,$r,$amin,$amax,@pa) = @_;
	
	my $unitL = $par->{unitL};
	my $unitA = $par->{unitA};
	my $polar = $par->{polar};
	my $parent = $par->{parent};
	my $idR = $par->{idR};
	my $hi = $SBV::conf->{hspace};
	
	# set the range par and coord
	my @range_coord = ($r,$amin,$r+10,$amax-$unitA);
	my %range_par = (class=>"range");

	# draw the clade arc
	my $a = ($pa[0]+$pa[-1])/2;
	my $clade_line1 = $polar->pline($r,$pa[0],$pa[-1],class=>"clade");
	$par->{angle}->{$root->internal_id} = $a;

	# draw the clade line
	my $clade_line2;
	my $r1 = $r;
	my $root_len = $root eq $par->{rootNode} ? 0 : _get_branch_length($root,$par->{conf});
	if ($root_len)
	{
		$r1 = nearest 0.01 , ($r-$root_len*$unitL);
		my $clade_line2_id = "node_" . $root->internal_id;
		$clade_line2 = $polar->line($r1,$a,$r,$a,class=>"clade",id=>$clade_line2_id);
		_add_circular_branch_length($root,$r1,$r,$a,$par);
		_add_circular_bootstrap($root,$r,$a,$clade_line1,$clade_line2,$par);
	}
    
    # draw the clade id
    if ($par->{conf}->{show_clade_id})
    {
        $polar->text($r,$a,0,$root->id,class=>"clade_id",id=>$root->id);
    }

	# deal the definition
	if (my$def = $par->{defs}->{$root->internal_id})
	{
		if ($def->{clade})
		{
			$clade_line1->setAttribute("style","stroke:$def->{clade}->{color}");
			$clade_line2->setAttribute("style","stroke:$def->{clade}->{color}") if ($root_len);
		}
		
		if ($def->{range})
		{
			my ($width,$rectR);
			
			if (1 == $par->{conf}->{align})
			{
				if ($par->{conf}->{definition}->{cover} eq "full")
				{
					$rectR = $r1;
					$width = $idR - $r1 + $par->{idW};
				}
				else
				{
					$rectR = $idR;
					$width = $par->{idW};
				}
			}
			else
			{
				if ($par->{conf}->{definition}->{cover} eq "full")
				{
					$rectR = $r1;
					$width = $par->{idW};
				}
				else
				{
					return;
				}
			}
			
			$range_coord[0] = $rectR;
			$range_coord[2] = $range_coord[0] + $width;
			$range_par{"style"} = "fill:$def->{range}->{color}";
			my $child1 = $parent->getFirstChild();
			my $range = $polar->prect(@range_coord,%range_par);
			$range = $parent->removeChild($range);
			$parent->insertBefore($range,$child1);
		}
	}
}

# add the circular clade
sub _add_circular_clade
{
	my ($root,$r,$a1,$a2,$amin,$amax,$par) = @_;
	
	my $unitL = $par->{unitL};
	my $unitA = $par->{unitA};
	my $polar = $par->{polar};
	my $parent = $par->{parent};
	my $idR = $par->{idR};
	my $hi = $SBV::conf->{hspace};
	
	# set the range par and coord
	my @range_coord = ($r,$amin,$r+10,$amax);
	my %range_par = (class=>"range");

	# draw the clade arc
	my $a = ($a1+$a2)/2;
	my $clade_line1 = $polar->pline($r,$a1,$a2,class=>"clade");
	$par->{angle}->{$root->internal_id} = $a;

	# draw the clade line
	my $clade_line2;
	my $r1 = $r;
	my $root_len = $root eq $par->{rootNode} ? 0 : _get_branch_length($root,$par->{conf});
	if ($root_len)
	{
		$r1 = nearest 0.01 , ($r-$root_len*$unitL);
		my $clade_line2_id = "node_" . $root->internal_id;
		$clade_line2 = $polar->line($r1,$a,$r,$a,class=>"clade",id=>$clade_line2_id);
		_add_circular_branch_length($root,$r1,$r,$a,$par);
		_add_circular_bootstrap($root,$r,$a,$clade_line1,$clade_line2,$par);
	}
	
	# deal the definition
	if (my$def = $par->{defs}->{$root->internal_id})
	{
		if ($def->{clade})
		{
			$clade_line1->setAttribute("style","stroke:$def->{clade}->{color}");
			$clade_line2->setAttribute("style","stroke:$def->{clade}->{color}") if ($root_len);
		}
		
		if ($def->{range})
		{
			my ($width,$rectR);
			
			if (1 == $par->{conf}->{align})
			{
				if ($par->{conf}->{definition}->{cover} eq "full")
				{
					$rectR = $r1;
					$width = $idR - $r1 + $par->{idW};
				}
				else
				{
					$rectR = $idR;
					$width = $par->{idW};
				}
			}
			else
			{
				if ($par->{conf}->{definition}->{cover} eq "full")
				{
					$rectR = $r1;
					$width = $par->{idW};
				}
				else
				{
					return;
				}
			}
			
			$range_coord[0] = $rectR;
			$range_coord[2] = $range_coord[0] + $width;
			$range_par{"style"} = "fill:$def->{range}->{color}";
			my $child1 = $parent->getFirstChild();
			my $range = $polar->prect(@range_coord,%range_par);
			$range = $parent->removeChild($range);
			$parent->insertBefore($range,$child1);
		}
	}
}

# add the circular leaf
# draw branch line and id
sub _add_circular_leaf
{
	my($leaf,$r,$a,$par) = @_;
	
	my $unitL = $par->{unitL};
	my $unitA = $par->{unitA};
	my $parent = $par->{parent};
	my $polar = $par->{polar};
	my $idR = $par->{idR};
	my $idW = $par->{idW};
	my $conf = $par->{conf};
	my $defs = $par->{defs};
	
	my $leafL = nearest 0.01 ,(_get_branch_length($leaf,$conf) * $unitL);
	$leafL = 0 if ($leafL < 0);
	my $r2 = $r + $leafL; 
	
	my $hi = $SBV::conf->{hspace};
	my $font = SBV::Font->fetch_font("leaf");
	my $textH = $font->fetch_text_height;

	# draw the range background for leaf and its branch
	my @range_coord = ($r,$a-$unitA/2,$r+10,$a+$unitA/2);
	my %range_par = (class=>"range");
	my $range = $polar->prect(@range_coord,%range_par);
	
	# draw leaf branch 
	my $leafLine_id = "node_" . $leaf->internal_id;
	my $leafLine = $polar->line($r,$a,$r2,$a,class=>"leaf",id=>$leafLine_id);
    my $leaf_link_line;
	$par->{angle}->{$leaf->internal_id} = $a;
	
	# draw leaf branch length value
	_add_circular_branch_length($leaf,$r,$r2,$a,$par);
	
	# draw leaf id
	my $textR;
	if (0 == $conf->{align})
	{
		$textR = $r2+$SBV::conf->{hspace};
	}
	else
	{
		$textR = $idR;
        my $class = $conf->{linkage_type} eq "dotted" ? "linkage" : "leaf";
		$leaf_link_line = $polar->line($r2,$a,$idR-$hi,$a,class=>$class) if ($idR-$hi > $r2+$hi);
	}
	
	my $label = $leaf->id;
	
	if ( $defs->{$leaf->internal_id} && $defs->{$leaf->internal_id}->{label} && $defs->{$leaf->internal_id}->{label}->{font})
	{
		$label = $defs->{$leaf->internal_id}->{label}->{font};
	}

	my $leafText = $polar->text($textR,$a,$textH/2,$label,class=>"leaf",id=>$label);
	
	# deal the definition
	if (my$def = $defs->{$leaf->internal_id})
	{
		if ($def->{clade})
		{
			$leafLine->setAttribute("style","stroke:$def->{clade}->{color}");
            $leaf_link_line->setAttribute("style","stroke:$def->{clade}->{color}") if ($leaf_link_line);
		}

		if ($def->{label})
		{
			if ($def->{label}->{color})
			{
				$leafText->setAttribute("style","fill:$def->{label}->{color}");
			}
		}
		
		if ($def->{range})
		{
			my $defconf = $conf->{'definition'};

			my $width = 0;
			if ($defconf->{cover} eq "label")
			{
				$range_coord[0] = $idR;
				$width = 1 == $conf->{align} ? $idW : $font->fetch_text_width($label);
			}
			else
			{
				$width = 1 == $conf->{align} ? ($idR-$r + $idW) : $r2-$r + $font->fetch_text_width($label);
			}
			
			$width = nearest 0.01 , $width;
			$range_coord[2] = $range_coord[0] + $width;
			$range_par{style} = "fill:$def->{range}->{color};stroke:$def->{range}->{color}";
		}
	}
	
	if ($range_coord[0] == $range_coord[2]+10)
	{
		$parent->removeChild($range);
	}
	else
	{
		my $range1 = $polar->prect(@range_coord,%range_par);
		$parent->replaceChild($range1,$range);
	}
}

# add bootstrap in circular tree
sub _add_circular_bootstrap
{
	my ($node,$r,$a,$line1,$line2,$par) = @_;
	
	my $parent = $par->{parent};
	my $polar = $par->{polar};
	my $conf = $par->{conf};
	return if (! defined $conf->{bootstrap});
	
	my $bsconf = $conf->{bootstrap};
	
	my $bootstrap = $node->bootstrap;
	return unless defined $bootstrap;
	
	$bootstrap *= 100 if ($bootstrap <= 1);
	$bootstrap = int $bootstrap;

	my $font = SBV::Font->fetch_font("bootstrap");
	my $textH = $font->fetch_text_height;

	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};

	# draw bootstrap text
	if ($bsconf->{text})
	{
		my $threshold = $bsconf->{threshold} || 60;
		return if ($bootstrap < $threshold);
		
		my $textW = $font->fetch_text_width($bootstrap);
		$polar->text($r-$textW-$hi,$a,$textH+$vi,$bootstrap,class=>"bootstrap");
	}
	# draw symbol
	elsif ($bsconf->{symbol})
	{
		my $symbol = _get_symbol($bsconf->{symbol},$bootstrap);
		return if ($symbol eq "");

		my $textW = $font->fetch_text_width($symbol);
		$polar->text($r-$textW-$hi,$a,$textH+$vi,$symbol,class=>"bootstrap");
	}
	# draw color 
	elsif ($bsconf->{color})
	{
		my $color = _get_color($bsconf->{color},$bootstrap);
		$line1->setAttribute("style","stroke:$color");
		$line2->setAttribute("style","stroke:$color");
	}
}

# add branch length in circular tree
sub _add_circular_branch_length
{
	my ($node,$r1,$r2,$a,$par) = @_;
	
	return if (! $node->branch_length);
	
	my $conf = $par->{conf};
	
	return if (! $conf->{show_branch_length});
	
	my $unitL = $par->{unitL};
	my $parent = $par->{parent};
	my $polar = $par->{polar};
		
	my $font = SBV::Font->fetch_font('branch');
	my $textH = $font->fetch_text_height;
	
	my $bl = $node->branch_length;
	
	return if ($conf->{branch_length_cutoff} && $bl < $conf->{branch_length_cutoff});
	$bl = nearest $conf->{branch_length_nearest} , $bl if ($conf->{branch_length_nearest});
	
	my $textW = $font->fetch_text_width($bl);
	my $textR = ($r1+$r2)/2 - $textW/2;
	$polar->text($textR,$a,-$SBV::conf->{vspace},$bl,class=>"branch");
}

# add the HGT arrow in circular tree
sub _add_circular_HGT_arrow
{
	my ($file,$trans,$parent) = @_;
	$file = check_path($file);
	
	open FH,$file or die "can't open file $file $!";
	while(<FH>)
	{
		chomp;
		my @arr = split /\t/;
		my $id1 = _trans_key($arr[0],"HGT",$trans);
		my $id2 = _trans_key($arr[1],"HGT",$trans);
		my $color = SBV::Colors::fetch_color($arr[2]);

		my $line1 = $SBV::svg->getElementByID("node_" . $id1);
		my $line2 = $SBV::svg->getElementByID("node_" . $id2);
		my $x1 = ($line1->getAttribute('x1') + $line1->getAttribute('x2')) / 2;
		my $x2 = ($line2->getAttribute('x1') + $line2->getAttribute('x2')) / 2;
		my $y1 = ($line1->getAttribute('y1') + $line1->getAttribute('y2')) / 2;
		my $y2 = ($line2->getAttribute('y1') + $line2->getAttribute('y2')) / 2;

		my $markid = SBV::DRAW::arrow(20,10,-zh=>0.5,-style=>"fill:$color",-class=>"arrow");
		$parent->line(x1=>$x1,x2=>$x2,y1=>$y1,y2=>$y2,
			style=>"stroke:$color",class=>"hgt",'marker-end'=>"url(#$markid)");
	}
	close FH;
}

#-------------------------------------------------------------------------------
# add dataset in circular tree
#-------------------------------------------------------------------------------
# tree marker
sub _add_circular_tree_marker
{
	my ($dataset,$r,%par) = @_;
	
	my $angle = $dataset->{height} * $par{unitA};
	my $width = $dataset->{width};
	my $polar = $par{polar};
	my $class = $dataset->{border} ? "selector" : "marker";

	foreach my$id(keys %{$dataset->{data}})
	{
		my $fill = $dataset->{data}->{$id};
		my $style = "fill:$fill;";

		my $a = $par{angle}->{$id};
		$polar->prect($r,$a-$angle/2,$r+$width,$a+$angle/2,style=>$style,class=>$class);
	}
}

# add tree bar
sub _add_circular_tree_bar
{
	my ($dataset,$r,%par) = @_;
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};

	my $height = $dataset->{height} * $par{unitH};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my $polar = $par{polar};
	my @color = @{ $dataset->{color} };

	# create x axis 
	my $unitA = $par{unitA};
	my $cx = $polar->{cx};
	my $cy = $polar->{cy};
	my @sum = map { sum($_) } values %{$dataset->{data}};
	my $max = max(\@sum);
	my $scale = SBV::STAT::dividing(0,$max);
	my $axis_group = $parent->group(transform=>"rotate(-$unitA,$cx,$cy)");
	my %axis_par = (parent=>$axis_group,ox=>$cx,oy=>$cy - $r,length=>$width,tick=>$scale,
		side=>"left",start=>0,translate=>0,angle=>-90);
    my $axis = SBV::STONE::AXIS->new(%axis_par);
    $axis->aes(%{$dataset->{axis}});
    $axis->plot;

	foreach my$id(keys %{$dataset->{data}})
	{
		my $rectx = $cx + $r;
		my $recty = $cy - $height/2;
		my $i = 0;
		my $a = $par{angle}->{$id} - 90;
		foreach my$num (@{$dataset->{data}->{$id}})
		{
			my $rectw = nearest 0.01 , ($axis->fetch_dis($num));
			my $color = loop_arr(\@color,$i);
			
			if ($dataset->{bar_type} && $dataset->{bar_type} eq "fan")
			{
				my $r1 = $rectx - $cx;
				my $r2 = $r1 + $rectw;
				my $a1 = $par{angle}->{$id};
				my $a2 = $a1 + $par{unitA};
				my $mid = $a1;
				$a1 = $mid - $par{unitA}*$dataset->{height}/2;
				$a2 = $mid + $par{unitA}*$dataset->{height}/2;
				$polar->fan($r1,$a1,$r2,$a2,style=>"fill:$color;");
			}
			else 
			{
				$parent->rect(x=>$rectx,y=>$recty,width=>$rectw,height=>$height,
				style=>"fill:$color",class=>"marker",transform=>"rotate($a,$cx,$cy)");
			}
			
			$rectx += $rectw;
			$i ++;
		}
	}
}

sub _add_circular_tree_simple_bar
{
	my ($dataset,$r,%par) = @_;	
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};

	my $height = $dataset->{height} * $par{unitH};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my @color = @{ $dataset->{color} };
	my $polar = $par{polar};
	
	# create x axis 
	my $unitA = $par{unitA};
	my $cx = $polar->{cx};
	my $cy = $polar->{cy};
	my @nums = map { $_->[0] } values %{$dataset->{data}};
	my $scale = SBV::STAT::dividing(\@nums,-xtrue=>1);
	my $axis_group = $parent->group(transform=>"rotate(-$unitA,$cx,$cy)");
	my %axis_par = (parent=>$axis_group,ox=>$cx,oy=>$cy - $r,length=>$width,tick=>$scale,
		side=>"left",start=>0,translate=>0,angle=>-90);
    my $axis = SBV::STONE::AXIS->new(%axis_par);
    $axis->aes(%{$dataset->{axis}});
    $axis->plot;
	
	my $i = 0;
	foreach my$id(keys %{$dataset->{data}})
	{
		my $color = loop_arr(\@color,$i);
		my $rectx = $cx + $r;
		my $recty = $cy - $height/2;
		my $num = $dataset->{data}->{$id}->[0];
		my $rectw = nearest 0.01 , ($axis->fetch_dis($num));
		my $rotate = $par{angle}->{$id} - 90;
		$parent->rect(x=>$rectx,y=>$recty,width=>$rectw,height=>$height,
			style=>"fill:$color",class=>"marker",transform=>"rotate($rotate,$cx,$cy)");
		$i ++;
	}
}

sub _add_circular_tree_multi_bar
{
	my ($dataset,$r,%par) = @_;	
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};

	my $height = $dataset->{height} * $par{unitH};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my $polar = $par{polar};
	my @color = @{ $dataset->{color} };
	
	my $cx = $polar->{cx};
	my $cy = $polar->{cy};
	my $unitA = $par{unitA} * 360 / $TWOPI;
	my $axis_group = $parent->group(transform=>"rotate(-$unitA,$cx,$cy)");
	my @values = values %{$dataset->{data}};
	my $bar_num = scalar @{$values[0]};
	my $bar_width = nearest 0.01 , ($width / $bar_num);
	
	for my$index (0 .. $bar_num-1)
	{
		my $color = loop_arr(\@color,$index);
		my @nums = map { $_->[$index] } values %{$dataset->{data}};
		my $scale = SBV::STAT::dividing(\@nums,-xtrue=>1);
		my %axis_par = (parent=>$axis_group,ox=>$cx,oy=>$cy-$r-$index*$bar_width,skip_last_tick=>1,
			,length=>$bar_width,tick=>$scale,side=>"left",start=>0,translate=>0,angle=>-90);
        my $axis = SBV::STONE::AXIS->new(%axis_par);
        $axis->aes(%{$dataset->{axis}});
        $axis->plot;

		foreach my$id(keys %{$dataset->{data}})
		{
			my $rectx = $cx + $r + $index*$bar_width;
			my $recty = $cy - $height/2;
			my $num = $dataset->{data}->{$id}->[$index];
			my $rectw = nearest 0.01 , ($axis->fetch_dis($num));
			my $rotate = $par{angle}->{$id} - 90;
			$parent->rect(x=>$rectx,y=>$recty,width=>$rectw,height=>$height,
					style=>"fill:$color",class=>"marker",transform=>"rotate($rotate,$cx,$cy)");
		}
	}
}

sub _add_circular_tree_circles
{
	my ($dataset,$r,%par) = @_;	
	my $hi = $SBV::conf->{hspace};

	my $height = $dataset->{height} * $par{unitH};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my $polar = $par{polar};
	my @color = @{ $dataset->{color} };
	
	my @values = values %{$dataset->{data}};
	my $circle_num = scalar @{$values[0]};
	my $space = ($width - $circle_num * $height) / ($circle_num - 1);
	my @nums = map { $_->[0] } @values;
	my $max = max(\@nums);
	my $pcx = $polar->{cx};
	my $pcy = $polar->{cy};
	
	for my$index (0 .. $circle_num-1)
	{
		my $color = loop_arr(\@color,$index);
		foreach my$id(keys %{$dataset->{data}})
		{
			my $rotate = $par{angle}->{$id} - 90;
			my $cx = nearest 0.01 , ($pcx + $r + $index * ($space + $height) + $height/2);
			my $cy = $pcy;
			my $r = nearest 0.01 , ($height/2 * $dataset->{data}->{$id}->[$index] / $max); 
			$parent->circle(cx=>$cx,cy=>$cy,r=>$r,style=>"fill:$color",
				class=>"marker",transform=>"rotate($rotate,$pcx,$pcy)");
		}
	}
}

sub _add_circular_tree_boxplot
{
	my ($dataset,$r,%par) = @_;	
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};

	my $height = $dataset->{height} * $par{unitH};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my $polar = $par{polar};
	my @color = @{$dataset->{color}};

	# create x axis 
	my $unitA = $par{unitA};
	my $cx = $polar->{cx};
	my $cy = $polar->{cy};
	my @nums;
	map { splice(@nums,0,0,@$_) } values %{$dataset->{data}};
	my $scale = SBV::STAT::dividing(\@nums);
	my $axis_group = $parent->group(transform=>"rotate(-$unitA,$cx,$cy)");
	my %axis_par = (parent=>$axis_group,ox=>$cx,oy=>$cy-$r,length=>$width,tick=>$scale,
		side=>"left",start=>0,translate=>0,angle=>-90);
    my $axis = SBV::STONE::AXIS->new(%axis_par);
    $axis->aes(%{$dataset->{axis}});
    $axis->plot;
	
	my $i = 0;
	foreach my$id(keys %{$dataset->{data}})
	{
		my $rotate = $par{angle}->{$id};
		my $boxplot_parent = $parent->group(transform=>"rotate($rotate,$cx,$cy)");
		my $color = loop_arr(\@color,$i);
		my @val = @{ $dataset->{data}->{$id} };
		my ($q1,$q2,$q3) = SBV::STAT::quartile(\@val);
		my $iqr = $q3 - $q1;
		my $up = $q3 + 1.5*$iqr;
		my $low = $q1 - 1.5*$iqr;
		
		my ($upval,$lowval,@abnormal);
		foreach (@val){if ($_ >= $low){$lowval = $_;last;}else{push @abnormal , $_;}}
		foreach (reverse @val){if ($_ <= $up){$upval = $_;last;}else{push @abnormal , $_;}}

		my $y2 = $cy;
		my $y1 = $y2 - $height/2;
		my $y3 = $y2 + $height/2;
		
		my $q3x = $cx + $r + $axis->fetch_dis($q3);
		my $q2x = $cx + $r + $axis->fetch_dis($q2);
		my $q1x = $cx + $r + $axis->fetch_dis($q1);
		my $upx = $cx + $r + $axis->fetch_dis($upval);
		my $lowx = $cx + $r + $axis->fetch_dis($lowval);
		my $w = ($q3x-$q1x);

		$boxplot_parent->rect(y=>$y1,x=>$q1x,height=>$height,width=>$w,
			style=>{stroke=>$color,'stroke-width'=>1});
		$boxplot_parent->line(y1=>$y1,x1=>$q2x,y2=>$y3,x2=>$q2x,
			style=>{stroke=>$color,'stroke-width'=>2});
		$boxplot_parent->line(y1=>$y2,y2=>$y2,x1=>$q3x,x2=>$upx,
			style=>{stroke=>$color,'stroke-width'=>1});
		$boxplot_parent->line(y1=>$y2,y2=>$y2,x1=>$q1x,x2=>$lowx,
			style=>{stroke=>$color,'stroke-width'=>1});
		foreach my$i (@abnormal)
		{
			my $ix = $cx + $r + $axis->fetch_dis($i);;
			$boxplot_parent->circle(cy=>$y2,cx=>$ix,r=>2,style=>{fill=>$color,'stroke-width'=>0});
		}

		$i ++;
	}	
}

sub _add_circular_tree_pie
{
	my ($dataset,$r,%par) = @_;	
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};

	my $parent = $par{parent};
	my $polar = $par{polar};
	my @color = @{ $dataset->{color} };
	my $R = $par{unitH} || 20;
	
	foreach my$id(keys %{$dataset->{data}})
	{
		my $line = $SBV::svg->getElementByID("node_$id");
		my $cx = ( $line->getAttribute('x1') + $line->getAttribute('x2') )/ 2;
		my $cy = ( $line->getAttribute('y1') + $line->getAttribute('y2') )/ 2;

		my @vals = @{$dataset->{data}->{$id}};
		my $sum = sum(\@vals);
		my $temp = 0;
		my $group = $parent->group();
		foreach my$i(0 .. $#vals)
		{
			my $color = loop_arr(\@color,$i);
			my %fan = (start=>$temp,color=>$color,r1=>0,class=>'pie',parent=>$group);
			SBV::DRAW::Fan($cx,$cy,$sum,$temp+$vals[$i],$R/2,%fan);
			$temp += $vals[$i];
		}
	}
}

sub _add_circular_tree_heatmap
{
	my ($dataset,$r,%par) = @_;	
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};

	my $angle = $dataset->{height} * $par{unitA};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my $polar = $par{polar};
	my @colors = @{ $dataset->{color} };
	
	my @values = values %{$dataset->{data}};
	my $col_num = scalar @{$values[0]};
	my @nums;
	map { splice(@nums,0,0,@$_) } @values;
	my $max = max(\@nums);
	my $min = min(\@nums);
	my $block_width = $width/$col_num;

	my $scale = $dataset->{scale} || "none";
	
	# fetch the column min and max ( for scale == column )
	my (@cmin,@cmax);
	if ($scale eq "column")
	{
		foreach my$i (0 .. $col_num-1)
		{
			my @temp = map { $_->[$i] } @values;
			push @cmin , min(\@temp);
			push @cmax , max(\@temp);
		}
	}
	
	foreach my$id(keys %{$dataset->{data}})
	{
		my @vals = @{$dataset->{data}->{$id}};
		
		if ($scale eq "row")
		{
			$min = min(\@vals);
			$max = max(\@vals);
		}
		my $a = $par{angle}->{$id};
		foreach my$index(0 .. $#vals)
		{
			if ($scale eq "column")
			{
				$min = $cmin[$index];
				$max = $cmax[$index];
			}

			my ($ratio,$color);

			if ($max != $min)
			{
				$ratio = ($vals[$index]-$min)/($max-$min);
				$color = SBV::Colors::fetch_gradient_color($ratio,@colors);
			}
			else 
			{
				$color = "none";
			}
			
			my $rectr = $r + $index * $block_width;
			$polar->prect($rectr,$a-$angle/2,$rectr+$block_width,$a+$angle/2,style=>"fill:$color",class=>"heatmap");
		}
	}
}

sub _add_circular_tree_connection
{
	my ($dataset,$r,%par) = @_;	
		
}

sub _add_circular_tree_modify
{
	my ($dataset,$r,%par) = @_;	
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};

	my $angle = $dataset->{height} * $par{unitA};
	my $width = $dataset->{width};
	my $parent = $par{parent};
	my $polar = $par{polar};
	my $height = $dataset->{height} * $par{unitH};
	my $cx = $polar->{cx};
	my $cy = $polar->{cy};
	
	foreach my$id(keys %{$dataset->{data}})
	{
		my $a = $par{angle}->{$id};

		if ($dataset->{format} eq "domain")
		{
			$polar->line($r,$a,$r+$width,$a);
			$a = $a * 360 / $TWOPI - 90;
			my @length = map {$_->[0]->[0]} values %{$dataset->{data}};
			my $maxLen = max(\@length);

			foreach my$modify(@{$dataset->{data}->{$id}})
			{
				my ($len,$sta,$end,$shape,$color,$fill,$label) = @$modify;
				my $usex = $polar->{cx} + $r + $sta/$maxLen * $width;
				my $usew = ($end-$sta+1)/$len * $width;
				my $symid = SBV::STONE::SYMBOL::new($shape,
					height=>$height,width=>$usew,fill=>$fill,color=>$color);
				$parent->group(transform=>"rotate($a $cx $cy)")->use(
					x=>$usex,y=>$polar->{cy}-$height/2,width=>$usew,height=>$height,'-href'=>"#$symid");
			}
		}
		elsif ($dataset->{format} eq "symbol")
		{
			my $i = 0;
			$a = $a * 360 / $TWOPI - 90;
			foreach my$modify(@{$dataset->{data}->{$id}})
			{
				my ($shape,$color,$fill,$label) = @$modify;
				my $usex =$polar->{cx} + $r + ($height+$hi) * $i;
				my $usew = $height;
				my $symid = SBV::STONE::SYMBOL::new($shape,height=>$height,width=>$usew,fill=>$fill,color=>$color);
				$parent->group(transform=>"rotate($a $cx $cy)")->use(
					x=>$usex,y=>$polar->{cy}-$height/2,width=>$usew,height=>$height,'-href'=>"#$symid");
				$i ++;
			}
		}
	}
}
# draw circular tree done
#------------------------------------------------------------------------------


#-------------------------------------------------------------------------------
#  Inverted circular tree 
#-------------------------------------------------------------------------------


#  draw Inverted circular tree done
#-------------------------------------------------------------------------------


#-------------------------------------------------------------------------------
#   unrooted tree
#-------------------------------------------------------------------------------
sub unrooted_tree
{
	my ($self,$tree,$conf,$scale_group,$group) = @_;
	my %par;
	
	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};
	
	# load color and leaf labels definition files
	my $defs = _load_defs($conf,$self->{id_trans});
	my @datasets = _load_datasets($conf,$self->{id_trans});
	
	# get the datasets sum width (cantain the internal gap)
	my $dataWidth = 0;
	if ($#datasets >= 0)
	{
		for(@datasets) {
			next if ($_->{type} eq "pie");
			$dataWidth += $_->{width} + 2*$hi;
		}
		$dataWidth += 2*$hi;
	}

	# get the root node
	#my @nodes = $tree->get_root_node->each_Descendent;
	my $rootNode = $tree->get_root_node;
	
	my $x = $conf->{ox};
	my $y = $conf->{oty};

	my $treeL = tree_length($rootNode,$conf);
	my $unit = $conf->{unit} || (split /\s+/ , SBV::STAT::dividing(0,$treeL) )[2];
	my @leaves = $tree->get_leaf_nodes;
	
	my @ids = map { 
		if(defined $defs->{$_->internal_id}->{label}->{font}){
			$defs->{$_->internal_id}->{label}->{font}
		} else { $_->id} 
	} @leaves;
	
	# the unit Angle
	my $unitA = $conf->{angle} / ($#leaves + 1);
	
	# set the radius and root point coord (for unrooted tree)
	my $R = $conf->{tw} > $conf->{th} ? $conf->{th} : $conf->{tw};
	my $r = $conf->{size_ratio} * $R;
	my $cx = $x + $conf->{x_offset}*$conf->{tw};
	my $cy = $y + $conf->{y_offset}*$conf->{th};
	
	# set the unit length 
	# set the unit length 
	my ($id_width,$tree_width);
	
	if ($conf->{tree_width})
	{
		$tree_width = $conf->{tree_width};
		$id_width = $r - 3*$hi - $tree_width - $dataWidth;
		
		my $leaf_font = SBV::Font->fetch_font("leaf");
		my ($font_size,$unit) = $leaf_font->{'font-size'} =~ /(\d+)([a-z]+)/;
		my $raw_id_width = $leaf_font->fetch_max_text_width(\@ids);
		my $new_size = int $font_size*$id_width/$raw_id_width;
		$SBV::allStyle->{text}->{"CLASSleaf"}->{'font-size'} = $new_size;
	}
	else 
	{
		$id_width = SBV::Font->fetch_font("leaf")->fetch_max_text_width(\@ids);
		$tree_width = $r - $id_width - 3*$hi - $dataWidth;
	}

	my $unitL = $tree_width / $treeL;

    my $group_range = $group->g(class=>"range");
    my $group_main  = $group->g(class=>"main");
    my $group_clade = $group->g(class=>"clade");
    my $polar = SBV::Coordinate::POLAR->new($cx,$cy,parent=>$group_main);

	# set the par
	$par{unitH} = $conf->{unit_height};
	$par{unitA} = $unitA;
	$par{unitL} = $unitL;
	$par{idW} = $id_width;
	$par{treeL} = $treeL;
    $par{range_parent} = $group_range;
	$par{parent} = $group_main;
    $par{clade_parent} = $group_clade;
	$par{conf} = $conf;
	$par{rootNode} = $rootNode;
	$par{defs} = $defs;
	$par{r} = $r;
	$par{polar} = $polar;

	# draw branch length scale 
	if ($rootNode->height && ! $conf->{ignore_branch_length} && $conf->{show_distance_scale})
	{
		# get font of scale
		my $font = SBV::Font->fetch_font("scale");
		my $textH = $font->fetch_text_height;
		my $x2 = nearest 0.01 , ($x+$unit*$unitL);
		$y = $y + $textH/2;
		$scale_group->line(x1=>$x,x2=>$x2,y1=>$y,y2=>$y,class=>"scale");
		$scale_group->text(x=>$x2 + $hi,y=>$y+$textH/2,class=>"scale")->cdata($unit);
        $y += 4;
	}
    

	# the main part
    # draw tree 
	my $rotation = $conf->{rotation} || 0;
	_add_unrooted_tree_clade($rootNode,$polar,$rotation,\%par);

	# add the HGT 
	if (my$hgt = $conf->{definition}->{hgt})
	{
		_add_HGT_arrow($hgt,$self->{id_trans},$group);
	}
    
    # transform the unrooted tree to suitable position
    my @leaf_lines = $group->getElements("line");
    my (@linex,@liney);
    foreach my $line (@leaf_lines){
        my $attrs = $line->getAttributes();
        next unless $attrs->{class} eq "leaf";
        push @linex , $attrs->{x1};
        push @linex , $attrs->{x2};
        push @liney , $attrs->{y1};
        push @liney , $attrs->{y2};
    }
    
    my $groupx1 = min(\@linex);
    my $groupx2 = max(\@linex);
    my $groupy1 = min(\@liney);
    my $groupy2 = max(\@liney);
    my $groupw  = $groupx2 - $groupx1;
    my $grouph  = $groupy2 - $groupy1;
    
    my $tx = $groupx1 - $x;
    my $ty = $groupy1 - $y;
    my $sx = $conf->{tw} / $groupw;
    my $sy = ($conf->{oy} - $y) / $grouph;
    $group->setAttribute("transform","translate($x,$y) scale($sx,$sy) translate(-$groupx1,-$groupy1)");

	# now not support datasets for unrooted tree
    return;

	# add the datasets 
	my %func = (
		marker     => \&_add_unrooted_tree_marker,
		bar        => \&_add_unrooted_tree_bar,
		simple_bar => \&_add_unrooted_tree_simple_bar,
		multi_bar  => \&_add_unrooted_tree_multi_bar,
		circles    => \&_add_unrooted_tree_circles,
		boxplot    => \&_add_unrooted_tree_boxplot,
		pie        => \&_add_unrooted_tree_pie,
		connection => \&_add_unrooted_tree_connection,
		heatmap    => \&_add_unrooted_tree_heatmap,
		modify     => \&_add_unrooted_tree_modify
	);
	my $dataR = $par{idR} + $par{idW} + 2*$hi;
	
	foreach my $dataset(@datasets)
	{
		&{$func{$dataset->{type}}}($dataset,$dataR,%par);
		$dataR += $dataset->{width} + $hi * 2 if ($dataset->{type} ne "pie");
	}
}

sub _add_unrooted_tree_clade
{
	my ($root,$polar,$a,$par) = @_;
	
	my $unitL = $par->{unitL};
	my $unitA = $par->{unitA};
	my $parent = $par->{parent};
    my $range  = $par->{range_parent};
    my $clade  = $par->{clade_parent};
	my $conf = $par->{conf};
	
	my $rootL = nearest 0.01 , (_get_branch_length($root,$conf) * $unitL);
	my @nodes = $root->get_all_Descendents;
	my @leaves = grep { $_->is_Leaf } @nodes;
	my $sumA = $unitA * ($#leaves);
	
	if ($root != $par->{rootNode})
	{
		my $line = $polar->line(0,$a+$sumA/2,$rootL,$a+$sumA/2,class=>"clade",id=>"node_" . $root->internal_id);
		
		# branch length
		_add_unrooted_branch_length($root,0,$rootL,$a,$par);
		# bootstrap
		_add_unrooted_bootstrap($root,$rootL,$a+$sumA/2,$line,$par);
		
		# deal the definition
		if (my$def = $par->{defs}->{$root->internal_id})
		{
			# $line->setAttribute("style","stroke:$def->{clade}->{color}") if ($def->{clade});
			if ($def->{clade}){
				$polar->parent($clade);
		        $polar->line(0,$a+$sumA/2,$rootL,$a+$sumA/2,class=>"clade",id=>"re_node_" . $root->internal_id);
				$polar->parent($parent);
            }

            if ($def->{range})
			{
				my $defconf = $conf->{'definition'};
				my $style = "fill:$def->{range}->{color};stroke:$def->{range}->{color}";
				my $theta1 = $a + $sumA/2 - $unitA/2;
				my $theta2 = $a + $sumA/2 + $unitA/2;
				$polar->parent($range);
				$polar->fan(0,$theta1,$rootL,$theta2,class=>"range",style=>$style);
				$polar->parent($parent);
			}
		}
		
		# create new polar coord
		my ($cx,$cy) = $polar->polar2pos($rootL,$a+$sumA/2,"angle");
		$polar = SBV::Coordinate::POLAR->new($cx,$cy,parent=>$parent);
		$par->{polar} = $polar;
	}
	
	my @sons  = $root->each_Descendent;
	my $tempA = $a;
	foreach my $i (0 .. $#sons)
	{
		my $son = $sons[$i];
		if ($son->is_Leaf)
		{
			_add_unrooted_tree_leaf($son,$polar,$tempA,$par);
			$tempA += $unitA;
		}
		else
		{
			my $leftA = _add_unrooted_tree_clade($son,$polar,$tempA,$par);
			$tempA += $leftA + $unitA;
		}
	}

	return $sumA;
}

sub _add_unrooted_tree_leaf
{
	my ($leaf,$polar,$a,$par) = @_;
	my $conf = $par->{conf};
	my $unitL = $par->{unitL};
	my $unitA = $par->{unitA};
	my $hi = $SBV::conf->{hspace};
	my $font = SBV::Font->fetch_font("leaf");
	my $textH = $font->fetch_text_height;
	my $defs = $par->{defs};
	my $parent = $par->{parent};
    my $clade  = $par->{clade_parent};
    my $range  = $par->{range_parent};

	
	my $leafL = nearest 0.01 , (_get_branch_length($leaf,$conf) * $unitL);
	$leafL = 0 if ($leafL < 0);
	my $leafLine = $polar->line(0,0,$leafL,$a,class=>"leaf",id=>"node_" . $leaf->internal_id);
	my $leafText = $polar->text($leafL+$hi,$a,$textH/2,$leaf->id,class=>"leaf") if ($conf->{show_leaves_name});
	
	# branch length
	_add_unrooted_branch_length($leaf,0,$leafL,$a,$par);

	# deal the definition
	if (my$def = $defs->{$leaf->internal_id})
	{
		if ($def->{clade})
		{
			#$leafLine->setAttribute("style","stroke:$def->{clade}->{color}");
			$polar->parent($clade);
	        $polar->line(0,0,$leafL,$a,class=>"leaf",style=>"stroke:$def->{clade}->{color}",id=>"re_node_" . $leaf->internal_id);
			$polar->parent($parent);
		}

		if ($def->{label} && $leafText)
		{
			if (defined $def->{label}->{font})
			{
				my $label = $def->{label}->{font};
				$leafText->setAttribute("-cdata",$label);
			}

			if ($def->{label}->{color})
			{
				$leafText->setAttribute("style","fill:$def->{label}->{color}");
			}
		}
		
		if ($def->{range})
		{
			my $defconf = $conf->{'definition'};
			my $style = "fill:$def->{range}->{color};stroke:$def->{range}->{color}";
			my $textW = 0;
            if ($leafText){
			    my $label = $leafText->getAttribute("-cdata");
                $textW = $font->fetch_text_width($label);
            }
			my $theta1 = $a - $unitA/2;
			my $theta2 = $a + $unitA/2;
			my $r2 = $leafL + $textW + $hi;
			my $r1 = $defconf->{cover} eq "label" ? $leafL + $hi : 0;
			$polar->parent($range);
			$polar->fan($r1,$theta1,$r2,$theta2,class=>"range",style=>$style);
			$polar->parent($parent);
		}
	}
}

*_add_unrooted_branch_length = \&_add_circular_branch_length;

# add bootstrap in unrooted tree
sub _add_unrooted_bootstrap
{
	my ($node,$r,$a,$line,$par) = @_;
	
	my $parent = $par->{parent};
	my $polar = $par->{polar};
	my $conf = $par->{conf};
	return if (! defined $conf->{bootstrap});
	
	my $bsconf = $conf->{bootstrap};
	my $bootstrap = $node->bootstrap;
	return unless defined $bootstrap;
	
	$bootstrap *= 100 if ($bootstrap <= 1);
	$bootstrap = int $bootstrap;
	
	my $font = SBV::Font->fetch_font("bootstrap");
	my $textH = $font->fetch_text_height;

	my $hi = $SBV::conf->{hspace};
	my $vi = $SBV::conf->{vspace};

	# draw bootstrap text
	if ($bsconf->{text})
	{
		my $threshold = $bsconf->{threshold} || 60;
		return if ($bootstrap < $threshold);
		
		my $textW = $font->fetch_text_width($bootstrap);
		$polar->text($r-$textW-$hi,$a,$textH+$vi,$bootstrap,class=>"bootstrap");
	}
	# draw symbol
	elsif ($bsconf->{symbol})
	{
		my $symbol = _get_symbol($bsconf->{symbol},$bootstrap);
		return if ($symbol eq "");

		my $textW = $font->fetch_text_width($symbol);
		$polar->text($r-$textW-$hi,$a,$textH+$vi,$symbol,class=>"bootstrap");
	}
	# draw color 
	elsif ($bsconf->{color})
	{
		my $color = _get_color($bsconf->{color},$bootstrap);
		$line->setAttribute("style","stroke:$color");
	}
}

# draw unrooted tree done
#-------------------------------------------------------------------------------

#--------------------------------------------------------
# sub functions for public 
#--------------------------------------------------------
# get the tree top longest branch length
# used to align the branch id texts
sub tree_length
{
	my $rootNode = shift;
	my $conf = shift;
	
    return $rootNode->height if (defined $rootNode->height && ! $conf->{ignore_branch_length});

	my $hash;
	$hash = _tree_depth($rootNode,0,$hash);
	my @len = values %$hash;
	return max(\@len) + 1;
}

sub max_height {
    my $rootNode = shift;
    my @lengths;
    foreach my $node ( $rootNode->get_all_Descendents() ) {
        push @lengths , $node->branch_length;
    }
    
    @lengths = sort {$b<=>$a} grep { $_ > 0.01 } @lengths;
    print "@lengths\n";
    my $sum = sum(\@lengths);
    print $sum , "\n";
}

sub _tree_depth
{
	my $rootNode = shift;
	my $depth = shift;
	my $hash = shift;

	foreach my$node($rootNode->each_Descendent)
	{
		if ($node->is_Leaf)
		{
			$hash->{$node->internal_id} = $depth + 1;
		}
		else
		{
			$hash = _tree_depth($node,$depth+1,$hash);
		}
	}

	return $hash;
}

# get the branch length of node, 
# if not defined, will return 1 (2 for leaf node)
# if ignore_branch_length is set, will return 1 (2 for leaf node)
sub _get_branch_length
{
	my ($node,$conf) = @_;

	my $bl = 0;
	if ($conf->{ignore_branch_length} || ! defined $node->branch_length)
	{
		$bl = $node->is_Leaf ? 2 : 1;
	}
	else
	{
		$bl = $node->branch_length;
	}
	return $bl;
}

# get the bootstrap symbol 
sub _get_symbol
{
	my ($str,$bs) = @_;
	my @arr = split /\s+/ , $str;

	map {
		my ($sta,$end,$symbol) = split /,/ , $_;
		return $symbol if ($sta<$bs && $bs<=$end);
	} @arr;

	return "";
}

# get the bootstrap symbol 
sub _get_color
{
	my ($str,$bs) = @_;
	my @arr = split /\s+/ , $str;

	map {
		my ($sta,$end,$color) = split /,/ , $_;
		return SBV::Colors::fetch_color($color) if ($sta<$bs && $bs<=$end);
	} @arr;

	return "";
}

# load definition files
sub _load_defs
{
	my $conf = shift;
	my $trans = shift;
	my $defs;
	
	my $align = $conf->{align};
	$conf = $conf->{definition};

	return {} if (! $conf);
	
	$defs = read_tree_color_defs($conf->{color},$trans,$align,$defs) if ($conf->{color});
	$defs = read_tree_leaf_defs($conf->{leaf},$trans,$defs) if ($conf->{leaf});
	
	return $defs;
}

# load datasets files
sub _load_datasets
{
	my ($conf,$trans) = @_;
	my @datasets = ();
	
	return () if (! $conf->{datasets});
	$conf = SBV::CONF::fetch_first_conf("datasets",$conf,0);

	return () if (! $conf->{dataset});
	

	# init parameter
	if (ref $conf->{dataset} eq "ARRAY")
	{
		foreach my$subconf(@{$conf->{dataset}})
		{
			my $dataset = _load_dataset($conf,$subconf,$trans);
			push @datasets , $dataset if (defined $dataset);
		}
	}
	elsif (ref $conf->{dataset} eq "HASH")
	{
		my $dataset = _load_dataset($conf,$conf->{dataset},$trans);
		push @datasets , $dataset if (defined $dataset);
	}

	return @datasets;
}

sub _load_dataset
{
	my ($conf,$subconf,$trans) = @_;
	my $dataset = undef;

	if (! defined $subconf->{file})
	{
		WARN("the dataset file is not exists, will be skiped!");
		return $dataset;
	}
	
	my $file = check_path($subconf->{file});

	# init parameter
	my $type  = $subconf->{type} || $conf->{type};
	my $format = $subconf->{format} || $conf->{format}; # just for modify
	my $color = $subconf->{color} || $conf->{color};
	my $width = $subconf->{width} || $conf->{width};
	my $height = $subconf->{height} || $conf->{height};
	my $header = $subconf->{header} || $conf->{header};
	my $show = exists $subconf->{show} ? $subconf->{show} : 1;
	my $scale = $subconf->{scale} || $conf->{scale};
	my $bar_type = $subconf->{bar_type} || $conf->{bar_type}; # just for bar 
    
    my $axis = {bone=>1,skip_first_tick=>0,skip_last_tick=>0,start=>0,translate=>0,side=>"left",show=>0};
    if ($subconf->{axis}){
        foreach my$key (keys %{$subconf->{axis}}){
            $axis->{$key} = $subconf->{axis}->{$key};
        }
    }

	#my @color = split /[\s\,\t]+/ , $color;
	#@color = map { SBV::Colors::fetch_color($_) } @color;
	my @color = SBV::Colors::fetch_brewer_color($color);
    $dataset->{type} = $type;
	$dataset->{color} = \@color;
	$dataset->{width} = $width;
	$dataset->{height} = $height;
	$dataset->{format} = $format;
	$dataset->{show} = $show;
	$dataset->{scale} = $scale;
	$dataset->{bar_type} = $bar_type;
    $dataset->{axis} = $axis;

	# read the dataset file 
	if ($type eq "marker")
	{
		my $data = SBV::DATA::Frame->new($file,header=>$header,rownames=>1);
		my @rownames = $data->rownames;
		
		$dataset->{border} = $subconf->{border} || 0;
		
		my @allVal = map { $data->{row}->{$_}->[0] } @rownames;
		my $max = $subconf->{gradient} ? max(\@allVal) : 0;
		my $min = $subconf->{gradient} ? min(\@allVal) : 0;

		foreach my$name(@rownames)
		{
			my $val = $data->{row}->{$name}->[0];
			
			if ($subconf->{gradient})
			{
				$val = SBV::Colors::fetch_gradient_color(($val-$min)/($max-$min),$color[0],"#ffffff");
			}
			else
			{
				$val = SBV::Colors::fetch_color ($val);
			}
			
			my @inids = _trans_key($name,"label",$trans);
			map { $dataset->{data}->{$_} = $val } @inids;
		}
	}
	elsif ($type eq "pie")
	{
		my $data = SBV::DATA::Frame->new($file,header=>$header,rownames=>1);
		my @rownames = $data->rownames;
		
		foreach my$name(@rownames)
		{
			my @inids = _trans_key($name,"pie",$trans);
			map { $dataset->{data}->{$_} = $data->{row}->{$name} } @inids;
		}
	}
	elsif ($type eq "modify")
	{
		my $data = SBV::DATA->new(-file=>$file,-format=>$format);
		my @rownames = $data->names;
		$dataset->{bgline} = $subconf->{bgline} || 0;

		foreach my$name(@rownames)
		{
			my @inids = _trans_key($name,"label",$trans);
			next if ($#inids > 0);
			map { $dataset->{data}->{$_} = $data->{$name} } @inids;
		}
	}
	elsif ($type eq "heatmap")
	{
		my $data = SBV::DATA::Frame->new($file,header=>$header,rownames=>1);
		my @rownames = $data->rownames;
		
		$data->scale(scale=>$scale);
		foreach my$name(@rownames)
		{
			my @inids = _trans_key($name,"label",$trans);
			map { $dataset->{data}->{$_} = $data->{row}->{$name} } @inids;
		}
	}
	elsif ($type eq "boxplot")
	{
		my $data = SBV::DATA->new(-file=>$file,-format=>$format);
		my @rownames = $data->names;

		foreach my$name(@rownames)
		{
			my @inids = _trans_key($name,"label",$trans);
			next if ($#inids > 0);
			map { $dataset->{data}->{$_} = $data->{$name} } @inids;
		}
	}
	else
	{
		my $data = SBV::DATA::Frame->new($file,header=>$header,rownames=>1);
		my @rownames = $data->rownames;
		foreach my$name(@rownames)
		{
			my @inids = _trans_key($name,"label",$trans);
			map { $dataset->{data}->{$_} = $data->{row}->{$name} } @inids;
		}
	}

	return $dataset;
}

# trans the key id to internal_id
sub _trans_key
{
	my ($key,$type,$trans,$align) = @_;
	#$align = 1 if (! defined $align);

	if ($key =~ /(.+)\|(.+)/) # the key is two id
	{
		my $node1 = $trans->{$1};
		my $node2 = $trans->{$2};
		my $lca   = get_lca($node1,$node2);

		my @subNodes = $lca->get_all_Descendents;
		my @leaves = grep {$_->is_Leaf} @subNodes;

		if ($type eq "clade")
		{
			my @internal_ids = map {$_->internal_id} @subNodes;
			push @internal_ids , $lca->internal_id;
			return @internal_ids;
		}
		elsif ($type eq "range")
		{
			if ($align == 1)
			{
				return $lca->internal_id;
			}
			else
			{
				my @internal_ids = map {$_->internal_id} @leaves;
				return @internal_ids;
			}
		}
		elsif ($type eq "label")
		{
			my @internal_ids = map {$_->internal_id} @leaves;
			return @internal_ids;
		}
		else # HGT
		{
			return $lca->internal_id;
		}
		return ();
	}
	elsif ($trans->{$key}) # the key is id, return internal_id
	{
		return ($trans->{$key}->internal_id);
	}
	else # the key is internal id
	{
		return ($key);
	}
}

#-------------------------------------------------------------------------------
#  Name: read_tree_color_defs
#  Func: read the tree color definition file
#  The file should be tab separated plain text file with the following fields:
#  NODE_ID	TYPE	COLOR	[LABEL]
#-------------------------------------------------------------------------------
sub read_tree_color_defs
{
	my ($file,$trans,$align,$res) = @_;
	$file = check_path($file);
	
	open FH,$file or die "can't open file $file $!";
	while(<FH>)
	{
		next if (/^#/);
		chomp;
		next if ($_ eq "");
		my @arr = split /\t/;
		my @internal_ids = _trans_key($arr[0],$arr[1],$trans,$align);
		$arr[2] = SBV::Colors::fetch_color($arr[2]);
		
		if (2 == $#arr)
		{
			map { $res->{$_}->{$arr[1]}->{color} = $arr[2]; } @internal_ids;
		}
		elsif (3 == $#arr)
		{
			map { $res->{$_}->{$arr[1]}->{color} = $arr[2]; } @internal_ids;
			map { $res->{$_}->{$arr[1]}->{label} = $arr[3]; } @internal_ids;
		}
		else
		{
			WARN('colnum_num_err');
			next;
		}
	}
	close FH;
	
	return $res;
}

#-------------------------------------------------------------------------------
#  Name: read_tree_leaf_defs
#  Func: read tree leaf definition file, used to set the leaf labels' text, font 
#  style and font weight
#-------------------------------------------------------------------------------
sub read_tree_leaf_defs
{
	my ($file,$trans,$res) = @_;
	$file = check_path($file);

	open FH,$file or die "can't open file $file $!";
	while(<FH>)
	{
		next if (/^#/);
		chomp;
		next if ($_ eq "");
		my @arr = split /\t/;
		
		my $font = "";
		my $style = "";
		my $name = $arr[0];
		if ($arr[1]){ $font = $arr[1] }
		if ($arr[2]){ $style = $arr[2] }

		my @inids = _trans_key($name,'font',$trans);
		map { 
			$res->{$_}->{label}->{font} = $font; 
			$res->{$_}->{label}->{style} = $style if ($style);
		} @inids;

	}
	close FH;

	return $res;
}

#-------------------------------------------------------------------------------
#  Name: reroot_tree
#  Func: re define the tree root (reset the outgroup)
#-------------------------------------------------------------------------------
sub reroot_tree {
    my ($tree,$node) = @_;
    
    my $root = $tree->get_root_node;
    my ($ancestor,@collaterals) = _identify_child($root,$node);
    my $father = _fetch_father($root);
    
    $root->remove_all_Descendents; # set new null root node
    $root->add_Descendent($node);
    my $father_node = $father->{$node};
    $father_node->remove_Descendent($node);
    $root->add_Descendent($father_node);

    while($father_node != $ancestor)
    {
        $node = $father_node;
        $father_node = $father->{$node} or last;
        $node->add_Descendent($father_node);
        $father_node->remove_Descendent($node);
    }

    for (@collaterals) { $father_node->add_Descendent($_) };
    
    return $tree;
}

sub reroot_tree_bak
{
	my ($tree,$node) = @_;

	#my @nodes = $tree->get_root_node->each_Descendent;
	my $root = $tree->get_root_node;
	#return $tree if $root eq $node;

	my ($ancestor,$collateral) = _identify_child($root,$node);

	my $father = _fetch_father($root);
	my $clade = $father->{$node};
	$root->remove_all_Descendents; # set new null root node
	$root->add_Descendent($node); # add node to new root 
	$root->add_Descendent($clade);

	while($clade != $ancestor)
	{
		$clade->add_Descendent($father->{$clade});
		$clade = $father->{$clade};
	}
	$clade->add_Descendent($collateral);
	
	return $tree;
}

sub _fetch_father {
    my %father = ();
    my $clade = shift;
    
    my @first_nodes = $clade->each_Descendent;
    foreach (@first_nodes){
        $father{$_} = $clade if ($_->is_Leaf);
    }

    my @nodes = $clade->get_all_Descendents;
    foreach my $node (@nodes){
        next if $node->is_Leaf;

        my @children = $node->each_Descendent;
        foreach my $child (@children){
            $father{$child} = $node;
        }
    }
    
    return \%father;
}

sub _fetch_father_bak
{
	my @parent = @_;
	my %hash;
	
	while($#parent >= 0)
	{
		my @newpar;
		foreach my$clade (@parent)
		{
			my @children = $clade->each_Descendent;
			for my$child(@children)
			{
				$hash{$child} = $clade;
				push @newpar , $child if (! $child->is_Leaf);
			}
		}
		@parent = @newpar;
	}

	return \%hash;
}

sub _identify_child {
    my ($root,$outgroup) = @_;

    my @first_nodes = $root->each_Descendent;
    my $ancestor = "";
    my @collaterals = ();

    foreach my $node (@first_nodes){
        if ( ($ancestor eq "") && (1 == isChild($node,$outgroup) )){
            $ancestor = $node;
        }else{
            push @collaterals , $node;
        }
    }
    
    return ($ancestor , @collaterals);
}

sub isChild {
    my ($clade,$node) = @_;
    my $flag = 0;

    if ($clade->is_Leaf && $clade == $node){
        $flag = 1;
    }elsif ($clade->is_Leaf && $clade != $node){
        $flag = 0;
    }else{
        my @nodes = $clade->get_all_Descendents();
        foreach (@nodes){
            if ($_ == $node){
                $flag = 1;
                last;
            }
        }
    }

    return $flag;
}

sub _identify_child_bak
{
	my ($root,$node) = @_;
	
	my ($node1,$node2) = $root->each_Descendent;

	my @nodes = $node1->get_all_Descendents;
	push @nodes , $node1;

	my $flag = 0;
	for (@nodes) 
	{ 
		if ($_ == $node )
		{ 
			$flag = 1; last; 
		}
	}
	
	if (1 == $flag)
	{
		return ($node1,$node2);
	}
	else
	{
		return ($node2,$node1);
	}
}

sub get_lca
{
	my ($node1,$node2) = @_;
	my $lca;

	my @parents1;
	my @parents2;
	while(my $parent = $node1->ancestor){ push @parents1 , $parent; $node1=$parent; }
	while(my $parent = $node2->ancestor){ push @parents2 , $parent; $node2=$parent; }
	@parents1 = reverse @parents1;
	@parents2 = reverse @parents2;
	
	my $len = min([$#parents1,$#parents2]);
	for my $i (0 .. $len)
	{
		if ($parents1[$i] eq $parents2[$i])
		{
			$lca = $parents1[$i];
		}
		else
		{
			last;
		}
	}

	return $lca;
}
