package SBV::DRAW;
#------------------------------------------------+
#    [APM] This moudle is generated by amp.pl    |
#    [APM] Creat time: 2013-05-15 10:45:56       |
#------------------------------------------------+
=pod

=head1 Name

SBV::DRAW

=head1 Synopsis

This module is not meant to be used directly

=head1 Feedback

Author: Peng Ai
Email:  aipeng0520@163.com

=head1 Version

Version history

=head2 v1.0

Date: 2013-05-15 10:45:56

=cut

use strict;
use warnings;
require Exporter;
our @ISA = qw(Exporter);
our @EXPORT    = qw(axis);

use Math::Round;
use FindBin;

use lib "$FindBin::RealBin";
use lib "$FindBin::RealBin/../";
use lib "$FindBin::RealBin/lib";
use lib "$FindBin::RealBin/../lib";

use SBV;
use SBV::DEBUG;
use SBV::CONF;
use SBV::Font qw(textWidth textHeight);
use SBV::Constants;
use SBV::STAT;
use SBV::Colors;
use SBV::STONE::FILTER;

sub polyline;
sub points;
sub legend;
sub symbol;
sub Fan;
sub mirror;

# draw polyline
sub polyline
{
	my $xcor = shift;
	my $ycor = shift;
	my %par;
	
	my $color = $par{color} || "#000";
	my $stroke_width = defined $par{stroke_width} ? $par{stroke_width} : 1;
	my $parent = $par{parent} || $SBV::svg;

	my $points = $parent->get_path(x=>$xcor,y=>$ycor,-type=>'polyline');
	$parent->polyline(%$points,fill=>'none',style=>{stroke=>$color,'stroke-width'=>$stroke_width});
}

# draw multi symbol
sub points
{
	my $xcor = shift;
	my $ycor = shift;
	my $symid = shift;
	my $conf = shift;
	my $parent = shift || $SBV::svg;
	
	my $w = $conf->{symbol_width};
	my $h = $conf->{symbol_height};

	my $points = $parent->group(id=>"points" . $SBV::idnum, class => 'symbol');
	$SBV::idnum ++;
	
	if (ref $symid eq "")
	{
		$symid = [$symid];	
	}

	map { 
		my $id = loop_arr($symid,$_);	
		$points->group()->use(x=>$xcor->[$_]-$w/2,y=>$ycor->[$_]-$h/2,
		width=>$w,height=>$h,'-href'=>"#$id"); 
	} 0 .. $#$xcor;

}

# draw area/polygon
sub area 
{
	my ($xcor,$ycor,%param) = @_;

	my $color = $param{color} || "000";
	my $fill = $param{fill} || "000";
	my $swidth = exists $param{stroke_width} ? $param{stroke_width} : 1;
	my $parent = $param{parent} || $SBV::svg;
	my $opacity = exists $param{opacity} ? $param{opacity} : 1;
	$color = SBV::Colors::fetch_color($color);
	$fill = SBV::Colors::fetch_color($fill);

	my $points = $parent->get_path(x=>$xcor,y=>$ycor,-type=>'polygon');
	$parent->polygon(%$points,style=>{'stroke-width'=>$swidth,stroke=>$color,fill=>$fill,'fill-opacity'=>$opacity});
} ## --- end sub area

# add path 
sub path
{
	my ($pathd,%param) = @_;
	
	my $color = $param{color} || "000";
	my $fill = $param{fill} || "000";
	my $swidth = exists $param{stroke_width} ? $param{stroke_width} : 1;
	my $parent = $param{parent} || $SBV::svg;
	my $opacity = exists $param{opacity} ? $param{opacity} : 1;
	$color = SBV::Colors::fetch_color($color);
	$fill = SBV::Colors::fetch_color($fill);
	
	$parent->path(d=>$pathd,style=>{'stroke-width'=>$swidth,stroke=>$color,fill=>$fill,'fill-opacity'=>$opacity});
}

#===  FUNCTION  ================================================================
#         NAME: legend
#      PURPOSE: draw legend for figure
#   PARAMETERS: loacation, text type col pch parent conf [title] [lineL]
#      RETURNS: legend group in parent
#  DESCRIPTION: 
#       THROWS: no legend text
#     COMMENTS: none
#     SEE ALSO: n/a
#===============================================================================
sub legend
{
	my ($x,$y);

	# legend param
	my %param = @_;
	my $res = {};
	
	my $parent = $param{parent} || $SBV::svg;
	my $pconf = $param{conf} || $SBV::conf;

	# legend location (can be specified word 
	# which defined in CONF.pm fetch_xy funtion)
	my $loc = $param{location} || $pconf->{location};
	$loc = "topright" if (! defined $loc);
	return 1 if ($loc eq "none");
	
	# fetch legend text
	my $text = $param{text};
	ERROR('legend_text_err') if (! $text);

	if ($pconf->{text})
	{
		my @temp = split /\s+/ , $pconf->{text};
		@$text = map { $temp[$_] } 0 .. $#$text;
	}

	my $types = $param{type};
	my $cols = $param{col};
	my $pchs = $param{pch};

	ERROR('legend_no_types_err') if (! defined $types);
	ERROR('legend_no_cols_err') if (! defined $cols);
	ERROR('legend_no_pchs_err') if (! defined $pchs);
	
	my $title = $param{title} || $pconf->{title};
	my $lineL = $pconf->{'linelen'};
	
	# legend size 
	my $hi = $SBV::conf->{'hspace'};
	my $vi = $SBV::conf->{'vspace'};
	
	# legend font 
	my $font = SBV::Font->fetch_font('CLASSlegend');
	my $textH = $font->fetch_text_height;
	my $textW = $font->fetch_max_text_width($text);

	# num of legend text
	my $num = scalar @$text;
	
	# legend height
	my $legendH = $num*($textH+$vi) + $vi;
	$legendH += $textH+$vi if (defined $pconf->{title});
	
	# get the symbol width
	my $symbol_len = $textH;
	for (@$types)
	{
		if ($_ ne "p")
		{
			$symbol_len = $lineL;
			last;
		}
	}
	
	# legend width
	my $legendW = $textW + 3*$hi + $symbol_len;

	if ($title)
	{
		my $titleW = $font->fetch_text_width($title) + 2*$hi;
		$legendW = $titleW if ($titleW > $legendW);
	}
	$res->{width} = $legendW;
	
	# get x,y coordinate
	my @temp = split /\s+/ , $loc;
	if (@temp == 2)	
	{
		($x,$y) = @temp;	
	}
	else
	{
		($x,$y) = SBV::CONF::fetch_xy($loc,$legendW,$legendH,$pconf);
		$x -= $legendW if($loc eq "outright");
	}
	
	# re def legend conf of location info
	$pconf->{ox} = $x;
	$pconf->{oty} = $y;
	$pconf->{tw} = $legendW;
	$pconf->{th} = $legendH;
	
	# init legend group
	my $legend = $parent->group(id=>"legend$SBV::idnum",class=>"legend");
	$SBV::idnum ++;
	
	# draw legend background and border
	background($pconf,$legend);
	
	# draw legend title
	if (defined $title)
	{
		my $titleW = $font->fetch_text_width($title);
		my $titleX = $x + $hi + $legendW/2 - $titleW/2;
		#my $titleX = $x + $hi;
		my $titleY = $y + $vi + $textH;
		$y = $titleY;
		$legend->text(x=>$titleX,y=>$titleY,class=>"legend_title")->cdata($title);
	}

	map {
		my $textX = $x + 2*$hi+$symbol_len;
		my $textY = $y + ($vi+$textH)*($_ + 1);
		$legend->text(x=>$textX,y=>$textY)->cdata($text->[$_]);
		
		my $type = loop_arr($types,$_);
		my $col = loop_arr($cols,$_);
		my $pch = loop_arr($pchs,$_);
		
		my $symbolX = $x + $hi;
		my $symbolY = $y + ($vi+$textH)*$_ + $vi;
		if ($type eq "p")
		{
			my $symid = SBV::STONE::SYMBOL::new($pch,fill=>$col);
			$legend->group()->use(x=>$symbolX+$symbol_len/2-$textH/2,y=>$symbolY,
				width=>$textH,height=>$textH,
				'-href'=>"#$symid");
		}
		elsif ($type eq "b")
		{
			
		}
		elsif ($type eq "c")
		{
			
		}
		elsif ($type eq "o")
		{
			$legend->line(x1=>$symbolX,x2=>$symbolX+$symbol_len,
				y1=>$symbolY+$textH/2,y2=>$symbolY+$textH/2,
				style=>{stroke=>$col});
			
			my $symid = SBV::STONE::SYMBOL::new($pch,fill=>$col);
			$legend->group()->use(x=>$symbolX+$symbol_len/2-$textH/2,y=>$symbolY,
				width=>$textH,height=>$textH,
				'-href'=>"#$symid");
		}
		elsif ($type eq "a" || $type eq "A" || $type eq "H" || $type eq "h")
		{
			my $symid = SBV::STONE::SYMBOL::new(0,fill=>$col);
			$legend->group()->use(x=>$symbolX+$symbol_len/2-$textH/2,y=>$symbolY,
				width=>$textH,height=>$textH,
				'-href'=>"#$symid");
		}
		else # s S l
		{
			$legend->line(x1=>$symbolX,x2=>$symbolX+$symbol_len,
				y1=>$symbolY+$textH/2,y2=>$symbolY+$textH/2,
				style=>{stroke=>$col});
		}
	} 0 .. $#$text;

	return $res;
}

# return the width of legend
sub legend_width
{
	my %param = @_;
	my $pconf = $param{conf} || $SBV::conf;
	my $types = $param{type};
	my $text = $param{text} || ERROR('legend_text_err');
	my $title = $param{title};
	my $hi = $SBV::conf->{hspace};
	
	# legend font 
	my $font = SBV::Font->fetch_font('CLASSlegend');
	my $textH = $font->fetch_text_height;
	my $textW = $font->fetch_max_text_width($text);
	my $lineL = $pconf->{'linelen'};
	
	# get the symbol width
	my $symbol_len = $textH;
	for (@$types)
	{
		if ($_ ne "p")
		{
			$symbol_len = $lineL;
			last;
		}
	}
	
	# legend width
	my $legendW = $textW + 3*$hi + $symbol_len;

	if ($title)
	{
		my $titleW = $font->fetch_text_width($title) + 2*$hi;
		$legendW = $titleW if ($titleW > $legendW);
	}
	
	return $legendW;
}

#===  FUNCTION  ================================================================
#         NAME: Fan
#      PURPOSE: Draw Fan shaped image
#   PARAMETERS: cx, cy, size, start, end, r1, r2, color
#      RETURNS: none
#  DESCRIPTION: add Fan shaped element in SVG
#       THROWS: no exceptions
#     COMMENTS: none
#     SEE ALSO: n/a
#===============================================================================
sub Fan
{
	my $cx = shift;
	my $cy = shift;
	my $size = shift;
	my $end = shift;
	my $r2 = shift;

	my %param = @_;

	my $sta = $param{start} || 0;
	my $r1 = $param{r1} || 0;
	my $col = $param{color} || 'none';
	my $class = $param{class} || 'none';
	my $raise = $param{'raise'} || 0;
	my $parent = $param{'parent'} || $SBV::svg;
	my $filter = $param{'filter'};
	
	my $fan = $parent->group(id=>"g$SBV::idnum",transform=>"translate($cx,$cy)");
	$SBV::idnum ++;

	my $angle1 = nearest 0.00001 , ($TWOPI*$sta/$size);
	my $angle2 = nearest 0.00001 , ($TWOPI*$end/$size);
	($angle1,$angle2) = ($angle2,$angle1) if ($angle2<$angle1);
	
	$cx = 0;
	$cy = 0;
	my $x1 = nearest 0.00001 , ($cx + sin($angle1)*$r1);
	my $y1 = nearest 0.00001 , ($cy - cos($angle1)*$r1); 
	my $x2 = nearest 0.00001 , ($cx + sin($angle1)*$r2);
	my $y2 = nearest 0.00001 , ($cy - cos($angle1)*$r2);
	my $x3 = nearest 0.00001 , ($cx + sin($angle2)*$r2);
	my $y3 = nearest 0.00001 , ($cy - cos($angle2)*$r2);
	my $x4 = nearest 0.00001 , ($cx + sin($angle2)*$r1);
	my $y4 = nearest 0.00001 , ($cy - cos($angle2)*$r1);

	my $flag = ($angle2 - $angle1) > $PI ? 1 : 0;
	
	my $style = {fill=>$col} ;
	if ($filter)
	{
		my $filterid = SBV::STONE::FILTER::filter($filter);
		$style->{filter} = "url(#$filterid)";
	}
	my %path = (
		d => "M$x2 $y2 A$r2 $r2 $angle1 $flag 1 $x3 $y3 L$x4 $y4 A$r1 $r1 $angle1 $flag 0 $x1 $y1 Z",
		style => $style);

	$path{"class"} = $class if ($class ne "none");
	
	my ($angle,$tx,$ty);
	if ($raise != 0)
	{
		$angle = ($angle1 + $angle2)/2;
		$tx = nearest 0.00001 , $raise*sin($angle);
		$ty = nearest 0.00001 , -1*$raise*cos($angle);

		$path{"transform"} = "translate($tx,$ty)";	
	}

	$fan->path(%path);

	# draw mark
	if ($param{'mark'})
	{
		my $markFont = SBV::Font->fetch_font('CLASSmark');
		
		#my $markH = $markFont->fetch_text_height;
		my $markW = $markFont->fetch_text_width($param{'mark'});

		my $marklen = 10;
		my $angle = 180*($sta+$end)/$size;
		my $mark;
		if ($raise != 0)
		{
			$mark = $fan->group(transform=>"translate($tx,$ty)")->group(
				transform=>"rotate($angle,$cx,$cy)",class=>"mark");
		}
		else
		{
			$mark = $fan->group(transform=>"rotate($angle,$cx,$cy)",class=>"mark");
		}
		
		$mark->line(x1=>$cx,x2=>$cx,y1=>$cy-$r2,y2=>$cy-$r2-$marklen);
		$mark->text(x=>$cx-$markW/2,y=>$cy-$r2-$marklen-4)->cdata($param{'mark'});
	}
}


#-------------------------------------------------------------------------------
#  draw arrow, add the arrow tail marker to SBV::defs
#  $w: the arrow head width 
#  $h: the arrow head height
#  %par: other parameter, like -class and -style
#-------------------------------------------------------------------------------
sub arrow
{
	my ($w,$h,%par) = @_;
	
	# $zh: the arrow head zipper head, 0-1 of $w
	my $zh = defined $par{'-zh'} ? $par{'-zh'} : 1;
	$zh = 1 if ($zh < 0 || $zh > 1);
	my $zhx = $zh * $w;
	my $halfh = $h/2;

	my $markid = "marker" . $SBV::idnum;
	$SBV::idnum ++;

	my $marker = $SBV::defs->marker(
		refX => $w, refY => $h/2, # the basic point coord, is very important
		markerWidth=>$w,markerHeight=>$h,orient => 'auto',
		markerUnits => 'strokeWidth',id=>$markid);
	$marker->setAttribute('style',$par{-style}) if ($par{-style});	
	$marker->setAttribute('class',$par{-class}) if ($par{-class});

	$marker->path(d => "M0,0 L$w,$halfh L0,$h L$zhx,$halfh z");

	return $markid;
}

#-------------------------------------------------------------------------------
#  draw arrow shape 
#-------------------------------------------------------------------------------
sub arrow2
{
	my ($x,$y,$w,$h,%par) = @_;
	my $parent = $par{parent} || $SBV::svg;
	my $style = $par{style} || {};
	my $strand = $par{strand} || 1;
	my $aw = exists $par{arrow_width} ? $par{arrow_width}*$h : $h;

	# the ratio of line height / the arrow height
	my $ratio = $par{ratio} || 0.5;
	my $uhratio = 0.5 - $ratio * 0.5;
	my $dhratio = 0.5 + $ratio * 0.5;
	
	my (@px,@py);

	if (1 == $strand)
	{
		if ($w > $aw)
		{
			@px = ($x,$x+$w-$aw,$x+$w-$aw,$x+$w,$x+$w-$aw,$x+$w-$aw,$x);
			@py = ($y+$h*$uhratio,$y+$h*$uhratio,$y,$y+$h*0.5,$y+$h,$y+$h*$dhratio,$y+$h*$dhratio);
		}
		else 
		{
			@px = ($x,$x+$w,$x);
			@py = ($y,$y+$h*0.5,$y+$h);
		}
	}
	else 
	{
		if ($w > $aw)
		{
			@px = ($x,$x+$aw,$x+$aw,$x+$w,$x+$w,$x+$aw,$x+$aw);
			@py = ($y+$h*0.5,$y,$y+$h*$uhratio,$y+$h*$uhratio,$y+$h*$dhratio,$y+$h*$dhratio,$y+$h);
		}
		else 
		{
			@px = ($x+$w,$x+$w,$x);
			@py = ($y,$y+$h,$y+$h*0.5);
		}
	}
	
	my $points = $parent->get_path(x=>\@px,y=>\@py,-type=>'polygon');
	$parent->polygon(%$points,style=>$style);

	return 1;
}

#-------------------------------------------------------------------------------
#  draw pencil shape
#-------------------------------------------------------------------------------
sub pencil
{
	my ($x,$y,$w,$h,%par) = @_;
	my $parent = $par{parent} || $SBV::svg;
	my $style = $par{style} || {};
	my $strand = $par{strand} || 1;
	
	my $aw;
	if (exists $par{arrow_width} && $par{arrow_width} ne "auto")
	{
		$aw =  $par{arrow_width}*$h;
	}
	else 
	{
		if ($w > 2*$h)
		{
			$aw = $h;
		}
		elsif ($w > $h/2) 
		{
			$aw = $w/2;
		}
		else 
		{
			$aw = $h;
		}
	}

	# my $aw = exists $par{arrow_width} ? $par{arrow_width}*$h : $h;
	
	my (@px,@py);

	if (1 == $strand)
	{
		if ($w > $aw)
		{
			@px = ($x,$x+$w-$aw,$x+$w,$x+$w-$aw,$x);
			@py = ($y,$y,$y+$h/2,$y+$h,$y+$h);
		}
		else
		{
			@px = ($x,$x+$w,$x);
			@py = ($y,$y+$h/2,$y+$h);
		}
	}
	else # strand == -1
	{
		if ($w > $aw)
		{
			@px = ($x+$w,$x+$w,$x+$aw,$x,$x+$aw);
			@py = ($y,$y+$h,$y+$h,$y+$h/2,$y);
		}
		else
		{
			@px = ($x+$w,$x+$w,$x);
			@py = ($y,$y+$h,$y+$h/2);
		}
	}

	my $points = $parent->get_path(x=>\@px,y=>\@py,-type=>'polygon');
	$parent->polygon(%$points,style=>$style);

	return 1;
}


=head1 Name
    
mirror

=head1 Synopsis

=head2 Synopsis1

line formula: mirror($k,$b)
$k is slope
$b is intercept, can be omited, default is 0

=head2 Synopsis2

two points: mirror($x1,$y1,$x2,$y2)

=head1 Function

generate matrix for SVG transform for drawing image mirror

=cut
sub mirror
{
	my ($k,$b);
	my $num = scalar @_;
	if ($num == 1)
	{
		$k = shift;
		$b = 0;
	}
	elsif ($num == 2)
	{
		($k,$b) = @_;
	}
	elsif ($num == 4)
	{
		my($x1,$y1,$x2,$y2) = @_;

		if ($x2 - $x1 == 0)
		{
			my $temp = 2*$x1;
			return "matrix(-1,0,0,1,$temp,0)";
		}
		else
		{
			$k = ($y2-$y1)/($x2-$x1);
			$b = ($x2*$y1-$x1*$y2)/($x2-$x1);
		}
	}
	else
	{
		die "ERROR: parameter ERROR!\n";
	}

	my $ma = (1-$k*$k)/(1+$k*$k);
	my $mb = 2*$k/(1+$k*$k);
	my $me = -2*$k*$b/(1+$k*$k);

	my $mc = 2*$k/(1+$k*$k);
	my $md = ($k*$k-1)/(1+$k*$k);
	my $mf = 2*$b/(1+$k*$k);

	return "matrix($ma,$mb,$mc,$md,$me,$mf)";
}

# draw background and border
sub background
{
	my $conf = shift || $SBV::conf;
	my $parent = shift || $SBV::svg;
	
	my $x = $conf->{ox};
	my $y = $conf->{oty};
	my $w = $conf->{tw};
	my $h = $conf->{th};
	
	# background
	if (my $bg = $conf->{background})
	{   
		if ($bg =~ /^url:(.+)/)
		{   
			$parent -> image(x=>$x,y=>$y,height=>$h,width=>$w,'-href'=>$conf->{background});
		}   
		else
		{   
			$bg = fetch_color($bg);
			$parent -> rect(x=>$x,y=>$y,height=>$h,width=>$w,style=>{fill=>$bg,'stroke-width'=>0},class=>"background");
		} 
	}

	#border
	if ($conf->{border})
	{
		my $border = $parent->group(class=>"border",id=>"g$SBV::idnum");
		$SBV::idnum ++;

		my @flag = split "" , $conf->{border};
		
		$border->line(x1=>$x,y1=>$y,x2=>$x+$w,y2=>$y) if ( 1 == loop_arr(\@flag,0) );
		$border->line(x1=>$x+$w,y1=>$y,x2=>$x+$w,y2=>$y+$h) if ( 1 == loop_arr(\@flag,1) );
		$border->line(x1=>$x+$w,y1=>$y+$h,x2=>$x,y2=>$y+$h) if ( 1 == loop_arr(\@flag,2) );
		$border->line(x1=>$x,y1=>$y+$h,x2=>$x,y2=>$y) if ( 1 == loop_arr(\@flag,3) );
	}
}

# draw arc
sub arc
{
	my ($cx,$cy,$r,$size,$sta,$end,%param) = @_;

	# 1 means + , 0 means -
	my $strand = $param{strand} || "+";
	$strand = $strand eq "+" ? 1 : 0;

	my $parent = $param{parent} || $SBV::svg;
	my $class = $param{class} || "none";
	my $markid = $param{marker};

	my $angle1 = nearest 0.00001 , ($TWOPI*$sta/$size);
	my $angle2 = nearest 0.00001 , ($TWOPI*$end/$size);
	
	($angle1,$angle2) = ($angle2,$angle1) if (0 == $strand);

	my $x1 = nearest 0.00001 , ($cx + sin($angle1)*$r);
	my $y1 = nearest 0.00001 , ($cy - cos($angle1)*$r); 
	my $x2 = nearest 0.00001 , ($cx + sin($angle2)*$r);
	my $y2 = nearest 0.00001 , ($cy - cos($angle2)*$r);

	my $flag = abs($angle2 - $angle1) > $PI ? 1 : 0;
	
	my %path = (d => "M$x1 $y1 A$r $r $angle1 $flag $strand $x2 $y2");
	$path{"class"} = $class if ($class ne "none");
	$path{"marker-end"} = "#$markid" if (defined $markid);

	$parent->path(%path);
}

# draw side space 
# x,y axis and title, graph title
sub side_space
{
	my $conf = shift;
	my $side = shift;
	my $parent = shift || $SBV::svg; 

	title($conf,,$parent);
	xlab($conf,$side,$parent);
	ylab($conf,$side,$parent);
	my $xaxis = xaxis($conf,$side,$parent);
	my $yaxis = yaxis($conf,$side,$parent);
	
	return ($xaxis,$yaxis);
}

# add title to map
sub title 
{
	my ($conf,$parent) = @_;
	
	if ($conf->{title})
	{
		my $font = SBV::Font->fetch_font('CLASStitle');
		my $textH = $font->fetch_text_height;
		my $textW = $font->fetch_text_width($conf->{title});

		my $y = $conf->{oty} - $SBV::conf->{vspace};
		my $x = $conf->{ox} + $conf->{tw}/2 - $textW/2;

		$parent->text(class=>"title",x=>$x,y=>$y)->cdata($conf->{title});
	}
}

sub xlab
{
	my ($conf,$side,$parent) = @_;

	if ($conf->{xlab})
	{
		my $font = SBV::Font->fetch_font('CLASSsubtitle');
		my $textH = $font->fetch_text_height;
		my $textW = $font->fetch_text_width($conf->{xlab});

		my $x = $conf->{ox} + $conf->{tw}/2 - $textW/2;
		my $y = $conf->{oy} + $side->{xaxis} + $side->{xlab} - $SBV::conf->{vspace};
		$parent->text(class=>"subtitle",x=>$x,y=>$y)->cdata($conf->{xlab});
	}
}

sub ylab
{
	my ($conf,$side,$parent) = @_;
	
	if ($conf->{ylab})
	{
		my $font = SBV::Font->fetch_font('CLASSsubtitle');
		my $textH = $font->fetch_text_height;
		my $textW = $font->fetch_text_width($conf->{ylab});

		my $x = $conf->{ox} - $side->{yaxis} - $SBV::conf->{hspace};
		my $y = $conf->{oy} - $conf->{th}/2 + $textW/2;

		$parent->text(class=>"subtitle",x=>$x,y=>$y,transform=>"rotate(-90,$x,$y)")->cdata($conf->{ylab});
	}
}

sub xaxis
{
	my ($conf,$side,$parent) = @_;

	my %par = (parent=>$parent,ox=>$conf->{ox},oy=>$conf->{oy},length=>$conf->{tw},
		tick=>$side->{xscale},bgline=>$conf->{th},side=>'right');
	$par{translate} = 0.5 if ($side->{names});
	$par{bgline} = 0 if (defined $conf->{xbgline} && 0 == $conf->{xbgline});
	$par{theme} = $conf->{xaxis_theme} if ($conf->{xaxis_theme});
	
	my $xaxis = SBV::STONE::AXIS->new(%par);
	$xaxis->plot();
	
	return $xaxis;
}

sub yaxis 
{
	my ($conf,$side,$parent) = @_;
	my %par = (parent=>$parent,ox=>$conf->{ox},oy=>$conf->{oy},length=>$conf->{th},
		tick=>$side->{yscale},bgline=>$conf->{tw},side=>'left',angle=>-90);

	$par{bgline} = 0 if (defined $conf->{ybgline} && 0 == $conf->{ybgline});
	$par{angle} = -90;
	$par{theme} = $conf->{yaxis_theme} if ($conf->{yaxis_theme});

	my $yaxis = SBV::STONE::AXIS->new(%par);
	$yaxis->plot();

	return $yaxis;
}

# add text to SVG graph
sub text
{
	my ($str,$x,$y,%opts) = @_;
	
	my $class = $opts{class} ? "CLASS" . $opts{class} : "defalt";
	my $font = SBV::Font->fetch_font($class);
	my $fontH = nearest 0.001 , $font->fetch_text_height;
	my $fontW = nearest 0.001 , $font->fetch_text_width($str);
	
	my $parent = $opts{parent} || $SBV::svg;
	my $xalign = $opts{xalign} || "center";
	my $yalign = $opts{yalign} || "center";

	my ($newx,$newy);

	if ($xalign eq "center")
	{
		$newx = $x - $fontW/2;	
	}
	elsif ($xalign eq "left")
	{
		$newx = $x;	
	}
	elsif ($xalign eq "right")
	{
		$newx = $x - $fontW;	
	}
	else
	{
		die("x alignment must be center, left or right",$xalign);
	}
		
	if ($yalign eq "center")
	{
		$newy = $y + $fontH/2;	
	}
	elsif ($yalign eq "top")
	{
		$newy = $y + $fontH;
	}
	elsif ($yalign eq "bottom")
	{
		$newy = $y;	
	}
	else
	{
		die ("y alignment must be center, top or bottom",$yalign);	
	}
	
	my $text = $parent->text(x=>$newx,y=>$newy)->cdata($str);
	$text->setAttribute("class",$opts{class}) if ($opts{class});
	$text->setAttribute("style",$opts{style}) if ($opts{style});
	$text->setAttribute("id",$opts{id}) if ($opts{id});
	
	return $text;
}	

# add text to SVG with text theme
sub theme_text
{
	my ($parent,$x,$y,$theme,$cdata) = @_;
	
	# set the start postion of the text, set by hjust and vjust attributes
	my $font = SBV::Font->new($theme);
	my $textH = $font->fetch_text_height();
	my $textW = $font->fetch_text_width($cdata);
	my $startx = $x;
	my $starty = $y;
	

	if ($font->{hjust})
	{
		$startx = $x - $textW * $font->{hjust};
		delete $font->{hjust};
	}

	if ($font->{vjust})
	{
		$starty = $y + $textH * $font->{vjust};
		delete $font->{hjust};
	}
	
	my $text = $parent->text(x=>$startx,y=>$starty)->cdata($cdata);

	if (exists $font->{'font-angle'})
	{
		$text->setAttribute("transform","rotate($font->{'font-angle'},$x,$y)");
		delete $font->{'font-angle'};
	}
	
	$text->setAttribute("style",$font->toStyle);
}

#-------------------------------------------------------------------------------
#  name: fixText -- fix the text height and width 
#-------------------------------------------------------------------------------
sub fixText
{
	my ($x,$y,$width,$height,$str,$style,$class,$parent) = @_;

	my $font = SBV::Font->fetch_font($class);
	my $textH = $font->fetch_text_height;
	my $textW = $font->fetch_text_width($str);
	my $sx = nearest 0.01 , $width / $textW;
	my $sy = nearest 0.01 , $height / $textH;

	$parent->group(transform=>"translate($x,$y)")->text(x=>0,y=>$textH,style=>$style,
		class=>$class,transform=>"scale($sx,$sy)")->cdata($str);	
}

#-------------------------------------------------------------------------------
# add multi line text to SVG graph
#-------------------------------------------------------------------------------
sub mtext
{
	my ($str,$x,$y,%opts) = @_;
	
	my $lineN = scalar @$str;
	my $class = defined $opts{class} ? "CLASS" . $opts{class} : "default";
	my $font = SBV::Font->fetch_font($class);
	my $fontH = nearest 0.001 , $font->fetch_text_height;
	my $fontW = $font->fetch_max_text_width($str);
	
	# line space of multi line text
	my $space = defined $opts{space} ? $opts{space} : $SBV::conf->{vspace};
	my $sumH = $fontH*$lineN + $space*($lineN-1);
	
	my $parent = $opts{parent} || $SBV::svg;
	my $xalign = $opts{xalign} || "center";
	my $yalign = $opts{yalign} || "center";

	my ($newx,$newy);

	if ($yalign eq "center")
	{
		$newy = $y - $sumH/2;
	}
	elsif ($yalign eq "top")
	{
		$newy = $y;
	}
	elsif ($yalign eq "bottom")
	{
		$newy = $y - $sumH;	
	}
	
	my $textg = $parent->group();
	$textg->setAttribute(id=>$opts{id}) if (defined $opts{id});

	#$newy -= $sumH;
	for my$i(0 .. $#$str)
	{
		my $tempx; 
		my $tempW = $font->fetch_text_width($str->[$i]);
		if ($xalign eq "center")
		{
			$tempx = $x - $tempW/2;
		}
		elsif ($xalign eq "left")
		{
			$tempx = $x - $fontW;
		}
		elsif ($xalign eq "right")
		{
			$tempx = $x;
		}
		else
		{
			die("x alignment must be center, left or right",$xalign);
		}

		my $tempy = $newy + ($i+1)*$fontH + $i*$space;

		my $text = $textg->text(x=>$tempx,y=>$tempy)->cdata($str->[$i]);
		$text->setAttribute("class",$opts{class}) if ($opts{class});
		$text->setAttribute("style",$opts{style}) if ($opts{style});
	}

	return $textg;
}

# draw the comboText with diff font style 
sub comboText
{
	my ($x,$y,$cdata,$parent,%par) = @_;
	my $class = $par{class} || "default";
	my $style = $par{style} || {};

	my $text = $parent->text(x=>$x,y=>$y)->cdata($cdata);
	$text->setAttribute("class",$par{class}) if ($par{class});
	$text->setAttribute("style",$par{style}) if ($par{style});

	return $text;
}

# resize the SVG
sub resize
{
	my %par = @_;

	my $root = $SBV::svg->getElementByID("sbv1");
	my $margin = SBV::CONF::fetch_margin();
	my @rects = $SBV::svg->getElements("rect");
	my $bgrect = $rects[-1];

	if ($par{width})
	{
		$root->setAttribute('width',$par{width});
		$bgrect->setAttribute('height',$par{width}-$margin->{left}-$margin->{right}) if ($par{bg});
	}

	if ($par{height})
	{
		$root->setAttribute('height',$par{height});
		$bgrect->setAttribute('height',$par{height}-$margin->{top}-$margin->{bottom}) if ($par{bg});
	}
}

#------------------
# for js
#------------------
# plot mouse move event
# get the mouse point coordinate
# draw horizontal and vertical line
sub plotMouseMove
{
	my $parent = shift;
	my $xaxis = shift;
	my $yaxis = shift;
	my %param = @_;

	my $evt = $param{evt} || "onclick"; # you can set it as onmousemove
	my $lineCol = $param{col} || "#99f";
	
	my $pid = $parent->getElementID();
	$parent->setAttributes(
		{
			$evt=>"plotMove(evt)",
			"onmouseout"=>"plotOut(evt)"
		}
	);
	
	my $id = "plotMove$SBV::idnum";
	$SBV::idnum ++;

	my $ox = $xaxis->{ox};
	my $oy = $xaxis->{oy};
	my $xmax = $xaxis->{ox} + $xaxis->{length};
	my $ymin = $yaxis->{oy} - $yaxis->{length};

	my $xaxis_min = $xaxis->{min} - ($xaxis->{start} - $xaxis->{translate})*$xaxis->{window};
	my $xaxis_zoom = $xaxis->{zoom};
	my $yaxis_min = $yaxis->{min} - ($yaxis->{start} - $yaxis->{translate})*$yaxis->{window};
	my $yaxis_zoom = $yaxis->{zoom};

	my $js = <<JS;
var svgdoc;
var xpos;
var ypos;
var svgns = "http://www.w3.org/2000/svg";
var isIE = document.all?true:false;

function plotMove(evt)
{
	svgdoc = evt.target.ownerDocument;
	
	getMousePosition(evt);

	var xval = $xaxis_zoom * (xpos-$ox) + $xaxis_min;
	var yval = $yaxis_zoom * ($oy-ypos) + $yaxis_min;
	xval = xval.toFixed(1);
	yval = yval.toFixed(1);
	
	if (xpos > $ox && xpos < $xmax && ypos < $oy && ypos > $ymin)
	{
		var move = svgdoc.getElementById("$id");

		if (move)
		{
			var circle = svgdoc.getElementById("$id\_circle");
			circle.setAttribute("cx",xpos);
			circle.setAttribute("cy",ypos);

			var hline = svgdoc.getElementById("$id\_hline");
			hline.setAttribute("y1",ypos);
			hline.setAttribute("y2",ypos);

			var vline = svgdoc.getElementById("$id\_vline");
			vline.setAttribute("x1",xpos);
			vline.setAttribute("x2",xpos);

			var text = svgdoc.getElementById("$id\_text");
			text.setAttribute("x",xpos+2);
			text.setAttribute("y",ypos-2);
			var textNode = svgdoc.createTextNode(xval+","+yval);
			text.replaceChild(textNode,text.firstChild);
		}
		else
		{
			var plot = svgdoc.getElementById("$pid");
			move = document.createElementNS(svgns,"g");
			move.setAttribute("id","$id");
			plot.appendChild(move);

			var circle = svgdoc.createElementNS(svgns,"circle");
			circle.setAttribute("cx",xpos);
			circle.setAttribute("cy",ypos);
			circle.setAttribute("r",2);
			circle.setAttribute("style","fill:$lineCol");
			circle.setAttribute("id","$id\_circle");
			move.appendChild(circle);

			var hline = svgdoc.createElementNS(svgns,"line");
			hline.setAttribute("x1",$ox);
			hline.setAttribute("x2",$xmax);
			hline.setAttribute("y1",ypos);
			hline.setAttribute("y2",ypos);
			hline.setAttribute("style","stroke:$lineCol;stroke-width:1");
			hline.setAttribute("id","$id\_hline");
			move.appendChild(hline);

			var vline = svgdoc.createElementNS(svgns,"line");
			vline.setAttribute("x1",xpos);
			vline.setAttribute("x2",xpos);
			vline.setAttribute("y1",$ymin);
			vline.setAttribute("y2",$oy);
			vline.setAttribute("style","stroke:$lineCol;stroke-width:1");
			vline.setAttribute("id","$id\_vline");
			move.appendChild(vline);
			
			var text = svgdoc.createElementNS(svgns,"text");
			text.setAttribute("x",xpos+2);
			text.setAttribute("y",ypos-2);
			text.setAttribute("style","font-size:10;font-family:Arial");
			text.setAttribute("id","$id\_text");
			
			var textNode = svgdoc.createTextNode(xval+","+yval);
			text.appendChild(textNode);
			move.appendChild(text);
		}
	}
}

function plotOut(evt)
{
	svgdoc = evt.target.ownerDocument;
	var plot = svgdoc.getElementById("$pid");
	var move = svgdoc.getElementById("$id");
	
	getMousePosition(evt);

	if (xpos < $ox || xpos > $xmax || ypos > $oy || ypos < $ymin)
	{
		plot.removeChild(move);
	}
}

function getMousePosition(evt)
{
	var _x;
	var _y;

	if (!isIE)
	{
		_x = evt.pageX;
		_y = evt.pageY;
	}
	else
	{
		_x = event.clientX + document.body.scrollLeft;
		_y = event.clientY + document.body.scrollTop;
	}

	xpos = _x;
	ypos = _y;

	return true;
}
JS

	$SBV::svg->script(type=>"text/javascript")->CDATA($js);
}

sub chrLocMouseMove
{
	
}

sub vennOnclick
{
	
}
